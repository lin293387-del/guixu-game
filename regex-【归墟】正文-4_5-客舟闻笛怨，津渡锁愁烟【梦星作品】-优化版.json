{
  "id": "e853883a-9ad4-4de2-84ee-4cd0ace04f92-optimized",
  "scriptName": "【归墟】正文-4.5-客舟闻笛怨，津渡锁愁烟【梦星作品】-优化版",
  "findRegex": "</UpdateVariable>",
  "replaceString": "</UpdateVariable>\\n```\\n<!DOCTYPE html><!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 --><html lang=\"zh-CN\"><head><meta charset=\"UTF-8\" /><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /><title>归墟 - 宿命轮回</title><style> :root { /* 主题颜色变量 */ --color-primary: #c9aa71; --color-secondary: #8b7355; --color-accent: #ff6b6b; --color-bg-dark: rgba(26, 26, 46, 0.8); --color-bg-light: rgba(45, 27, 61, 0.5); --color-text: #e0dcd1; --color-border: rgba(201, 170, 113, 0.3); /* 布局变量 */ --border-radius: var(--border-radius); --border-radius-small: 4px; --border-radius-large: 12px; --border-width: 1px; --spacing-small: 4px; --spacing-medium: 8px; --spacing-large: 16px; /* 动画变量 */ --transition-fast: 0.2s; --transition-normal: 0.3s; --transition-slow: 0.4s; --animation-timing: cubic-bezier(0.4, 0, 0.2, 1); /* z-index层级 */ --z-dropdown: 1000; --z-modal: 1001; --z-tooltip: 1002; } /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */ @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&family=Ma+Shan+Zheng&display=swap'); /* --- 基础与布局 --- */ .guixu-root { font-family: 'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif; --overlay-opacity: 1; /* 默认完全不透明 */ background-size: cover; background-position: center; background-repeat: no-repeat; color: var(--color-primary); border: var(--border-width) solid var(--color-primary); border-radius: var(--border-radius); overflow: hidden; max-width: 100%; margin: auto; box-shadow: 0 0 15px rgba(201, 170, 113, 0.2); position: relative; width: 100%; /* aspect-ratio: 16 / 9; */ /* 移除宽高比，使用固定高度 */ max-width: 900px; /* 恢复原始宽度 */ } .guixu-root::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(26, 26, 46, var(--overlay-opacity, 1)); pointer-events: none; z-index: -1; top: 0; left: 0; right: 0; bottom: 0; background: rgba(15, 15, 35, 0.7); z-index: 1; } .game-container { position: relative; z-index: 2; display: grid; grid-template-rows: 65px 1fr auto; /* 让底部栏高度自适应 */ grid-template-columns: 220px 1fr 160px; width: 100%; height: 600px; /* 固定高度以便滚动 */ transition: grid-template-columns 0.3s cubic-bezier(0.4, 0, 0.2, 1); } /* 面板折叠状态 - 为按钮预留空间 */ .game-container.left-panel-collapsed { grid-template-columns: 20px 1fr 160px; } .game-container.right-panel-collapsed { grid-template-columns: 220px 1fr 20px; } .game-container.both-panels-collapsed { grid-template-columns: 20px 1fr 20px; } .guixu-root * { margin: 0; padding: 0; box-sizing: border-box; } /* --- 各面板样式 --- */ .status-top { grid-column: 1 / -1; background: linear-gradient( 90deg, rgba(26, 26, 46, 0.8) 0%, rgba(45, 27, 61, 0.8) 50%, rgba(26, 26, 46, 0.8) 100% ); border-bottom: 1px solid #c9aa71; display: flex; align-items: center; justify-content: space-around; padding: 0 10px; box-shadow: 0 1px 8px rgba(201, 170, 113, 0.15); } .status-item { display: flex; flex-direction: column; align-items: center; gap: var(--spacing-small); } .status-label { font-size: 11px; color: var(--color-secondary); } .status-value { font-size: 14px; color: var(--color-primary); font-weight: bold; } .progress-bar { width: 100% !important; height: 5px; background: rgba(0, 0, 0, 0.5); border-radius: 3px; overflow: hidden; border: var(--border-width) solid var(--color-primary); display: block; box-sizing: border-box; } .progress-fill { height: 100%; background: linear-gradient(90deg, #ff6b6b, #ffd93d); border-radius: 2px; } .guixu-charge { width: 100px; height: 6px; background: rgba(0, 0, 0, 0.7); border-radius: var(--border-radius-small); border: 1px solid #8b4513; overflow: hidden; } .guixu-fill { height: 100%; background: linear-gradient(90deg, #dc143c, #ff6b6b, #ffd700); width: var(--guixu-charge, 0%); border-radius: 3px; } .char-panel { background: rgba(26, 26, 46, 0.5); border-right: none; padding: 10px; overflow-y: auto; overflow-x: hidden; position: relative; transition: all var(--transition-normal) var(--animation-timing); } /* 面板折叠按钮样式 - 细长状紫色风格，位于面板外部 */ .panel-toggle-btn { position: absolute; top: 50%; transform: translateY(-50%); width: 14px; height: 80px; /* 减短按钮长度 */ background: transparent; border: 1px solid rgba(75, 57, 91, 0.6); border-radius: var(--border-radius); cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: var(--z-dropdown); transition: all var(--transition-normal) var(--animation-timing); font-size: 9px; color: #e8dcc6; font-weight: bold; box-shadow: none; opacity: 0.7; } /* 左侧按钮位于面板外部右侧 */ .left-panel-toggle { right: -8px; /* 移到面板外部 */ } /* 右侧按钮位于面板外部左侧 */ .right-panel-toggle { left: -8px; /* 移到面板外部 */ } .panel-toggle-btn:hover { background: transparent; border-color: rgba(201, 170, 113, 0.8); transform: translateY(-50%) scale(1.1); color: #fff; opacity: 1; } .panel-toggle-btn .toggle-arrow { transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); font-weight: bold; } /* 面板完全隐藏状态 - 只保留按钮可见 */ .character-panel.collapsed { padding: 0; overflow: visible; /* 允许按钮显示在外面 */ background: rgba(0, 0, 0, 0.2); border: none; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); } /* 隐藏左侧面板的所有内容，除了折叠按钮 */ .character-panel.collapsed> *:not(.left-panel-toggle) { display: none !important; } .interaction-panel.collapsed { padding: 0; overflow: visible; /* 允许按钮显示在外面 */ background: rgba(0, 0, 0, 0.2); border: none; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); } /* 隐藏右侧面板的所有内容，除了折叠按钮 */ .interaction-panel.collapsed> *:not(.right-panel-toggle) { display: none !important; } /* 折叠按钮在隐藏状态下的居中定位 */ .character-panel.collapsed .left-panel-toggle { right: 3px; /* 在20px预留空间内居中 */ left: auto; background: transparent; border: 1px solid rgba(75, 57, 91, 0.6); opacity: 0.9; } .interaction-panel.collapsed .right-panel-toggle { left: 3px; /* 在20px预留空间内居中 */ right: auto; background: transparent; border: 1px solid rgba(75, 57, 91, 0.6); opacity: 0.9; } /* 桌面端专用样式 */ @media (max-width: 768px) { .panel-toggle-btn { display: none; } } .panel-section { margin-bottom: 15px; padding: var(--spacing-medium); background: rgba(0, 0, 0, 0.3); border-radius: 5px; border: var(--border-width) solid var(--color-border); overflow: hidden; transition: all var(--transition-normal) ease; } .section-title { font-size: 13px; color: var(--color-primary); margin-bottom: 8px; text-align: center; border-bottom: 1px solid rgba(201, 170, 113, 0.3); padding-bottom: 4px; } .equipment-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; } .equipment-slot { aspect-ratio: 1; background: rgba(0, 0, 0, 0.5); border: 1px dashed rgba(201, 170, 113, 0.5); border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: var(--color-secondary); cursor: pointer; transition: background-color 0.3s; } .equipment-slot.equipped { border-style: solid; color: #e0dcd1; font-size: 12px; } .equipment-slot:hover { background: rgba(201, 170, 113, 0.1); } .attributes-list { display: flex; flex-direction: column; gap: 6px; width: 100%; } .details-container { margin-bottom: 5px; } .details-container summary { cursor: pointer; display: flex; justify-content: space-between; font-size: 11px; list-style: none; /* 隐藏默认箭头 */ } .details-container summary::-webkit-details-marker { display: none; /* 隐藏默认箭头 */ } .details-content { padding: var(--spacing-medium); margin-top: 4px; font-size: 11px; background: rgba(0, 0, 0, 0.2); border-radius: var(--border-radius-small); border-top: 1px solid rgba(201, 170, 113, 0.2); color: #a09c91; } .details-content p { margin-bottom: 4px; } .attribute-item { display: flex; justify-content: space-between; font-size: 11px; } .attribute-name { color: var(--color-secondary); } .attribute-value { color: var(--color-primary); font-weight: bold; } .interaction-panel { background: var(--color-bg-light); border-left: none; padding: 10px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; /* 新增：允许交互面板在内容过多时滚动 */ overflow-x: hidden; /* 防止横向滚动条 */ position: relative; transition: all var(--transition-normal) var(--animation-timing); } .main-buttons-container { display: contents; } .interaction-btn { padding: 10px 8px; background: linear-gradient(45deg, #1a1a2e, #2d1b3d); border: var(--border-width) solid var(--color-primary); border-radius: 5px; color: var(--color-primary); font-size: 12px; cursor: pointer; text-align: center; transition: all var(--transition-normal) ease; } .interaction-btn:hover { background: linear-gradient(45deg, #2d1b3d, #3d2b4d); } /* 专用于底部发送/历史记录按钮的小尺寸样式 */ .bottom-bar-btn { padding: 6px 4px; font-size: 10px; } .btn-danger { background: linear-gradient(45deg, #8b0000, #c0392b); color: #fff; border-color: #c0392b; } .world-line-section { border-top: 1px solid rgba(201, 170, 113, 0.5); padding-top: 10px; margin-top: auto; } .world-line-title { font-size: 10px; color: var(--color-secondary); text-align: center; margin-bottom: 6px; } .primary-btn { background: linear-gradient(45deg, #8b4513, #cd853f); border-color: #daa520; color: #fff; } .auto-write-section { display: flex; align-items: center; gap: var(--spacing-medium); margin-top: 15px; /* 与上方内容隔开 */ padding-top: 15px; /* 与上方内容隔开 */ border-top: 1px solid rgba(201, 170, 113, 0.3); /* 分割线 */ } .auto-write-label { font-size: 12px; color: var(--color-secondary); cursor: pointer; } #auto-write-checkbox { cursor: pointer; } .primary-btn:hover { background: linear-gradient(45deg, #cd853f, #daa520); } .status-bottom { grid-column: 1 / -1; background: linear-gradient( 90deg, rgba(45, 27, 61, 0.8) 0%, rgba(26, 26, 46, 0.8) 50%, rgba(45, 27, 61, 0.8) 100% ); border-top: 1px solid #c9aa71; display: flex; align-items: center; justify-content: space-between; gap: 15px; padding: 0 15px; transition: height 0.2s ease-in-out; } .send-container { display: flex; align-items: center; gap: var(--spacing-medium); flex-grow: 1; /* Allow it to take up space */ justify-content: center; /* Center the input and buttons within */ } .send-input { background: rgba(0, 0, 0, 0.5); border: 1px solid #8b7355; border-radius: var(--border-radius-small); color: #e0dcd1; padding: 5px 10px; font-size: 12px; width: 100%; flex-grow: 1; /* Make the input take up available space */ max-width: 500px; height: 32px; resize: none; line-height: 1.5; font-family: inherit; overflow-y: auto; transition: height 0.2s ease-in-out; } .send-button-row { display: flex; gap: 10px; } .send-button-row button { width: 90px; text-align: center; } .send-input:focus { height: 80px; } .send-input::placeholder { color: var(--color-secondary); } /* --- 新增：快速指令弹出菜单 --- */ #quick-command-popup { display: none; position: absolute; bottom: 65px; /* 增加bottom值，将菜单上移 */ right: 175px; /* 大致对齐到快速发送区域 */ background: rgba(15, 15, 35, 0.98); border: var(--border-width) solid var(--color-primary); border-radius: 6px; z-index: var(--z-tooltip); width: 280px; max-height: 200px; overflow-y: auto; box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.5); } .quick-command-list { list-style: none; padding: 5px; margin: 0; } .quick-command-item { padding: var(--spacing-medium) 12px; color: #a09c91; font-size: 12px; /* cursor: pointer; */ /* 移除指针手势 */ border-bottom: 1px solid rgba(201, 170, 113, 0.1); transition: background-color 0.2s; } .quick-command-item:last-child { border-bottom: none; } .quick-command-item:hover { background-color: rgba(201, 170, 113, 0.15); color: #e0dcd1; } .quick-command-empty { padding: 15px; text-align: center; color: var(--color-secondary); font-style: italic; font-size: 12px; } .status-effect { display: flex; align-items: center; gap: 5px; padding: var(--spacing-small) 8px; background: rgba(0, 0, 0, 0.3); border-radius: 15px; border: var(--border-width) solid var(--color-border); white-space: nowrap; font-size: 10px; } .effect-icon { width: 14px; height: 14px; background: #c9aa71; border-radius: 50%; } /* --- 中央内容区 --- */ .main-content { padding: 20px; overflow-y: auto; background: rgba(0, 0, 0, 0.2); } .game-text-container { font-size: 14px; line-height: 1.8; color: #e0dcd1; white-space: pre-wrap; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); } .novel-chapter-title { font-size: 1.5em; font-weight: bold; text-align: center; margin-bottom: 1em; } /* --- 新增：正文染色样式 --- */ .text-language { color: #ff1493; /* 荧光粉色 */ font-style: italic; } .text-psychology { color: rgba(255, 255, 255, 0.7); /* 半透明白色 */ font-style: italic; } .text-scenery { color: #98fb98; /* 淡绿色 */ } /* --- 新增：变量改变提醒样式 --- */ .var-changes { margin-top: 15px; border: 1px solid #8b7355; border-radius: 6px; background: rgba(139, 115, 85, 0.1); overflow: hidden; } .variable-changes-header { background: rgba(139, 115, 85, 0.2); padding: var(--spacing-medium) 12px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; font-size: 13px; color: #e0dcd1; border-bottom: 1px solid rgba(139, 115, 85, 0.3); user-select: none; } .variable-changes-header:hover { background: rgba(139, 115, 85, 0.3); } .variable-changes-title { display: flex; align-items: center; gap: var(--spacing-medium); } .variable-changes-icon { font-size: 12px; transition: transform 0.2s ease; } .variable-changes-icon.collapsed { transform: rotate(-90deg); } .variable-changes-count { background: rgba(139, 115, 85, 0.4); padding: 2px 6px; border-radius: 10px; font-size: 11px; min-width: 16px; text-align: center; } .variable-changes-content { padding: 10px 12px; max-height: 200px; overflow-y: auto; display: none; } .variable-changes-content.expanded { display: block; } .variable-change-item { padding: 6px 0; border-bottom: 1px solid rgba(139, 115, 85, 0.2); font-size: 12px; color: #d4c5a9; } .variable-change-item:last-child { border-bottom: none; } .variable-change-description { margin-bottom: 3px; color: #e0dcd1; } .variable-change-comment { font-style: italic; color: #b8a082; font-size: 11px; } .variable-change-type { display: inline-block; padding: 1px 4px; border-radius: 3px; font-size: 10px; font-weight: bold; margin-right: 6px; min-width: 24px; text-align: center; } .variable-change-type.set { background: #4a90e2; color: white; } .variable-change-type.add { background: #7ed321; color: white; } .variable-change-type.assign { background: #f5a623; color: white; } .variable-change-type.remove { background: #d0021b; color: white; } /* --- 模态窗口 (Modal) 样式 --- */ .modal-overlay { display: none; /* 默认隐藏 */ position: absolute; /* 相对于 .guixu-root 定位 */ top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); justify-content: center; align-items: center; z-index: var(--z-dropdown); } .modal-content { background: rgba(26, 26, 46, 0.95); border: var(--border-width) solid var(--color-primary); border-radius: var(--border-radius); padding: 20px; width: 90%; max-width: 800px; height: 90%; /* --- 人物关系UI优化 (v3) --- */ .rel-grid { display: flex; flex-direction: column; gap: 12px; padding-right: 8px; } .rel-card { background: linear-gradient(135deg, rgba(26, 26, 46, 0.9), rgba(30, 30, 50, 0.8)); border: 1px solid rgba(85, 68, 51, 0.6); border-radius: var(--border-radius-large); padding: 20px; transition: all var(--transition-normal) var(--animation-timing); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); } .rel-card:hover { border-color: var(--color-primary); box-shadow: 0 4px 16px rgba(201, 170, 113, 0.2); transform: translateY(-2px); } .relationship-main { display: flex; flex-direction: column; gap: 12px; } .relationship-header { display: flex; justify-content: space-between; align-items: center; gap: var(--spacing-large); } .header-left { display: flex; align-items: center; gap: var(--spacing-large); } .character-name { font-size: 20px; font-weight: 600; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); } .character-relationship { font-size: 12px; color: #888; font-style: italic; } .attributes-summary { display: flex; gap: 12px; font-size: 12px; color: #ffb347; } .attr-item { font-style: italic; } .cultivation-info { font-size: 15px; color: #888; font-style: italic; font-weight: normal; } .favorability-section { display: flex; flex-direction: column; gap: var(--spacing-medium); } .favorability-value { font-size: 14px; color: var(--color-primary); font-weight: 500; } .favorability-bar { width: 100%; height: 8px; background: rgba(0, 0, 0, 0.3); border-radius: var(--border-radius-small); overflow: hidden; } .favorability-progress { height: 100%; background: linear-gradient(90deg, #d4af37, #b8860b); border-radius: var(--border-radius-small); transition: width 0.3s ease; } .relationship-details { margin-top: 16px; border-top: 1px solid rgba(85, 68, 51, 0.3); padding-top: 16px; } .details-toggle { background: none; border: none; color: var(--color-primary); font-size: 14px; font-weight: 500; cursor: pointer; padding: var(--spacing-medium) 0; display: flex; align-items: center; gap: var(--spacing-medium); transition: color 0.2s ease; } .details-toggle:hover { color: #e8d4a0; } .details-toggle::after { content: '▼'; font-size: 10px; transition: transform 0.2s ease; } .details-toggle.collapsed::after { transform: rotate(-90deg); } .details-content { display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-large); margin-top: 12px; } .details-content.hidden { display: none; } .detail-item { font-size: 13px; line-height: 1.5; color: #d4d4d4; } .detail-item strong { color: #e8e8e8; font-weight: 500; } .details-row { display: flex; flex-direction: column; gap: var(--spacing-large); } .details-section { width: 100%; } .history-section { width: 100%; } .event-history-container { border: 1px solid rgba(201, 170, 113, 0.5); border-radius: var(--border-radius); overflow: hidden; margin-top: 16px; } .event-history-summary { padding: 10px 15px; cursor: pointer; background-color: rgba(201, 170, 113, 0.1); color: var(--color-primary); font-weight: 500; list-style: none; /* 移除默认的三角箭头 */ display: flex; align-items: center; } .event-history-summary::-webkit-details-marker { display: none; /* 隐藏 Chrome/Safari 的默认箭头 */ } .event-history-summary::before { content: '▼'; font-size: 10px; margin-right: 8px; transition: transform 0.2s ease; } .event-history-container[open]> .event-history-summary::before { transform: rotate(-90deg); } .event-history-list { padding: 10px 15px 15px 30px; /* 左侧留出空间给圆点 */ margin: 0; list-style-type: disc; /* 使用实心圆点 */ color: #d4d4d4; } .event-history-list li { margin-bottom: 10px; line-height: 1.6; font-size: 13px; } .event-history-list li:last-child { margin-bottom: 0; } /* --- 新增：人物关系标签页和控制样式 --- */ .relationships-header { margin-bottom: 15px; background: rgba(20, 20, 35, 0.8); border-radius: var(--border-radius); border: 1px solid rgba(85, 68, 51, 0.4); overflow: hidden; } /* 标签页导航 */ .relationship-tabs { display: flex; background: rgba(15, 15, 25, 0.9); border-bottom: 1px solid rgba(85, 68, 51, 0.3); } .tab-btn { flex: 1; display: flex; align-items: center; justify-content: center; gap: var(--spacing-medium); padding: 12px 16px; background: transparent; border: none; color: #a0a0a0; cursor: pointer; transition: all var(--transition-normal) var(--animation-timing); position: relative; font-size: 14px; font-weight: 500; } .tab-btn:hover { background: rgba(201, 170, 113, 0.1); color: var(--color-primary); } .tab-btn.active { background: linear-gradient(135deg, rgba(201, 170, 113, 0.2), rgba(139, 115, 85, 0.15)); color: var(--color-primary); box-shadow: inset 0 -2px 0 #c9aa71; } .tab-btn.active::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #c9aa71, #8b7355); animation: tab-glow 2s ease-in-out infinite alternate; } @keyframes tab-glow { from { box-shadow: 0 0 5px rgba(201, 170, 113, 0.5); } to { box-shadow: 0 0 15px rgba(201, 170, 113, 0.8); } } .tab-icon { font-size: 16px; } .tab-text { font-weight: 600; } .tab-count { background: rgba(201, 170, 113, 0.8); color: #1a1a2e; padding: 2px 8px; border-radius: var(--border-radius-large); font-size: 12px; font-weight: bold; min-width: 20px; text-align: center; } .tab-btn.active .tab-count { background: #c9aa71; color: #1a1a2e; animation: count-pulse 1.5s ease-in-out infinite; } @keyframes count-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } } /* 控制区域 */ .relationships-controls { padding: 15px; display: flex; justify-content: space-between; align-items: center; gap: 15px; } /* 内容区域动画 */ .relationships-content { position: relative; overflow: hidden; } .rel-grid { display: flex; flex-direction: column; gap: 12px; padding-right: 8px; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); opacity: 1; transform: translateX(0); } .relationships-grid.switching { opacity: 0; transform: translateX(-20px); } .relationships-grid.intimate-mode { animation: slide-in-right 0.4s cubic-bezier(0.4, 0, 0.2, 1); } .relationships-grid.all-mode { animation: slide-in-left 0.4s cubic-bezier(0.4, 0, 0.2, 1); } @keyframes slide-in-right { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } } @keyframes slide-in-left { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } } /* --- 人物关系空状态界面样式 --- */ .rel-empty { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 40px; text-align: center; background: linear-gradient(135deg, rgba(26, 26, 46, 0.6), rgba(30, 30, 50, 0.4)); border: 2px dashed rgba(85, 68, 51, 0.4); border-radius: 16px; margin: 20px 0; min-height: 400px; } .empty-state-icon { font-size: 64px; margin-bottom: 20px; opacity: 0.7; animation: float 3s ease-in-out infinite; } @keyframes float { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-10px); } } .empty-state-title { font-size: 24px; font-weight: 600; color: var(--color-primary); margin-bottom: 16px; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); } .empty-state-description { color: #a0a0a0; font-size: 16px; line-height: 1.6; margin-bottom: 40px; max-width: 500px; } .empty-state-description p { margin: 8px 0; } .empty-state-features { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; max-width: 400px; width: 100%; } .feature-item { display: flex; align-items: center; gap: 12px; padding: var(--spacing-large); background: rgba(20, 20, 35, 0.6); border: 1px solid rgba(85, 68, 51, 0.3); border-radius: var(--border-radius-large); transition: all var(--transition-normal) ease; } .feature-item:hover { background: rgba(20, 20, 35, 0.8); border-color: rgba(201, 170, 113, 0.5); transform: translateY(-2px); } .feature-icon { font-size: 20px; opacity: 0.8; } .feature-text { color: #d4d4d4; font-size: 14px; font-weight: 500; } /* 移动端适配 */ @media (max-width: 768px) { .rel-empty { padding: 40px 20px; min-height: 300px; } .empty-state-icon { font-size: 48px; } .empty-state-title { font-size: 20px; } .empty-state-description { font-size: 14px; } .empty-state-features { grid-template-columns: 1fr; gap: 12px; } .feature-item { padding: 12px; } } .sort-controls { display: flex; align-items: center; gap: var(--spacing-medium); } .sort-controls label { color: var(--color-primary); font-size: 14px; font-weight: 500; } .sort-controls select { background: rgba(30, 30, 50, 0.9); border: 1px solid rgba(85, 68, 51, 0.6); border-radius: 6px; color: #e8dcc6; padding: 6px 12px; font-size: 13px; cursor: pointer; transition: all var(--transition-normal) ease; } .sort-controls select:hover { border-color: var(--color-primary); background: rgba(40, 40, 60, 0.9); } .sort-controls select:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 2px rgba(201, 170, 113, 0.2); } .intimate-toggle .toggle-btn { background: linear-gradient(135deg, rgba(139, 115, 85, 0.8), rgba(201, 170, 113, 0.6)); border: 1px solid rgba(201, 170, 113, 0.8); border-radius: 6px; color: #fff; padding: var(--spacing-medium) 16px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all var(--transition-normal) ease; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); } .intimate-toggle .toggle-btn:hover { background: linear-gradient(135deg, rgba(201, 170, 113, 0.9), rgba(139, 115, 85, 0.7)); transform: translateY(-1px); box-shadow: 0 2px 8px rgba(201, 170, 113, 0.3); } /* --- 新增：亲密关系指示器样式 --- */ .rel-card { position: relative; } .intimate-indicator { position: absolute; bottom: 12px; right: 12px; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; z-index: 2; transition: all var(--transition-normal) ease; /* 默认状态下隐藏 */ display: none; } .intimate-indicator.is-intimate { display: flex; /* 只有亲密关系时才显示 */ background: linear-gradient(135deg, #ff6b6b, #ee5a52); border-color: #ff6b6b; color: white; animation: heartbeat 2s ease-in-out infinite; box-shadow: 0 2px 8px rgba(255, 107, 107, 0.4); } @keyframes heartbeat { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } } /* --- 三连击效果样式 --- */ .rel-card:active { transform: scale(0.98); transition: transform 0.1s ease; } .relationship-card.triple-clicked { border-color: #ff6b6b; box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.5); animation: triple-click-flash 0.5s ease-out; } @keyframes triple-click-flash { 0% { box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.8); transform: scale(1.02); } 50% { box-shadow: 0 0 0 6px rgba(255, 107, 107, 0.4); transform: scale(1.05); } 100% { box-shadow: 0 0 0 0px rgba(255, 107, 107, 0); transform: scale(1); } } .relationship-content { padding: 20px; background: rgba(0, 0, 0, 0.1); border-top: 1px solid rgba(85, 68, 51, 0.3); } .content-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 16px; } .content-section { background: rgba(0, 0, 0, 0.2); border-radius: var(--border-radius); padding: var(--spacing-large); border-left: 3px solid #c9aa71; } .section-title { font-size: 14px; font-weight: 600; color: var(--color-primary); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px; } .section-content p { margin: 0 0 8px 0; font-size: 13px; line-height: 1.5; color: #d4d4d4; } .section-content p:last-child { margin-bottom: 0; } .section-content strong { color: #e8e8e8; font-weight: 500; } .attributes-section { grid-column: 1 / -1; background: linear-gradient(135deg, rgba(201, 170, 113, 0.1), rgba(201, 170, 113, 0.05)); border-left-color: #ffb347; } .attributes-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; margin-top: 8px; } .attribute-item { text-align: center; padding: var(--spacing-medium); background: rgba(0, 0, 0, 0.3); border-radius: 6px; border: 1px solid rgba(255, 179, 71, 0.2); } .attribute-label { font-size: 11px; color: #ffb347; margin-bottom: 4px; font-weight: 500; } .attribute-value { font-size: 14px; font-weight: 600; color: #fff; } .event-history { margin-top: 16px; border-radius: var(--border-radius); overflow: hidden; } .event-history summary { background: rgba(0, 0, 0, 0.2); padding: 12px 16px; cursor: pointer; font-size: 14px; font-weight: 500; color: var(--color-primary); border-bottom: 1px solid rgba(85, 68, 51, 0.3); } .event-history[open] summary { background: rgba(201, 170, 113, 0.1); } .event-history ul { margin: 0; padding: var(--spacing-large); background: rgba(0, 0, 0, 0.1); list-style: none; } /* 好感度条样式补充 */ .favorability-bar-container { width: 100%; height: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden; margin: 16px 0; } .favorability-bar-fill { height: 100%; background: linear-gradient(90deg, #ff6b9d, #c44569); border-radius: 3px; transition: width 0.3s ease; } .event-history li { margin-bottom: 12px; padding: var(--spacing-medium) 12px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; border-left: 3px solid #8b7355; font-size: 12px; line-height: 1.4; color: #c5bba8; } .event-history li:last-child { margin-bottom: 0; } .event-history li strong { color: #e8e8e8; } max-height: 550px; display: flex; flex-direction: column; box-shadow: 0 0 20px rgba(201, 170, 113, 0.3); } .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(201, 170, 113, 0.5); padding-bottom: 10px; margin-bottom: 15px; } .modal-title { font-size: 18px; color: var(--color-primary); } .modal-close-btn { font-size: 24px; color: var(--color-secondary); cursor: pointer; background: none; border: none; } .modal-close-btn:hover { color: var(--color-primary); } .modal-body { flex-grow: 1; overflow-y: auto; } /* --- 大事记时间线样式 (参考 修仙之路) --- */ .timeline-container { position: relative; padding: 20px 0; margin-left: 20px; } .timeline-line { position: absolute; left: 0; top: 0; bottom: 0; width: 2px; background: #e0e0e0; /* 改为浅灰色 */ } .timeline-event { position: relative; margin-bottom: 30px; padding-left: 30px; transition: all var(--transition-normal) ease; } .timeline-event:hover { transform: translateX(5px); } .timeline-event::before { content: ''; position: absolute; left: -5px; top: 5px; width: 12px; height: 12px; border-radius: 50%; background: #ffffff; /* 改为白色 */ border: 2px solid #cccccc; /* 改为灰色边框 */ } /* timeline-header is removed as date and tags are now separate elements */ .timeline-date { font-size: 12px; color: #757575; /* 深灰色 */ font-style: italic; margin-bottom: 8px; /* Add margin to separate from tags */ } .timeline-tags { display: flex; flex-wrap: wrap; /* Allow tags to wrap on smaller screens */ gap: 5px; margin-bottom: 8px; /* Add margin to separate from title */ } .tag-item { background-color: #eeeeee; /* 浅灰色背景 */ border: 1px solid #e0e0e0; color: #616161; /* 深灰色文字 */ padding: 2px 8px; border-radius: var(--border-radius-small); font-size: 10px; white-space: nowrap; font-style: italic; } .timeline-content { background: #ffffff; /* 改为白色背景 */ padding: 15px; border-radius: 5px; border: 1px solid #000000; /* 黑色边框 */ box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); } .timeline-title { font-weight: bold; margin-bottom: 8px; color: #212121; /* 近黑色 */ font-style: italic; } .timeline-description { font-size: 13px; color: #424242; /* 深灰色 */ line-height: 1.7; } .past-life-details { margin-top: 10px; font-size: 12px; display: flex; flex-direction: column; gap: 6px; color: #424242; /* 深灰色 */ } .detail-item> strong { color: #212121; /* 近黑色 */ margin-right: 5px; font-style: italic; } .past-life-details .detail-item.death-reason { color: #ff8a8a; /* A lighter red for better readability */ border-left: 2px solid #c0392b; padding-left: 8px; margin-left: -10px; /* Align with the parent padding */ background: rgba(192, 57, 43, 0.1); } .past-life-details .detail-item.death-reason strong { color: #ff6b6b; /* A brighter red for the key */ } .past-life-details .detail-item.achievement { color: #f0e68c; /* Khaki */ border-left: 2px solid #daa520; /* Goldenrod */ padding-left: 8px; margin-left: -10px; background: rgba(218, 165, 32, 0.1); } .past-life-details .detail-item.achievement strong { color: #ffd700; /* Gold */ } .past-life-details .detail-item.items-obtained { color: #dda0dd; /* Plum */ border-left: 2px solid #9932cc; /* Dark Orchid */ padding-left: 8px; margin-left: -10px; background: rgba(153, 50, 204, 0.1); } .past-life-details .detail-item.items-obtained strong { color: #da70d6; /* Orchid */ } .past-life-details .detail-item.summary-evaluation { color: #add8e6; /* Light Blue */ border-left: 2px solid #4682b4; /* Steel Blue */ padding-left: 8px; margin-left: -10px; background: rgba(70, 130, 180, 0.1); } .past-life-details .detail-item.summary-evaluation strong { color: #87ceeb; /* Sky Blue */ } /* 滚动条 */ ::-webkit-scrollbar { width: 5px; } /* ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); } */ /* 暂时注释掉以避免SillyTavern核心脚本错误 */ ::-webkit-scrollbar-thumb { background: rgba(201, 170, 113, 0.5); border-radius: 3px; } /* 完全隐藏左侧装备栏的滚动条 */ .char-panel::-webkit-scrollbar { width: 0px; /* 完全隐藏滚动条 */ background: transparent; } .char-panel::-webkit-scrollbar-thumb { background: transparent; } .char-panel::-webkit-scrollbar-track { background: transparent; } /* 对于Firefox */ .char-panel { scrollbar-width: none; /* Firefox隐藏滚动条 */ -ms-overflow-style: none; /* IE隐藏滚动条 */ } /* --- 背包模态框样式 --- */ .inventory-category { margin-bottom: 15px; border: var(--border-width) solid var(--color-border); border-radius: 5px; background: rgba(0, 0, 0, 0.2); overflow: hidden; } .inventory-category-title { padding: 10px 15px; font-size: 16px; color: var(--color-primary); cursor: pointer; list-style: none; display: block; background: rgba(0, 0, 0, 0.3); } .inventory-category-title::-webkit-details-marker { display: none; } .inventory-item-list { padding: 10px; display: flex; flex-direction: column; gap: 10px; } .inventory-item { background: rgba(26, 26, 46, 0.7); border: 1px solid rgba(201, 170, 113, 0.2); border-radius: var(--border-radius-small); padding: 10px; } .item-header { display: flex; justify-content: space-between; align-items: center; gap: 15px; margin-top: 10px; /* Add space below the name */ } .item-details { margin-top: 10px; font-size: 12px; border-top: 1px solid rgba(201, 170, 113, 0.2); padding-top: 8px; } .item-name { font-weight: bold; color: #e0dcd1; font-size: 16px; padding-bottom: 10px; margin-bottom: 10px; border-bottom: 1px solid rgba(201, 170, 113, 0.2); } .item-quantity { font-size: 12px; color: var(--color-secondary); } .item-description { font-size: 12px; color: #a09c91; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(201, 170, 113, 0.1); } .item-meta { display: flex; align-items: center; gap: 15px; white-space: nowrap; flex-grow: 1; } .item-actions { display: flex; gap: 5px; flex-shrink: 0; } .empty-category-text { color: var(--color-secondary); font-style: italic; padding: 10px; text-align: center; } /* --- 装备按钮和悬浮提示框 --- */ .item-equip-btn, .item-unequip-btn { padding: var(--spacing-small) 10px; font-size: 12px; background: linear-gradient(45deg, #8b4513, #cd853f); border: 1px solid #daa520; color: #fff; border-radius: var(--border-radius-small); cursor: pointer; transition: background 0.3s; margin-left: 15px; } .item-equip-btn:hover, .item-unequip-btn:hover { background: linear-gradient(45deg, #cd853f, #daa520); } .item-use-btn { padding: var(--spacing-small) 10px; font-size: 12px; background: linear-gradient(45deg, #8b4513, #cd853f); border: 1px solid #daa520; color: #fff; border-radius: var(--border-radius-small); cursor: pointer; transition: background 0.3s; margin-left: 15px; } .item-use-btn:hover { background: linear-gradient(45deg, #cd853f, #daa520); } .item-discard-btn { padding: var(--spacing-small) 10px; font-size: 12px; background: #8b0000; border: 1px solid #ff6b6b; color: #fff; border-radius: var(--border-radius-small); cursor: pointer; transition: background 0.3s; margin-left: 5px; } .item-discard-btn:hover { background: #a52a2a; } #equipment-tooltip { display: none; position: absolute; /* 跟随鼠标 */ background: rgba(15, 15, 35, 0.95); border: var(--border-width) solid var(--color-primary); border-radius: 6px; padding: 15px; color: #e0dcd1; font-size: 12px; z-index: var(--z-modal); width: auto; max-width: 300px; pointer-events: none; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); } .tooltip-title { font-size: 16px; font-weight: bold; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid rgba(201, 170, 113, 0.4); } .tooltip-section { margin-top: 10px; } .tooltip-section-title { color: var(--color-secondary); font-style: italic; margin-bottom: 5px; } .tooltip-attributes p { margin: 3px 0; } .tooltip-attributes strong { color: var(--color-primary); margin-right: 5px; } .command-center-actions { list-style-type: none; padding: 0; margin-bottom: 20px; } .command-center-action-item { background: rgba(0, 0, 0, 0.3); padding: var(--spacing-medium) 12px; border-radius: var(--border-radius-small); margin-bottom: 8px; font-size: 14px; } .command-center-footer { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: auto; /* 推到底部 */ padding-top: 15px; border-top: 1px solid rgba(201, 170, 113, 0.5); } /* --- 归墟系统模态框美化 --- */ #guixu-system-modal .modal-content { background: radial-gradient(circle, rgba(45, 27, 61, 0.9) 0%, rgba(15, 15, 35, 0.95) 100%); border: 1px solid #8b7355; box-shadow: 0 0 25px rgba(201, 170, 113, 0.3); } #guixu-system-modal .attribute-item { padding: 10px 4px; /* 增加垂直内边距 */ font-size: 13px; /* 放大字体 */ border-bottom: 1px solid rgba(201, 170, 113, 0.1); } #guixu-system-modal .attribute-item:last-child { border-bottom: none; } /* --- 人物关系样式 --- */ .rel-card { background: rgba(0, 0, 0, 0.2); border: var(--border-width) solid var(--color-border); border-radius: 5px; padding: 15px; margin-bottom: 15px; } .relationship-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid rgba(201, 170, 113, 0.2); } .relationship-name { font-size: 18px; font-weight: bold; } .relationship-relation { font-size: 14px; color: #a09c91; font-style: italic; } .relationship-body { font-size: 13px; line-height: 1.7; } .relationship-body p { margin-bottom: 8px; } .relationship-meta { display: flex; justify-content: space-between; font-size: 12px; color: #a09c91; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(201, 170, 113, 0.2); } .favorability-bar-container { width: 100%; height: 8px; background: rgba(0, 0, 0, 0.5); border-radius: var(--border-radius-small); margin-top: 4px; border: 1px solid #8b7355; } .favorability-bar-fill { height: 100%; background: linear-gradient(90deg, #8b4513, #cd853f); border-radius: 3px; } .event-history-details { margin-top: 15px; } .event-history-summary { cursor: pointer; color: var(--color-primary); font-style: italic; } .event-history-list { list-style-type: disc; padding-left: 20px; margin-top: 8px; color: #a09c91; } .relationship-actions { display: flex; align-items: center; gap: 10px; } .btn-mark-intimate, .btn-unmark-intimate { padding: var(--spacing-small) 10px; font-size: 12px; background: linear-gradient(45deg, #4a0e7a, #8a2be2); /* Purple gradient */ border: 1px solid #dda0dd; color: #fff; border-radius: var(--border-radius-small); cursor: pointer; transition: background 0.3s; white-space: nowrap; } .btn-mark-intimate:hover, .btn-unmark-intimate:hover { background: linear-gradient(45deg, #8a2be2, #9932cc); } .btn-mark-intimate:hover, .btn-unmark-intimate:hover { background: linear-gradient(45deg, #8a2be2, #9932cc); } /* --- 新增：当前变量模态框样式 (模块化修改后) --- */ .variables-editor-container { display: flex; flex-direction: column; gap: 15px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } .variable-category { border: var(--border-width) solid var(--color-border); border-radius: 5px; background: rgba(0, 0, 0, 0.2); overflow: hidden; } .variable-category-title { padding: 12px 15px; font-size: 16px; color: var(--color-primary); cursor: pointer; list-style: none; display: block; background: rgba(0, 0, 0, 0.3); font-family: 'Ma Shan Zheng', cursive; } .variable-category-title::-webkit-details-marker { display: none; } .variable-items-list { padding: 10px; display: flex; flex-direction: column; gap: var(--spacing-medium); } .variable-item { display: grid; grid-template-columns: 200px 1fr auto; align-items: center; gap: 10px; padding: var(--spacing-medium); background: rgba(26, 26, 46, 0.7); border-radius: var(--border-radius-small); border-left: 3px solid #8b7355; } .variable-item.nested { margin-left: 20px; grid-template-columns: 180px 1fr auto; } .variable-key { font-weight: bold; color: var(--color-primary); font-size: 13px; flex-shrink: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .variable-value-container { flex-grow: 1; display: flex; } .variable-input { background: rgba(0, 0, 0, 0.5); border: 1px solid #8b7355; border-radius: var(--border-radius-small); color: #e0dcd1; padding: 6px 10px; font-size: 13px; width: 100%; } .variable-input[type=\"checkbox\"] { width: 18px; height: 18px; cursor: pointer; } .variable-actions { display: flex; gap: 5px; } .btn-variable-action { padding: 6px 12px; font-size: 12px; border: var(--border-width) solid var(--color-primary); color: var(--color-primary); border-radius: var(--border-radius-small); cursor: pointer; background: linear-gradient(45deg, #1a1a2e, #2d1b3d); white-space: nowrap; } .btn-variable-action:hover { background: linear-gradient(45deg, #2d1b3d, #3d2b4d); } .btn-variable-action.btn-remove { background: linear-gradient(45deg, #8b0000, #c0392b); color: #fff; border-color: #c0392b; } .btn-variable-action.btn-remove:hover { background: linear-gradient(45deg, #c0392b, #e74c3c); } .variable-item-adder { padding: 10px; text-align: center; border-top: 1px dashed rgba(201, 170, 113, 0.2); margin-top: 8px; } .btn-add-item { width: 100%; background: rgba(0, 0, 0, 0.3); } /* --- 新增：本世历程详细信息样式 --- */ .detail-section { margin-bottom: 10px; padding: var(--spacing-medium); background: rgba(0, 0, 0, 0.1); border-radius: var(--border-radius-small); font-size: 12px; line-height: 1.5; } .detail-section strong { color: var(--color-primary); margin-right: 5px; } .timeline-location { font-size: 12px; color: var(--color-secondary); margin: 5px 0; font-style: italic; } .timeline-detailed-info { animation: fadeIn 0.3s ease-in-out; } @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } } </style><style> /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */ /* --- 新增：移动端适配样式 --- */ /* --- 新增：视图切换按钮样式 --- */ .view-toggle-btn { position: absolute; top: 15px; right: 15px; width: 35px; height: 35px; background: rgba(15, 15, 35, 0.8); border: var(--border-width) solid var(--color-primary); color: var(--color-primary); border-radius: 50%; cursor: pointer; z-index: 100; font-size: 18px; display: flex; align-items: center; justify-content: center; transition: background-color 0.3s; } .view-toggle-btn:hover { background-color: rgba(45, 27, 61, 0.9); } /* --- 新增：移动端视图样式 (由JS切换) --- */ .guixu-root-container.mobile-view { height: 100%; aspect-ratio: unset; /* 在移动端移除PC端的宽高比限制 */ } .guixu-root-container.mobile-view .game-container { grid-template-columns: 1fr; /* 单列布局 */ grid-template-rows: auto 1fr auto; /* 简化为: 顶部, 正文, 底部 */ height: 100vh; /* 使用全屏高度 */ gap: 0; } /* 让所有面板占据整行 */ .guixu-root-container.mobile-view .status-top, .guixu-root-container.mobile-view .char-panel, .guixu-root-container.mobile-view .main-content, .guixu-root-container.mobile-view .interaction-panel, .guixu-root-container.mobile-view .status-bottom { grid-column: 1 / -1; } /* --- 新增：默认隐藏面板的移动端视图 --- */ /* 在移动视图下，默认隐藏两个可折叠的面板，添加动画效果 */ .guixu-root-container.mobile-view .char-panel, .guixu-root-container.mobile-view .interaction-panel { transform: translateX(-100%); opacity: 0; transition: all var(--transition-normal) ease-in-out; position: relative; overflow: hidden; max-height: 0; } /* 当根容器有 .character-panel-visible 类时，显示角色面板 */ .guixu-root-container.mobile-view.character-panel-visible .char-panel { transform: translateX(0); opacity: 1; max-height: 60vh; /* 增加高度，使用视口高度 */ overflow-y: auto; /* 添加垂直滚动 */ } /* 当根容器有 .interaction-panel-visible 类时，显示交互面板 */ .guixu-root-container.mobile-view.interaction-panel-visible .interaction-panel { transform: translateX(0); opacity: 1; max-height: 40vh; /* 使用视口高度 */ overflow-y: auto; /* 添加垂直滚动 */ } .guixu-root-container.mobile-view .char-panel { position: fixed; top: 65px; /* 顶部状态栏高度 */ left: 0; /* 从左边缘开始，不再依赖侧边栏宽度 */ right: 0; z-index: var(--z-tooltip); /* 提高z-index，确保显示层级正确 */ border-right: none; border-bottom: 1px solid #c9aa71; background: rgba(26, 26, 46, 0.95); backdrop-filter: blur(10px); max-height: 45vh; /* 限制最大高度 */ overflow-y: auto; padding: 15px; border-radius: 0 0 15px 15px; /* 添加底部圆角，使界面更协调 */ box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); } .guixu-root-container.mobile-view .main-content { grid-row: 2; /* 占据主要空间 */ min-height: 0; overflow-y: auto; padding: 15px; /* 增加内边距 */ } .guixu-root-container.mobile-view .interaction-panel { position: fixed; bottom: 65px; /* 留出底部状态栏的空间 */ left: 0; /* 从左边缘开始，不再依赖侧边栏宽度 */ right: 0; z-index: var(--z-tooltip); /* 提高z-index，确保在底部状态栏之上 */ background: rgba(26, 26, 46, 0.95); backdrop-filter: blur(10px); border-top: 1px solid #c9aa71; border-left: none; max-height: 50vh; /* 限制最大高度，避免遮挡过多内容 */ overflow-y: auto; flex-direction: column; /* 改为垂直排列，更适合展开的功能面板 */ gap: var(--spacing-medium); padding: 15px; border-radius: 15px 15px 0 0; /* 添加圆角，使界面更协调 */ box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.3); } .guixu-root-container.mobile-view .interaction-btn { flex-grow: 1; /* 让按钮填充空间 */ min-width: 120px; /* 最小宽度 */ } .guixu-root-container.mobile-view .world-line-section { width: 100%; display: flex; justify-content: space-around; } .guixu-root-container.mobile-view .status-bottom { position: fixed; bottom: 0; left: 0; /* 从左边缘开始，不再依赖侧边栏宽度 */ right: 0; z-index: var(--z-modal); background: rgba(26, 26, 46, 0.95); backdrop-filter: blur(5px); border-top: 1px solid #c9aa71; padding: 6px; flex-direction: column; gap: var(--spacing-small); } .guixu-root-container.mobile-view .send-container { width: 100%; display: flex; flex-direction: column; gap: var(--spacing-small); } /* 发送按钮单独一行 */ .guixu-root-container.mobile-view .send-button-row { display: flex; justify-content: center; } .guixu-root-container.mobile-view .send-button-row button { flex: 1; max-width: 100px; padding: 6px 12px !important; font-size: 13px; font-weight: bold; } .guixu-root-container.mobile-view .send-input { width: 100%; height: 36px; resize: none; font-size: 13px; padding: 6px 8px; border-radius: var(--border-radius-small); border: 1px solid #8b7355; background: rgba(0, 0, 0, 0.6); color: #e0dcd1; margin: 2px 0; } .guixu-root-container.mobile-view .send-input:focus { height: 60px; outline: none; border-color: var(--color-primary); box-shadow: 0 0 5px rgba(201, 170, 113, 0.3); } .guixu-root-container.mobile-view #quick-command-popup { width: 90%; left: 5%; right: 5%; bottom: 110px; /* 调整位置 */ } /* 调整字体大小 */ .guixu-root-container.mobile-view .status-value { font-size: 12px; } .guixu-root-container.mobile-view .status-label { font-size: 10px; } .guixu-root-container.mobile-view .section-title { font-size: 12px; } .guixu-root-container.mobile-view .attribute-item { font-size: 11px; } .guixu-root-container.mobile-view .game-text-container { font-size: 13px; } .guixu-root-container.mobile-view .interaction-btn { font-size: 11px; } .guixu-root-container.mobile-view .modal-content { width: 95vw; height: 90vh; padding: 10px; max-width: none; max-height: none; } /* --- 新增：移动端按键折叠 --- */ /* PC端隐藏切换按钮 */ #btn-toggle-buttons { display: none; } /* --- 新增：长方形竖字长条可拖动按钮样式 --- */ .floating-toggle-btn { position: fixed; width: 20px; /* 长方形宽度 */ height: 60px; /* 长方形高度 */ background: linear-gradient(135deg, rgba(26, 26, 46, 0.8), rgba(45, 27, 61, 0.8)); border: none; border-radius: 10px; /* 圆角长条 */ color: var(--color-primary); font-size: 10px; cursor: move; /* 拖动光标 */ transition: none; /* 移除过渡效果，拖动延迟为0 */ display: none; /* 默认隐藏 */ align-items: center; justify-content: center; backdrop-filter: blur(5px); writing-mode: vertical-rl; /* 竖直文字 */ text-orientation: upright; /* 文字方向 */ z-index: var(--z-dropdown); user-select: none; /* 防止文字选择 */ touch-action: none; /* 防止触摸滚动 */ } .guixu-root-container.mobile-view .floating-toggle-btn { display: flex; /* 在移动端显示 */ } #floating-character-btn { left: 10px; top: 30%; /* 调整位置 */ } #floating-interaction-btn { left: 10px; top: 40%; /* 在角色按钮下方 */ } .floating-toggle-btn:hover { background: linear-gradient(135deg, rgba(45, 27, 61, 0.9), rgba(26, 26, 46, 0.9)); transform: scale(1.05); transition: none; /* 移除hover过渡效果 */ } .floating-toggle-btn.active { background: linear-gradient(135deg, rgba(201, 170, 113, 0.3), rgba(139, 115, 85, 0.3)); border: var(--border-width) solid var(--color-primary); transition: none; /* 移除active过渡效果 */ } .floating-toggle-btn.dragging { transform: scale(1.1); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); transition: none; /* 移除拖动过渡效果 */ } .sidebar-toggle-btn { width: 32px; height: 32px; margin: 5px 4px; background: linear-gradient(135deg, rgba(26, 26, 46, 0.8), rgba(45, 27, 61, 0.8)); border: none; border-radius: var(--border-radius-small); color: var(--color-primary); font-size: 10px; cursor: pointer; transition: all var(--transition-normal) ease; display: flex; align-items: center; justify-content: center; text-align: center; line-height: 1; writing-mode: vertical-rl; /* 文字竖直显示 */ text-orientation: upright; /* 文字方向 */ font-family: 'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3); } .sidebar-toggle-btn:hover { background: linear-gradient(135deg, rgba(45, 27, 61, 0.9), rgba(26, 26, 46, 0.9)); border-color: var(--color-primary); transform: translateX(2px); box-shadow: 0 2px 6px rgba(201, 170, 113, 0.2); } .sidebar-toggle-btn.active { background: linear-gradient(135deg, rgba(201, 170, 113, 0.3), rgba(139, 115, 85, 0.3)); border-color: var(--color-primary); color: #fff; box-shadow: 0 0 8px rgba(201, 170, 113, 0.4), inset 0 1px 3px rgba(201, 170, 113, 0.2); } /* 移动端主容器左边距调整 */ .guixu-root-container.mobile-view { margin-left: 0; /* 移除左边距，让正文占据100%宽度 */ width: 100%; /* 正文占据全宽 */ min-height: 100vh; } /* 小屏幕优化 */ @media (max-width: 480px) { .mobile-sidebar { width: 35px; } .sidebar-toggle-btn { width: 28px; height: 28px; font-size: 9px; margin: 3px 3.5px; } .guixu-root-container.mobile-view { margin-left: 0; /* 移除左边距 */ width: 100%; /* 正文占据全宽 */ } .guixu-root-container.mobile-view .game-text-container { font-size: 12px; padding: var(--spacing-medium); } .guixu-root-container.mobile-view .status-value { font-size: 11px; } .guixu-root-container.mobile-view .status-label { font-size: 9px; } } /* 超小屏幕优化 */ @media (max-width: 360px) { .mobile-sidebar { width: 30px; } .sidebar-toggle-btn { width: 24px; height: 24px; font-size: 8px; margin: 2px 3px; } .guixu-root-container.mobile-view { margin-left: 0; /* 移除左边距 */ width: 100%; /* 正文占据全宽 */ } } </style><style> /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */ /* --- 自定义确认模态框 --- */ .confirm-modal-content { width: auto; max-width: 400px; height: auto; max-height: none; text-align: center; padding: 30px; } .confirm-modal-message { font-size: 16px; color: #ff6b6b; /* 红色警告 */ margin-bottom: 25px; line-height: 1.6; } .confirm-modal-buttons { display: flex; justify-content: center; gap: 20px; } /* --- 新增：格式审查模态框样式 --- */ .format-validation-section h3 { color: var(--color-primary); margin-bottom: 15px; font-size: 16px; } .format-errors-container { background: rgba(139, 115, 85, 0.1); border: var(--border-width) solid var(--color-border); border-radius: var(--border-radius-small); padding: 15px; max-height: 400px; overflow-y: auto; } .format-error-item { border-radius: 6px; padding: 12px; margin-bottom: 12px; transition: all 0.2s ease; } .format-error-item:last-child { margin-bottom: 0; } /* 严重程度样式 */ .format-error-item.severity-high { background: rgba(255, 107, 107, 0.15); border: 2px solid rgba(255, 107, 107, 0.4); color: #ff6b6b; } .format-error-item.severity-medium { background: rgba(255, 193, 7, 0.15); border: 2px solid rgba(255, 193, 7, 0.4); color: #ffc107; } .format-error-item.severity-low { background: rgba(108, 117, 125, 0.15); border: 2px solid rgba(108, 117, 125, 0.4); color: #6c757d; } .format-error-header { display: flex; align-items: center; gap: var(--spacing-medium); margin-bottom: 8px; font-weight: bold; } .format-error-icon { font-size: 16px; min-width: 20px; } .format-error-tag { font-family: 'Courier New', monospace; background: rgba(0, 0, 0, 0.2); padding: 2px 6px; border-radius: 3px; font-size: 13px; } .format-error-type { font-size: 14px; opacity: 0.9; } .format-error-details { margin: 8px 0; font-size: 14px; line-height: 1.4; opacity: 0.85; } .format-error-counts { font-size: 12px; opacity: 0.7; font-family: 'Courier New', monospace; } .tag-count { font-weight: bold; } .tag-count.missing { color: #ff6b6b; background: rgba(255, 107, 107, 0.2); padding: 1px 4px; border-radius: 2px; } .format-no-errors { text-align: center; color: #28a745; font-size: 16px; } /* 新增：错误类型标题样式 */ .format-error-type-header { display: flex; align-items: center; margin: 15px 0 8px 0; padding: var(--spacing-medium) 12px; background: rgba(201, 170, 113, 0.1); border-left: 4px solid #c9aa71; border-radius: var(--border-radius-small); font-weight: bold; font-size: 14px; color: var(--color-primary); } .format-error-type-header:first-child { margin-top: 0; } .error-type-icon { margin-right: 8px; font-size: 16px; } .error-type-title { flex: 1; } /* 简化错误项样式 */ .format-error-message { color: #d4af37; font-size: 14px; line-height: 1.4; font-family: 'Courier New', monospace; padding: 20px; background: rgba(40, 167, 69, 0.1); border: 1px solid rgba(40, 167, 69, 0.3); border-radius: var(--border-radius-small); } /* 缺失标签总结样式 */ .format-missing-summary { background: rgba(220, 53, 69, 0.15); border: 2px solid rgba(220, 53, 69, 0.4); border-radius: 6px; padding: 15px; margin-bottom: 15px; color: #dc3545; } .missing-summary-header { display: flex; align-items: center; gap: var(--spacing-medium); margin-bottom: 8px; font-weight: bold; font-size: 16px; } .missing-summary-icon { font-size: 18px; min-width: 20px; } .missing-summary-title { color: #dc3545; } .missing-summary-content { font-size: 14px; line-height: 1.4; opacity: 0.9; } .missing-summary-content code { color: #dc3545; font-family: 'Courier New', monospace; background: rgba(220, 53, 69, 0.1); padding: 2px 4px; border-radius: 2px; font-weight: bold; } .format-validation-actions { display: flex; justify-content: center; gap: 15px; margin-top: 20px; } </style><style> /* --- 新增：行动选项样式 --- */ .action-options-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; padding-top: 20px; /* 与上方正文隔开 */ margin-top: 15px; border-top: 1px solid rgba(201, 170, 113, 0.1); } .action-option-btn { background: rgba(26, 26, 46, 0.4); /* 更淡的背景 */ border: var(--border-width) solid var(--color-border); /* 更淡的边框 */ color: #a09c91; /* 稍暗的文字颜色 */ padding: var(--spacing-medium) 15px; border-radius: 20px; /* 圆角矩形 */ cursor: pointer; font-size: 12px; transition: all var(--transition-normal) ease; text-align: center; } .action-option-btn:hover { background: rgba(45, 27, 61, 0.6); /* 悬浮时稍亮 */ border-color: var(--color-primary); color: #e0dcd1; } </style><style> /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */ /* --- 新增：存档管理模态框样式 --- */ .clear-saves-btn { background: #8b0000; color: #fff; border: 1px solid #ff6b6b; padding: var(--spacing-small) 10px; font-size: 12px; border-radius: var(--border-radius-small); cursor: pointer; transition: background 0.3s; margin-left: auto; /* 将按钮推到右边 */ } .clear-saves-btn:hover { background: #a52a2a; } #save-slots-container { display: flex; flex-direction: column; gap: 15px; } .save-slot { background: rgba(0, 0, 0, 0.3); border: var(--border-width) solid var(--color-border); border-radius: 5px; padding: 15px; display: flex; justify-content: space-between; align-items: center; } .save-slot-info { flex-grow: 1; } .save-slot-info .slot-name { font-size: 16px; color: #e0dcd1; } .save-slot-info .slot-time { font-size: 12px; color: var(--color-secondary); margin-top: 5px; } .save-slot-info .slot-summary { font-size: 11px; color: #a09c91; margin-top: 8px; font-style: italic; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 450px; /* 根据模态框宽度调整 */ } .save-slot-actions { display: flex; gap: 10px; } /* --- 新增：自动存档部分样式 --- */ .auto-save-section { padding: 15px; margin-bottom: 15px; background: rgba(0, 0, 0, 0.2); border: var(--border-width) solid var(--color-border); border-radius: 5px; display: flex; justify-content: space-between; align-items: center; } .auto-save-title { font-size: 16px; color: var(--color-primary); } .auto-save-toggle { display: flex; align-items: center; gap: var(--spacing-medium); cursor: pointer; } .auto-save-toggle label { font-size: 14px; color: #a09c91; cursor: pointer; } .auto-save-toggle input[type=\"checkbox\"] { cursor: pointer; width: 18px; height: 18px; } </style><style> /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */ /* --- 新增：等待悬浮窗 --- */ @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } @keyframes god-tier-animation { 0% { background-position: -200% center; } 100% { background-position: 200% center; } } .waiting-spinner { width: 24px; height: 24px; border: 3px solid rgba(201, 170, 113, 0.3); border-top-color: var(--color-primary); border-radius: 50%; animation: spin 1s linear infinite; flex-shrink: 0; } .waiting-popup { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(15, 15, 35, 0.8); color: var(--color-primary); padding: 15px 25px; border-radius: var(--border-radius); border: var(--border-width) solid var(--color-primary); z-index: 9999; font-size: 16px; box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7); line-height: 1.6; display: flex; align-items: center; gap: 20px; width: 450px; /* 拉长悬浮框 */ max-width: 90%; } </style><style> /* --- 新增：地图模态框样式 --- */ #map-modal-body { padding: 0; background-color: #ffffff; /* 只保留背景色 */ position: relative; overflow: hidden; /* 隐藏超出容器的标记, 这是实现平移缩放的关键 */ cursor: grab; /* 默认显示可抓取光标 */ } #map-modal-body:active { cursor: grabbing; /* 拖动时显示抓取中光标 */ } .map-container { position: absolute; /* 改为 absolute 以便 left/top 精准定位 */ width: 100%; height: 100%; transform-origin: 0 0; /* 移除CSS transition，完全由JS驱动变换，避免冲突导致缩放失效 */ background-color: #ffffff; /* 网格将完全由JS创建 */ } .map-location-dot { position: absolute; border: 1px solid #333; background-color: rgba(76, 175, 80, 0.7); /* 默认绿色 */ transform: translate(-50%, -50%); cursor: pointer; transition: all var(--transition-normal) ease; box-shadow: 0 0 5px rgba(0,0,0,0.5); opacity: 0.7; /* 移除混合模式，改用不透明度来处理重叠 */ /* 新增：Flexbox用于居中文本 */ display: flex; align-items: center; justify-content: center; color: white; /* 默认字体颜色 */ text-shadow: 1px 1px 2px rgba(0,0,0,0.8); /* 字体阴影，确保可读性 */ overflow: hidden; /* 防止文本溢出 */ white-space: nowrap; /* 防止文本换行 */ text-align: center; } .map-location-dot:hover { z-index: 20; } /* 恢复基于状态的背景色 */ .map-location-dot[data-$1=\"$2\"] { background-color: rgba(244, 67, 54, 0.7); /* 红色 */ } .map-location-dot[data-$1=\"$2\"] { background-color: rgba(158, 158, 158, 0.7); /* 灰色 */ } .player-cursor { position: absolute; width: 20px; height: 20px; background-color: gold; border-radius: 50%; border: 2px solid white; transform: translate(-50%, -50%); box-shadow: 0 0 15px gold, 0 0 25px rgba(255, 215, 0, 0.5); z-index: var(--z-dropdown); /* 最高层级 */ animation: pulse-gold 1.5s infinite ease-in-out; } @keyframes pulse-gold { 0% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } } /* 新增：地图控制UI样式 */ .map-controls { display: flex; align-items: center; gap: 10px; margin-left: auto; /* 将其推到标题和关闭按钮之间 */ margin-right: 20px; } #zoom-level-display { font-size: 12px; color: var(--color-secondary); min-width: 40px; /* 防止数字跳动 */ text-align: right; } #zoom-slider { -webkit-appearance: none; appearance: none; width: 120px; /* 稍微缩短滑块为新元素腾出空间 */ height: 5px; background: rgba(0, 0, 0, 0.5); border-radius: 3px; outline: none; opacity: 0.7; transition: opacity .2s; border: 1px solid #8b7355; } #zoom-slider:hover { opacity: 1; } #zoom-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 15px; height: 15px; background: #c9aa71; cursor: pointer; border-radius: 50%; border: 1px solid #fff; } #zoom-slider::-moz-range-thumb { width: 15px; height: 15px; background: #c9aa71; cursor: pointer; border-radius: 50%; border: 1px solid #fff; } #cursor-coords-display { font-size: 11px; color: var(--color-secondary); min-width: 130px; /* 防止坐标跳动 */ text-align: center; background: rgba(0,0,0,0.2); padding: 2px 5px; border-radius: 3px; font-family: monospace; /* 等宽字体更适合显示坐标 */ } #btn-center-player { background: none; border: var(--border-width) solid var(--color-primary); color: var(--color-primary); border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; } #btn-center-player:hover { background: rgba(201, 170, 113, 0.2); } #btn-center-player:disabled { opacity: 0.4; cursor: not-allowed; } /* 新增：确保地图控制在移动端也能正常显示 */ .guixu-root-container.mobile-view #map-modal .modal-header { flex-wrap: wrap; /* 允许换行 */ gap: 10px; /* 增加元素间距 */ } .guixu-root-container.mobile-view #map-modal .map-controls { order: 3; /* 将控制按钮区域放到最后 */ width: 100%; /* 占满整行 */ margin: 0; justify-content: center; /* 居中显示 */ } </style><style> /* --- 新增：全屏样式 --- */ .guixu-root:fullscreen { max-width: 100vw !important; width: 100vw !important; height: 100vh !important; border-radius: 0; border: none; margin: 0; box-shadow: none; } .guixu-root:fullscreen .game-container { height: 100vh !important; max-width: 100%; min-height: 100vh; } /* 新增：修复移动端全屏后模态框无法显示的问题 */ /* 最终修复：确保所有弹窗在全屏时都使用 fixed 定位并位于顶层 */ .guixu-root:fullscreen .modal-overlay, .guixu-root:fullscreen .status-effects-popup, .guixu-root:fullscreen #equipment-tooltip, .guixu-root:fullscreen #quick-command-popup { position: fixed !important; /* 强制相对于视口定位，脱离父容器限制 */ z-index: 99999 !important; /* 使用极高的z-index确保在最顶层 */ } /* --- 新增：优化移动端全屏视图 --- */ /* 默认情况下，隐藏面板和按钮 */ .guixu-root-container.mobile-view:fullscreen .game-container { grid-template-rows: auto 1fr auto; /* 优化布局：顶、中、底 */ } .guixu-root-container.mobile-view:fullscreen .char-panel, .guixu-root-container.mobile-view:fullscreen .interaction-panel { display: none; } #mobile-panel-toggle-btn { display: none; /* 默认隐藏 */ } /* 仅在移动全屏视图下显示切换按钮 */ .guixu-root-container.mobile-view:fullscreen #mobile-panel-toggle-btn { display: flex; } /* 当用户点击按钮，添加 character-panel-visible 或 interaction-panel-visible 类时，恢复面板和原始布局 */ .guixu-root-container.mobile-view.character-panel-visible:fullscreen .game-container, .guixu-root-container.mobile-view.interaction-panel-visible:fullscreen .game-container { grid-template-rows: auto 1fr auto auto auto; /* 恢复标准移动布局 */ height: 100vh !important; min-height: 100vh; } .guixu-root-container.mobile-view.character-panel-visible:fullscreen .char-panel { display: block; /* 恢复其原始 display 属性 */ } .guixu-root-container.mobile-view.interaction-panel-visible:fullscreen .interaction-panel { display: flex; /* 恢复其原始 display 属性 */ } .guixu-root-container.mobile-view.character-panel-visible:fullscreen .main-content, .guixu-root-container.mobile-view.interaction-panel-visible:fullscreen .main-content { grid-row: 2; } .guixu-root-container.mobile-view.character-panel-visible:fullscreen .char-panel { grid-row: 3; } .guixu-root-container.mobile-view.interaction-panel-visible:fullscreen .interaction-panel { grid-row: 4; } .guixu-root-container.mobile-view.character-panel-visible:fullscreen .status-bottom, .guixu-root-container.mobile-view.interaction-panel-visible:fullscreen .status-bottom { grid-row: 5; } /* 确保全屏模式下底部状态栏始终在屏幕底部 */ .guixu-root:fullscreen .status-bottom { position: relative; bottom: 0; width: 100%; } </style><style> /* --- 新增：状态效果弹出窗口 --- */ .status-effects-popup { display: none; /* 默认隐藏 */ position: absolute; bottom: 60px; /* 位于底部状态栏之上 */ left: 15px; width: 350px; max-height: 250px; background: rgba(15, 15, 35, 0.98); border: var(--border-width) solid var(--color-primary); border-radius: 6px; z-index: var(--z-modal); box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.5); flex-direction: column; animation: slideUpFadeIn 0.3s ease-out; } @keyframes slideUpFadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } } .status-effects-popup-header { display: flex; justify-content: space-between; align-items: center; padding: var(--spacing-medium) 12px; border-bottom: 1px solid rgba(201, 170, 113, 0.5); font-size: 14px; color: var(--color-primary); flex-shrink: 0; } #status-effects-popup-close { background: none; border: none; color: var(--color-secondary); font-size: 20px; cursor: pointer; } #status-effects-popup-close:hover { color: var(--color-primary); } .status-effects-popup-list { overflow-y: auto; padding: 5px; } .status-effect-item { padding: var(--spacing-medium) 12px; color: #a09c91; font-size: 12px; border-bottom: 1px solid rgba(201, 170, 113, 0.1); line-height: 1.6; } .status-effect-item:last-child { border-bottom: none; } /* 修改原有的状态显示区域，使其变成一个按钮 */ #status-summary-button { cursor: pointer; transition: background-color 0.3s; } #status-summary-button:hover { background: rgba(201, 170, 113, 0.1); } </style><style> /* --- 新增：思维过程显示样式 --- */ #btn-toggle-thinking { background: linear-gradient(45deg, #3a2a4e, #5d4b6d); border-color: #a99a81; align-self: center; /* 居中按钮 */ margin-bottom: 10px; } #thinking-content-display { white-space: pre-wrap; word-wrap: break-word; color: #a09c91; font-size: 12px; padding: 10px; background: rgba(0, 0, 0, 0.4); border-radius: var(--border-radius-small); border: 1px dashed rgba(201, 170, 113, 0.3); margin-bottom: 15px; font-style: italic; display: none; /* 默认隐藏 */ } /* --- 新增：输入缓存模态框样式 --- */ #input-cache-modal .modal-content { width: 600px; height: auto; max-height: 80vh; } .input-cache-section { margin-bottom: 20px; } .input-cache-list { list-style: none; padding: 0; margin: 0; max-height: 200px; overflow-y: auto; } .input-cache-item { background: rgba(0, 0, 0, 0.2); padding: 10px 15px; border-bottom: 1px solid rgba(201, 170, 113, 0.1); font-size: 13px; color: #a09c91; cursor: pointer; transition: background-color 0.2s; white-space: pre-wrap; /* 保留换行 */ word-wrap: break-word; /* 长单词换行 */ } .input-cache-item:hover { background-color: rgba(201, 170, 113, 0.1); color: #e0dcd1; } .input-cache-item .item-index { color: var(--color-secondary); font-size: 11px; margin-right: 10px; } #input-cache-modal details summary { cursor: pointer; list-style: none; } #input-cache-modal details summary::-webkit-details-marker { display: none; } </style><style> /* --- 新增：窗口大小调整控制面板样式 --- */ .window-size-panel { position: absolute; top: 60px; right: 15px; width: 280px; background: rgba(15, 15, 35, 0.95); border: var(--border-width) solid var(--color-primary); border-radius: var(--border-radius); z-index: var(--z-modal); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); animation: slideDownFadeIn 0.3s ease-out; } @keyframes slideDownFadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } } .window-size-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; border-bottom: 1px solid rgba(201, 170, 113, 0.3); font-size: 14px; color: var(--color-primary); font-weight: bold; } #window-size-close { background: none; border: none; color: var(--color-secondary); font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; } #window-size-close:hover { color: var(--color-primary); } .window-size-content { padding: 15px; } .size-control-group { margin-bottom: 15px; } .size-control-group label { display: block; font-size: 12px; color: #a09c91; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; } .size-control-group span { color: var(--color-primary); font-weight: bold; min-width: 60px; text-align: right; } .size-control-group input[type=\"range\"] { width: 100%; height: 6px; background: rgba(0, 0, 0, 0.5); border-radius: 3px; outline: none; border: 1px solid #8b7355; -webkit-appearance: none; appearance: none; } .size-control-group input[type=\"range\"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #c9aa71; cursor: pointer; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); } .size-control-group input[type=\"range\"]::-moz-range-thumb { width: 16px; height: 16px; background: #c9aa71; cursor: pointer; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); } .size-control-buttons { display: flex; gap: 10px; margin-top: 20px; } .size-control-btn { flex: 1; padding: var(--spacing-medium) 12px; font-size: 12px; border: 1px solid #8b7355; color: var(--color-primary); background: linear-gradient(45deg, #1a1a2e, #2d1b3d); border-radius: var(--border-radius-small); cursor: pointer; transition: all var(--transition-normal) ease; } .size-control-btn:hover { background: linear-gradient(45deg, #2d1b3d, #3d2b4d); } .size-control-btn.primary { background: linear-gradient(45deg, #8b4513, #cd853f); border-color: #daa520; color: #fff; } .size-control-btn.primary:hover { background: linear-gradient(45deg, #cd853f, #daa520); } /* 移动端适配 */ .guixu-root-container.mobile-view .window-size-panel { width: 90%; right: 5%; top: 70px; } </style><style> /* --- 新增：背景图设置相关样式 --- */ /* --- 新增：透明度滑块样式 --- */ #opacity-slider { -webkit-appearance: none; appearance: none; height: 6px; background: linear-gradient(to right, #1a1a2e 0%, #8b7355 100%); border-radius: 3px; outline: none; cursor: pointer; } #opacity-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #c9aa71; border-radius: 50%; cursor: pointer; border: 2px solid #8b7355; box-shadow: 0 2px 4px rgba(0,0,0,0.3); } #opacity-slider::-moz-range-thumb { width: 18px; height: 18px; background: #c9aa71; border-radius: 50%; cursor: pointer; border: 2px solid #8b7355; box-shadow: 0 2px 4px rgba(0,0,0,0.3); } #background-upload-area:hover { border-color: var(--color-primary); background: rgba(201, 170, 113, 0.1); } .background-item { position: relative; border-radius: var(--border-radius); overflow: hidden; background: rgba(0,0,0,0.3); border: 2px solid transparent; transition: all var(--transition-normal) ease; cursor: pointer; aspect-ratio: 16/9; } .background-item:hover { border-color: var(--color-primary); transform: scale(1.05); } .background-item.selected { border-color: #daa520; box-shadow: 0 0 10px rgba(218, 165, 32, 0.5); } .background-item img { width: 100%; height: 100%; object-fit: cover; } .background-item-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.3s ease; } .background-item:hover .background-item-overlay { opacity: 1; } .background-item-actions { display: flex; gap: var(--spacing-medium); } .background-item-btn { padding: 6px 12px; font-size: 12px; border: var(--border-width) solid var(--color-primary); color: var(--color-primary); background: rgba(0,0,0,0.8); border-radius: var(--border-radius-small); cursor: pointer; transition: all var(--transition-normal) ease; } .background-item-btn:hover { background: #c9aa71; color: #000; } .background-item-btn.delete { border-color: #ff6b6b; color: #ff6b6b; } .background-item-btn.delete:hover { background: #ff6b6b; color: #fff; } .background-preview-indicator { position: absolute; top: 5px; right: 5px; background: rgba(218, 165, 32, 0.9); color: #000; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold; } </style></head><body><!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 --><div class=\"$1\"><!-- 新增：视图切换按钮 --><!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 --><button id=\"mobile-panel-toggle-btn\" class=\"$1\" title=\"显示/隐藏面板\" style=\"\">☰</button><!-- 浮动按钮 --><button id=\"floating-character-btn\" class=\"$1\" title=\"角色面板\">角色</button><button id=\"floating-interaction-btn\" class=\"$1\" title=\"功能面板\">功能</button><div class=\"$1\"><!-- 顶部状态栏 --><!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 --><div class=\"$1\"><div class=\"$1\"><div class=\"$1\">当前纪年</div><div id=\"val-jinian\" class=\"$1\">...</div></div><div class=\"$1\"><div class=\"$1\">归墟充能</div><div id=\"val-guixu-charge-text\" class=\"$1\">...%</div><div id=\"bar-guixu-charge\" class=\"$1\"></div></div></div><!-- 左侧角色面板 --><!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 --><div class=\"$1\"><!-- 左侧面板折叠控制按钮 --><button class=\"$1\" id=\"left-panel-toggle\" title=\"折叠/展开左侧面板\"><span class=\"$1\">◀</span></button><div class=\"$1\"><div class=\"$1\">核心属性 <span style=\"\">(当前/上限)</span></div><div class=\"$1\"><div class=\"$1\"><span class=\"$1\">法力</span><span id=\"attr-fali\" class=\"$1\">...</span></div><div class=\"$1\"><span class=\"$1\">神海</span><span id=\"attr-shenhai\" class=\"$1\">...</span></div><div class=\"$1\"><span class=\"$1\">道心</span><span id=\"attr-daoxin\" class=\"$1\">...</span></div><div class=\"$1\"><span class=\"$1\">空速</span><span id=\"attr-kongsu\" class=\"$1\">...</span></div><div class=\"$1\"><span class=\"$1\">气运</span><span id=\"attr-qiyun\" class=\"$1\">...</span></div></div></div><div class=\"$1\"><div class=\"$1\">修为详情</div><div class=\"$1\"><div class=\"$1\"><span class=\"$1\">当前境界</span><span id=\"val-jingjie\" class=\"$1\">...</span></div><div class=\"$1\"><span class=\"$1\">境界映射</span><span id=\"attr-jingjie-yingshe\" class=\"$1\">1</span></div><div class=\"$1\"><span class=\"$1\">修为进度</span><span id=\"attr-xiuxing-jindu\" class=\"$1\">0%</span></div><div class=\"$1\" style=\"\"></div><div class=\"$1\"><span class=\"$1\">当前瓶颈</span><span id=\"attr-xiuxing-pingjing\" class=\"$1\">无</span></div></div></div><div class=\"$1\"><div class=\"$1\">天赋灵根</div><div id=\"talent-linggen-list\" class=\"$1\"><!-- 天赋和灵根将动态填充在这里 --></div></div><div class=\"$1\"><div class=\"$1\">当前装备</div><div class=\"$1\"><div id=\"equip-wuqi\" class=\"$1\">武器</div><div id=\"equip-fangju\" class=\"$1\">防具</div><div id=\"equip-shipin\" class=\"$1\">饰品</div><div id=\"equip-fabao1\" class=\"$1\">法宝</div><div id=\"equip-zhuxiuGongfa\" class=\"$1\">主修功法</div><div id=\"equip-fuxiuXinfa\" class=\"$1\">辅修心法</div></div></div></div><!-- 中央内容区 --><!-- 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 --><div class=\"$1\"><!-- 新增：思维过程按钮和显示区域 --><button id=\"btn-toggle-thinking\" class=\"$1\" style=\"\">查看思维过程</button><div id=\"game-text-display\" class=\"$1\"><!-- AI生成的主要游戏文本将显示在这里 --><gametxt> 欢迎来到《归墟》的世界。你的宿命，由此开始。 </gametxt></div><!-- 新增：变量改变提醒 --><div id=\"variable-changes-reminder\" class=\"$1\" style=\"\"><div class=\"$1\" id=\"variable-changes-header\"><div class=\"$1\"><span class=\"$1\" id=\"variable-changes-icon\">▼</span><span>变量改变</span><span class=\"$1\" id=\"variable-changes-count\">0</span></div></div><div class=\"$1\" id=\"variable-changes-content\"><!-- 变量改变内容将在这里显示 --></div></div><!-- 新增：行动选项容器 --></div><!-- 右侧交互面板 --><div class=\"$1\"><!-- 右侧面板折叠控制按钮 --><button class=\"$1\" id=\"right-panel-toggle\" title=\"折叠/展开右侧面板\"><span class=\"$1\">▶</span></button><div class=\"$1\"><button id=\"btn-inventory\" class=\"$1\">背包</button><button id=\"btn-relationships\" class=\"$1\">人物关系</button><button id=\"btn-guixu-system\" class=\"$1\">归墟系统</button><button id=\"btn-save-load-manager\" class=\"$1\">存档/读档</button><button id=\"btn-novel-mode\" class=\"$1\">小说模式</button><button id=\"btn-settings\" class=\"$1\">设置</button><!-- 新增：统一的世界书控制模块 --><div id=\"world-book-controls\" class=\"$1\" style=\"\"><div class=\"$1\" style=\"\">世界书控制</div><div style=\"\"><div style=\"\"><label for=\"unified-index-input\" style=\"\">读写序号:</label><input type=\"number\" id=\"unified-index-input\" value=\"1\" min=\"1\" style=\"\"></div><div style=\"\"><input type=\"checkbox\" id=\"auto-toggle-lorebook-checkbox\" style=\"\"><label for=\"auto-toggle-lorebook-checkbox\" class=\"$1\" style=\"\">自动开关世界书</label></div></div></div><!-- 时间线按钮已移至存档界面 --><div class=\"$1\"><div class=\"$1\">世界线回顾</div><div style=\"\"><button id=\"btn-view-journey-main\" class=\"$1\" style=\"\">本世历程</button><button id=\"btn-view-past-lives-main\" class=\"$1\" style=\"\">往世涟漪</button></div></div></div></div><!-- 底部状态效果 --><div id=\"bottom-status-container\" class=\"$1\"><div style=\"\"><!-- 修改：将状态列表改为一个可点击的摘要按钮 --><div id=\"status-summary-button\" class=\"$1\"><span id=\"status-summary-text\">当前无状态效果</span></div><!-- 新增：流式开关 --><div style=\"\"><input type=\"checkbox\" id=\"streaming-enabled-checkbox\" style=\"\"><label for=\"streaming-enabled-checkbox\" class=\"$1\" style=\"\">开启流式</label></div></div><div class=\"$1\"><!-- 输入框 --><textarea id=\"quick-send-input\" class=\"$1\" placeholder=\"请在此输入回复...\"></textarea></div><!-- 发送按钮行：历史记录在左边，发送在右边 --><div class=\"$1\"><button id=\"btn-show-cache\" class=\"$1\">历史记录</button><button id=\"btn-quick-send\" class=\"$1\">发送</button></div></div></div><!-- 各种模态窗口 --><div id=\"inventory-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">我的背包</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"><!-- 背包内容将由JS动态填充 --></div></div></div><div id=\"relationships-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">人物关系</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"><!-- 人物关系内容将由JS动态填充 --></div></div></div><div id=\"history-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 id=\"history-modal-title\" class=\"$1\">历史回顾</h2><button class=\"$1\" style=\"\">&times;</button></div><div id=\"history-modal-body\" class=\"$1\"><!-- 新增：修剪控制台 --><div id=\"trim-console\" class=\"$1\" style=\"\"><div class=\"$1\">修剪控制台</div><div style=\"\"><!-- 修剪字段选择 --><div id=\"trim-fields-container\" style=\"\"><span style=\"\">修剪字段:</span><label style=\"\"><input type=\"checkbox\" class=\"$1\" value=\"人物\" checked> 人物</label><label style=\"\"><input type=\"checkbox\" class=\"$1\" value=\"人物关系\" checked> 人物关系</label><label style=\"\"><input type=\"checkbox\" class=\"$1\" value=\"重要信息\" checked> 重要信息</label><label style=\"\"><input type=\"checkbox\" class=\"$1\" value=\"暗线与伏笔\" checked> 暗线与伏笔</label><label style=\"\"><input type=\"checkbox\" class=\"$1\" value=\"地点\"> 地点</label><label style=\"\"><input type=\"checkbox\" class=\"$1\" value=\"标签\"> 标签</label><label style=\"\"><input type=\"checkbox\" class=\"$1\" value=\"自动化系统\"> 自动化系统</label></div><hr style=\"\"><!-- 自动化和手动操作 --><div style=\"\"><!-- 左侧：自动化批量操作 --><div style=\"\"><label for=\"trim-keep-count\" style=\"\">保留最近</label><input type=\"number\" id=\"trim-keep-count\" value=\"10\" min=\"1\" style=\"\"><span style=\"\">条，其余的:</span><button id=\"btn-auto-trim\" class=\"$1\" style=\"\">修剪勾选字段</button><button id=\"btn-full-trim\" class=\"$1\" style=\"\">永久删除</button></div><!-- 右侧：手动精准操作 --><div style=\"\"><label style=\"\">对于历程中勾选的条目:</label><button id=\"btn-precise-trim\" class=\"$1\" style=\"\">修剪上方勾选字段</button></div></div></div></div><!-- 历程/涟漪内容将由JS动态填充 --></div></div></div><div id=\"novel-mode-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 id=\"novel-mode-modal-title\" class=\"$1\">小说模式</h2><div style=\"\"><label for=\"novel-mode-index-input\" style=\"\">读写序号:</label><input type=\"number\" id=\"novel-mode-index-input\" value=\"1\" min=\"1\" style=\"\"></div><button class=\"$1\" style=\"\">&times;</button></div><div id=\"novel-mode-modal-body\" class=\"$1\"><!-- Novel mode content will be dynamically filled here --></div></div></div><div id=\"command-center-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">指令中心</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"><!-- 指令将由JS动态填充 --></div><div class=\"$1\"><button id=\"btn-refresh-storage\" class=\"$1\">刷新缓存</button><div><button id=\"btn-clear-commands\" class=\"$1\">清空指令</button><button id=\"btn-execute-commands\" class=\"$1\" style=\"\"> 执行指令 </button></div></div></div></div><div id=\"extracted-content-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">最后一次提取的AI内容</h2><button class=\"$1\" style=\"\">&times;</button></div><div class=\"$1\"><div class=\"$1\"><div class=\"$1\" style=\"\"><span>本世历程</span><button id=\"btn-write-journey\" class=\"$1\" style=\"\"> 写入世界书 </button></div><pre id=\"extracted-journey\" style=\"\"> 无内容</pre></div><div class=\"$1\"><div class=\"$1\" style=\"\"><span>往世涟漪</span><button id=\"btn-write-past-lives\" class=\"$1\" style=\"\"> 写入世界书 </button></div><pre id=\"extracted-past-lives\" style=\"\"> 无内容</pre></div><div class=\"$1\"><div class=\"$1\" style=\"\"><span>小说模式</span><button id=\"btn-write-novel-mode\" class=\"$1\" style=\"\"> 写入世界书 </button></div><pre id=\"extracted-novel-mode\" style=\"\"> 小说模式已关闭</pre></div><div class=\"$1\"><div class=\"$1\" style=\"\"><span>提取角色</span><button id=\"btn-write-character-card\" class=\"$1\" style=\"\"> 写入世界书 </button></div><pre id=\"extracted-character-card\" style=\"\"> 无内容</pre></div><div class=\"$1\"><div class=\"$1\" style=\"\"><span>地图指令</span><button id=\"btn-execute-map-commands\" class=\"$1\" style=\"\"> 解析指令 </button></div><pre id=\"extracted-map-commands\" style=\"\"> 无内容</pre></div><!-- 新增：将自动写入选项移动到此模态框内部 --><div class=\"$1\"><input type=\"checkbox\" id=\"novel-mode-enabled-checkbox\" /><label for=\"novel-mode-enabled-checkbox\" class=\"$1\">开启小说模式</label><input type=\"checkbox\" id=\"auto-write-checkbox\" checked style=\"\" /><label for=\"auto-write-checkbox\" class=\"$1\">自动写入历程/涟漪</label><input type=\"checkbox\" id=\"action-options-enabled-checkbox\" checked style=\"\" /><label for=\"action-options-enabled-checkbox\" class=\"$1\">显示行动选项</label><input type=\"checkbox\" id=\"auto-send-action-checkbox\" checked style=\"\" /><label for=\"auto-send-action-checkbox\" class=\"$1\">行动选项-点击即发送</label><input type=\"checkbox\" id=\"format-validation-enabled-checkbox\" checked style=\"\" /><label for=\"format-validation-enabled-checkbox\" class=\"$1\">格式审查</label></div><details class=\"$1\" style=\"\"><summary class=\"$1\" style=\"\"><span>本次变量改变</span></summary><pre id=\"extracted-variable-changes\" style=\"\"> 无内容</pre></details><details class=\"$1\" style=\"\"><summary class=\"$1\" style=\"\"><span>当前变量</span></summary><pre id=\"current-mvu-variables\" style=\"\">加载中...</pre></details></div></div></div><!-- 装备详情悬浮提示框 (移至body末尾) --><!-- 新增：快速指令弹出菜单 --><div id=\"quick-command-popup\"><!-- 内容将由JS动态填充 --></div><!-- 新增：状态效果详情弹出窗口 --><div id=\"status-effects-popup\" class=\"$1\"><div class=\"$1\"><span>当前状态效果</span><button id=\"status-effects-popup-close\">&times;</button></div><div id=\"status-effects-popup-list\" class=\"$1\"><!-- 状态列表将由JS动态填充 --></div></div></div><!-- 新增：窗口大小调整控制面板 --><div id=\"window-size-panel\" class=\"$1\" style=\"\"><div class=\"$1\"><span>窗口大小调整</span><button id=\"window-size-close\">&times;</button></div><div class=\"$1\"><div class=\"$1\"><label for=\"width-slider\">宽度: <span id=\"width-display\">900px</span></label><input type=\"range\" id=\"width-slider\" min=\"600\" max=\"1400\" value=\"900\" step=\"50\"></div><div class=\"$1\"><label for=\"height-slider\">高度: <span id=\"height-display\">600px</span></label><input type=\"range\" id=\"height-slider\" min=\"400\" max=\"1000\" value=\"600\" step=\"50\"></div><div class=\"$1\"><button id=\"reset-size-btn\" class=\"$1\">重置默认</button></div></div></div><!-- 新增：归墟系统模态窗口 --><div id=\"guixu-system-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">归墟系统</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"><!-- 归墟系统信息将由JS动态填充 --></div></div></div><!-- 新增：自定义确认模态框 --><div id=\"custom-confirm-modal\" class=\"$1\"><div class=\"$1\"><div id=\"custom-confirm-message\" class=\"$1\"><!-- 消息将由JS填充 --></div><div class=\"$1\"><button id=\"custom-confirm-btn-ok\" class=\"$1\">确认</button><button id=\"custom-confirm-btn-cancel\" class=\"$1\">取消</button></div></div></div><!-- 新增：格式审查详情模态框 --><div id=\"format-validation-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">🔍 格式审查详情</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"><div class=\"$1\"><h3 style=\"\">检测到的格式问题：</h3><div id=\"format-errors-list\" class=\"$1\"><!-- 格式错误列表将由JS动态填充 --></div></div><div class=\"$1\" style=\"\"><button id=\"format-validation-rollback\" class=\"$1\" style=\"\">回退到上一条内容</button><button id=\"format-validation-continue\" class=\"$1\">保留并继续处理</button></div></div></div></div><!-- 新增：输入缓存模态窗口 --><div id=\"input-cache-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">输入历史</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"><div class=\"$1\"><h3 class=\"$1\" style=\"\">最近两次输入</h3><ul id=\"recent-inputs-list\" class=\"$1\"><li class=\"$1\">暂无记录</li></ul></div><details class=\"$1\"><summary class=\"$1\" style=\"\">所有历史记录</summary><ul id=\"all-inputs-list\" class=\"$1\"><li class=\"$1\">暂无记录</li></ul></details></div></div></div><!-- 新增：存档/读档管理模态窗口 --><div id=\"save-load-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">存档管理</h2><div style=\"\"><button id=\"btn-import-save\" class=\"$1\">导入存档</button><button id=\"btn-clear-all-saves\" class=\"$1\">清除所有存档</button></div><button class=\"$1\" style=\"\">&times;</button></div><div class=\"$1\"><!-- 新增：自动存档部分 --><div class=\"$1\"><div class=\"$1\">自动存档</div><div class=\"$1\"><label for=\"auto-save-checkbox\">开启自动存档</label><input type=\"checkbox\" id=\"auto-save-checkbox\" /></div></div><!-- 新增：自动存档专用槽位 --><div id=\"auto-save-slot-container\" style=\"\"><!-- 自动存档将由JS动态填充 --></div><div id=\"save-slots-container\"><!-- 存档槽位将由JS动态填充 --></div></div></div></div><!-- 新增：用于文件导入的隐藏input --><input type=\"file\" id=\"import-file-input\" style=\"\" accept=\".json\" /><!-- 新增：地图模态窗口 --><div id=\"map-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">玄昊界地图</h2><!-- 新增：地图控制，包含缩放滑块 --><div class=\"$1\"><span id=\"zoom-level-display\">100%</span><input type=\"range\" id=\"zoom-slider\" min=\"0.05\" max=\"5\" step=\"0.01\" value=\"1\"><!-- 新增：坐标显示和回到玩家按钮 --><span id=\"cursor-coords-display\">x: ---, y: ---</span><button id=\"btn-center-player\" title=\"回到当前位置\">●</button></div><button class=\"$1\" style=\"\">&times;</button></div><div class=\"$1\" id=\"map-modal-body\"><!-- 地图内容将由JS动态填充 --></div></div></div><!-- 新增：自动化系统修剪模态框 --><div id=\"trim-journey-modal\" class=\"$1\"><div class=\"$1\" style=\"\"><div class=\"$1\"><h2 class=\"$1\">自动化系统修剪</h2><button class=\"$1\">&times;</button></div><div class=\"$1\" style=\"\"><p style=\"\"> 此功能将移除\"本世历程\"中除最近两个事件外的所有\"自动化系统\"内容，以优化性能和减少干扰。 </p><div class=\"$1\"><div class=\"$1\">修剪选项</div><div class=\"$1\" style=\"\"><div class=\"$1\"><span class=\"$1\">读取/写入序号</span><input type=\"number\" id=\"trim-journey-index-input\" value=\"1\" min=\"1\" style=\"\"></div></div></div><div class=\"$1\" style=\"\"><button id=\"btn-confirm-trim\" class=\"$1\">确认修剪</button><button id=\"btn-cancel-trim\" class=\"$1\">取消</button></div></div></div></div><!-- 新增：设置模态框 --><div id=\"settings-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">设置</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"><div class=\"$1\"><div class=\"$1\">界面控制</div><div style=\"\"><button id=\"view-toggle-btn\" class=\"$1\" style=\"\"><span style=\"\">📱</span><div style=\"\"><div>切换视图模式</div><div style=\"\">在桌面和移动视图间切换</div></div></button><button id=\"fullscreen-btn\" class=\"$1\" style=\"\"><span style=\"\">↔️</span><div style=\"\"><div>进入全屏模式</div><div style=\"\">全屏显示游戏界面</div></div></button><button id=\"exit-fullscreen-btn\" class=\"$1\" style=\"\"><span style=\"\">↘️</span><div style=\"\"><div>退出全屏模式</div><div style=\"\">返回窗口模式</div></div></button><button id=\"window-size-btn\" class=\"$1\" style=\"\"><span style=\"\">📏</span><div style=\"\"><div>调整窗口大小</div><div style=\"\">自定义界面尺寸</div></div></button></div></div><div class=\"$1\"><div class=\"$1\">界面设置</div><div style=\"\"><button id=\"background-settings-btn\" class=\"$1\" style=\"\"><span style=\"\">🖼️</span><div style=\"\"><div>背景图设置</div><div style=\"\">管理自定义背景图片</div></div></button><!-- 新增：主界面透明度调节 --><div style=\"\"><div style=\"\"><span style=\"\">🌅</span><div style=\"\"><div style=\"\">背景图显示强度</div><div style=\"\">调节界面透明度，让背景图更清晰</div></div></div><div style=\"\"><span style=\"\">背景清晰</span><input type=\"range\" id=\"opacity-slider\" min=\"0\" max=\"100\" value=\"100\" style=\"\"><span style=\"\">界面清晰</span></div><div style=\"\"><span id=\"opacity-value\" style=\"\">当前设置: 100%</span></div></div></div></div><div class=\"$1\"><div class=\"$1\">文字设置</div><div style=\"\"><!-- 颜色设置 --><div><div style=\"\">文字颜色</div><div style=\"\"><div style=\"\"><span style=\"\">正文:</span><input type=\"color\" id=\"text-color-normal\" value=\"#e8dcc6\" style=\"\"></div><div style=\"\"><span style=\"\">对话:</span><input type=\"color\" id=\"text-color-dialogue\" value=\"#ff1493\" style=\"\"></div><div style=\"\"><span style=\"\">心理活动:</span><input type=\"color\" id=\"text-color-psychology\" value=\"#ffffff\" style=\"\"></div><div style=\"\"><span style=\"\">景物描写:</span><input type=\"color\" id=\"text-color-scenery\" value=\"#98fb98\" style=\"\"></div></div></div><!-- 字体大小设置 --><div><div style=\"\">字体大小</div><div style=\"\"><input type=\"range\" id=\"font-size-slider\" min=\"12\" max=\"24\" value=\"14\" style=\"\"><span id=\"font-size-value\" style=\"\">14px</span></div></div><!-- 字体选择 --><div><div style=\"\">字体选择</div><select id=\"font-family-select\" style=\"\"><!-- 选项将通过JavaScript动态生成 --></select><div style=\"\"><div>• 支持格式：TTF, OTF, WOFF, WOFF2</div><div>• 文件大小限制：10MB（推荐2MB以下）</div><div>• 选择\"+ 上传新字体\"来添加自定义字体</div><div>• 如需压缩，请使用<button id=\"font-compress-help-btn\" style=\"\">在线工具</button></div></div></div><!-- 自定义字体管理 --><div id=\"custom-font-section\"><div style=\"\">自定义字体管理</div><input type=\"file\" id=\"font-file-input\" accept=\".ttf,.otf,.woff,.woff2\" style=\"\"></div><!-- 重置按钮 --><div style=\"\"><button id=\"reset-text-settings-btn\" class=\"$1\" style=\"\">重置默认</button><button id=\"preview-text-settings-btn\" class=\"$1\" style=\"\">预览效果</button></div></div></div><div class=\"$1\"><div class=\"$1\">输入设置</div><div style=\"\"><div style=\"\"><input type=\"checkbox\" id=\"enter-send-checkbox\" style=\"\"><label for=\"enter-send-checkbox\" style=\"\"><div>回车发送</div><div style=\"\">开启后按回车键即可发送消息</div></label></div></div></div><div class=\"$1\"><div class=\"$1\">功能入口</div><div style=\"\"><button id=\"btn-command-center-from-settings\" class=\"$1\">指令中心</button><button id=\"btn-show-extracted-from-settings\" class=\"$1\">查看提取内容</button><button id=\"btn-map-from-settings\" class=\"$1\">地图</button></div></div></div></div></div><!-- 新增：背景图设置模态框 --><div id=\"background-settings-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">背景图设置</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"><!-- 显示模式选择 --><div class=\"$1\"><div class=\"$1\">显示模式</div><div style=\"\"><label style=\"\"><input type=\"radio\" name=\"background-mode\" value=\"random\" id=\"bg-mode-random\" checked><span style=\"\">随机显示</span><span style=\"\">每次回复后随机选择一张背景图</span></label><label style=\"\"><input type=\"radio\" name=\"background-mode\" value=\"fixed\" id=\"bg-mode-fixed\"><span style=\"\">固定显示</span><span style=\"\">始终显示选中的背景图</span></label></div></div><!-- 上传区域 --><div class=\"$1\"><div class=\"$1\">添加背景图</div><div style=\"\"><!-- 本地文件上传 --><div id=\"background-upload-area\" style=\"\"><div style=\"\">📁</div><div style=\"\">点击选择图片文件</div><div style=\"\">支持 JPG、PNG、GIF 格式</div></div><input type=\"file\" id=\"background-file-input\" accept=\"image/*\" multiple style=\"\"><!-- 外链图床输入 --><div style=\"\"><div style=\"\"><span style=\"\">🔗 或添加外链图床</span><button id=\"manage-url-images-btn\" class=\"$1\" style=\"\">管理外链</button></div><textarea id=\"image-url-input\" placeholder=\"请输入一个或多个图片链接，每行一个\" rows=\"4\" style=\"\"></textarea><button id=\"add-url-image-btn\" class=\"$1\" style=\"\">添加链接</button><div style=\"\"> 支持常见图床：imgur、postimg、sm.ms 等，确保链接可直接访问 </div></div></div></div><!-- 背景图列表 --><div class=\"$1\"><div class=\"$1\"><span>背景图列表</span><span id=\"background-count\" style=\"\">(0张)</span></div><div id=\"background-list\" style=\"\"><!-- 背景图项目将动态添加到这里 --></div></div></div></div></div><!-- 图床链接管理模态框 --><div id=\"url-images-manage-modal\" class=\"$1\"><div class=\"$1\"><div class=\"$1\"><h2 class=\"$1\">🔗 图床链接管理</h2><button class=\"$1\" onclick=\"GuixuManager.closeModal('url-images-manage-modal')\">&times;</button></div><div class=\"$1\"><div style=\"\"><div style=\"\"><span style=\"\">外链图片列表</span><span id=\"url-images-count\" style=\"\">(0张)</span></div><!-- 外链图片列表 --><div id=\"url-images-list\" style=\"\"><div style=\"\">暂无外链图片</div></div></div><div style=\"\"><button class=\"$1\" onclick=\"GuixuManager.closeModal('url-images-manage-modal')\" style=\"\">关闭</button></div></div></div></div><!-- 编辑图片名称模态框 --><div id=\"edit-image-name-modal\" class=\"$1\"><div class=\"$1\" style=\"\"><div class=\"$1\"><h2 class=\"$1\">✏️ 编辑图片名称</h2><button class=\"$1\" onclick=\"GuixuManager.closeModal('edit-image-name-modal')\">&times;</button></div><div class=\"$1\"><div style=\"\"><label style=\"\">图片名称：</label><input type=\"text\" id=\"edit-image-name-input\" placeholder=\"请输入新的图片名称\" style=\"\"></div><div style=\"\"><button class=\"$1\" onclick=\"GuixuManager.closeModal('edit-image-name-modal')\" style=\"\">取消</button><button id=\"save-image-name-btn\" class=\"$1\">保存</button></div></div></div></div></div></div></div></div></div></div><script> // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 // --- SillyTavern Global API --- // These are provided by the SillyTavern environment at runtime. // We will check for their existence before using them. /* global TavernHelper, eventOn, tavern_events, getChatMessages, getCurrentMessageId, _ */ // --- Main Application Logic --- (function () { 'use strict'; // --- API Availability Check --- if ( typeof TavernHelper === 'undefined' || typeof eventOn === 'undefined' || typeof tavern_events === 'undefined' || typeof getChatMessages === 'undefined' || typeof getCurrentMessageId === 'undefined' ) { console.error('TavernHelper API, event system, or lodash not found.'); document.addEventListener('DOMContentLoaded', () => { document.body.innerHTML = '<h1 style=\"\">错误：SillyTavern 环境 API 未找到或版本不兼容</h1><p style=\"\">请确保已安装并启用 TavernHelper 扩展。</p>'; }); return; } // --- Core Application Object for UI Interactions --- // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 const GuixuManager = { listenersBound: false, // 新增：防止事件监听器重复绑定的标志 // 新增：跟踪是否从设置界面进入子窗口 isFromSettingsModal: false, // 新增：主界面透明度设置 mainOpacity: 100, // 默认100%不透明 intimateCharacters: new Set(), // 新增：用于存储亲密角色的Set // 新增：面板折叠状态 leftPanelCollapsed: false, rightPanelCollapsed: false, // 追踪已装备物品的状态 // **逻辑修正**: equippedItems 现在存储完整的物品对象，而不仅仅是ID equippedItems: { wuqi: null, fangju: null, shipin: null, fabao1: null, zhuxiuGongfa: null, fuxiuXinfa: null, }, currentMvuState: null, // 新增：用于缓存当前最新的mvu状态 pendingActions: [], // 购物车/指令队列 baseAttributes: {}, // 存储从mvu加载的原始属性 calculatedMaxAttributes: {}, // 新增：用于缓存计算后的属性上限 lastExtractedJourney: null, lastExtractedPastLives: null, lastExtractedNovelText: null, // 新增：用于存储提取的原始正文 lastExtractedCharacterCard: null, // 新增：用于存储提取的角色卡 lastExtractedMapCommands: null, // 新增：用于存储提取的地图指令 lastExtractedThinking: null, // 新增：用于存储提取的思维过程 lastExtractedVariables: null, // 新增：用于存储变量改变 lastSentPrompt: null, // 新增：用于存储发送给AI的完整提示 isNovelModeEnabled: false, // 新增：小说模式开关状态 isAutoWriteEnabled: true, // 默认开启自动写入 autoWriteIntervalId: null, // 用于存储轮询计时器ID novelModeAutoWriteIntervalId: null, // 新增：小说模式的自动写入轮询ID isMobileView: false, // 新增：追踪移动视图状态 isCharacterPanelVisible: false, // 新增：追踪角色面板的显示状态 isInteractionPanelVisible: false, // 新增：追踪交互面板的显示状态 unifiedIndex: 1, // 新增：统一的读写序号 novelModeIndex: 1, // 新增：小说模式独立的读写序号 isAutoToggleLorebookEnabled: false, // 新增：自动开关世界书状态 autoToggleIntervalId: null, // 新增：轮询计时器ID isAutoSaveEnabled: false, // 新增：自动存档开关状态 isActionOptionsEnabled: true, // 新增：行动选项开关状态 isActionAutoSend: true, // 新增：行动选项自动发送开关状态 mapUpdateIntervalId: null, // 新增: 地图自动更新轮询ID isAutoTrimEnabled: false, // 新增：自动修剪开关状态 isStreamingGametxt: false, // 新增：跟踪<gametxt>流式状态 isStreamingEnabled: true, // 新增：流式开关状态 isFormatValidationEnabled: true, // 新增：格式审查开关状态 isEnterSendEnabled: false, // 新增：回车发送开关状态 lastValidGametxtHTML: '', // 新增：用于备份上一次有效的正文HTML intimateCharacters: [], // 新增：亲密关系角色ID列表 // --- 新增：文字设置状态 --- textSettings: { colors: { normal: '#e8dcc6', // 正文颜色 dialogue: '#ff1493', // 对话颜色 psychology: '#ffffff', // 心理活动颜色 scenery: '#98fb98' // 景物描写颜色 }, fontSize: 14, // 字体大小 fontFamily: \"'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif\", // 字体族 customFonts: [] // 用户上传的自定义字体 }, // --- 新增：背景图管理状态 --- backgroundImages: [], // 存储用户上传的背景图 backgroundMode: 'random', // 'random' 或 'fixed' selectedBackgroundId: null, // 固定模式下选中的背景图ID // --- 新增：地图缩放/平移状态 --- mapState: { scale: 1, panX: 0, panY: 0, isPanning: false, startX: 0, startY: 0, animationFrameId: null, // 用于优化拖动性能 playerMapPos: null, // 新增：用于存储玩家在地图上的像素坐标 }, // --- 新增：处理所有动作的核心函数 --- waitingMessages: [ '呜呜呜呜伟大的梦星大人啊，请给你虔诚的信徒{{user}}回复吧......', '梦星大人，我们敬爱你口牙！！请给我回复吧！！', '梦星大人正在回应你的请求，七个工作日给你回复', '正在向伟大梦星祈祷......呜呜呜你快一点好不好' ], showWaitingMessage() { this.hideWaitingMessage(); // Ensure only one is visible const message = this.waitingMessages[Math.floor(Math.random() * this.waitingMessages.length)]; const msgElement = document.createElement('div'); msgElement.id = 'waiting-popup'; msgElement.className = 'waiting-popup'; // 更新HTML结构以包含spinner msgElement.innerHTML = ` <span>${message}</span> `; const container = document.querySelector(\\'$1\\'); if (container) { container.appendChild(msgElement); } }, hideWaitingMessage() { const existingMsg = document.getElementById('waiting-popup'); if (existingMsg) { existingMsg.remove(); } }, updateWaitingMessage(text) { const popup = document.getElementById('waiting-popup'); if (popup) { const span = popup.querySelector('span'); if (span) { span.textContent = text; } } }, // --- 新增：视图切换核心功能 --- toggleViewMode() { this.isMobileView = !this.isMobileView; const container = document.querySelector(\\'$1\\'); const btn = document.getElementById('view-toggle-btn'); if (container && btn) { if (this.isMobileView) { container.classList.add('mobile-view'); btn.textContent = '💻'; // 切换到桌面图标 btn.title = '切换到桌面视图'; } else { container.classList.remove('mobile-view'); btn.textContent = '📱'; // 切换到手机图标 btn.title = '切换到移动视图'; } } this.saveViewMode(); }, saveViewMode() { try { localStorage.setItem('guixu_view_mode', this.isMobileView ? 'mobile' : 'desktop'); } catch (e) { console.error('保存视图模式失败:', e); } }, loadViewMode() { try { const savedMode = localStorage.getItem('guixu_view_mode'); // 仅当保存的模式为 'mobile' 时，才在加载时切换到移动视图 if ($1 === $2) { this.isMobileView = true; // 设置初始状态 const container = document.querySelector(\\'$1\\'); const btn = document.getElementById('view-toggle-btn'); if (container && btn) { container.classList.add('mobile-view'); btn.textContent = '💻'; btn.title = '切换到桌面视图'; } } else { this.isMobileView = false; // 确保默认是桌面视图 } } catch (e) { console.error('加载视图模式失败:', e); } }, formatMessageContent(text) { if (!$1) return ''; // 首先，处理换行符。AI响应似乎使用文字“\\\\n”。 let processedText = text.replace(/\\\\n/g, '<br />'); // 章节标题: 第x章 ... -> 放大加粗 processedText = processedText.replace(/(^\\s*第.*?章.*$)/gm, (match) => `<h3 class=\"$1\">${match}</h3>`); // 语言: “...” 或 「...」 -> 保留引号, 应用样式 processedText = processedText.replace(/(“[^”]+”|「[^」]+」)/g, match => { return `<span class=\"$1\">${match}</span>`; }); // 心理: *...* -> 移除星号, 应用样式 processedText = processedText.replace(/\\*([^*]+)\\*/g, (match, p1) => { return `<span class=\"$1\">${p1}</span>`; }); // 景物: 【...】 -> 移除括号, 应用样式, 且不匹配纯数字内容 processedText = processedText.replace(/【([^】\\d]+[^】]*)】/g, (match, p1) => { return `<span class=\"$1\">${p1}</span>`; }); return processedText; }, async init() { console.log('归墟UI交互管理器初始化...'); this.bindStaticListeners(); this.loadWindowSizeState(); // 加载窗口大小状态 this.initBackgroundSystem(); // 初始化背景图系统 await this.updateDynamicData(); // Initial data load this.loadAutoWriteState(); // 加载自动写入状态 this.loadNovelModeState(); // 加载小说模式状态 this.loadEquipmentState(); // 加载已装备物品状态 this.loadPendingActions(); // 加载待处理指令 this.loadViewMode(); // 新增：加载用户保存的视图模式 this.loadUnifiedIndex(); // 新增：加载统一的读写序号 this.loadNovelModeIndex(); // 新增：加载小说模式的读写序号 this.loadAutoToggleState(); // 新增：加载自动开关状态 this.loadAutoSaveState(); // 新增：加载自动存档状态 this.loadActionOptionsState(); // 新增：加载行动选项开关状态 this.loadActionAutoSendState(); // 新增：加载行动选项自动发送状态 this.startMapUpdatePolling(); // 新增: 启动地图轮询 this.loadAutoTrimState(); // 新增：加载自动修剪状态 this.loadPanelStates(); // 新增：加载面板折叠状态 this.loadStreamingState(); // 新增：加载流式开关状态 this.loadFormatValidationState(); // 新增：加载格式审查状态 this.loadEnterSendState(); // 新增：加载回车发送状态 this.loadIntimateList(); // 新增：加载亲密关系列表 this.loadRelationshipSettings(); // 新增：加载人物关系设置 this.loadLastThinking(); // 新增：加载上次的思维过程 this.loadTrimFieldsState(); // 新增：加载修剪字段状态 this.updateThinkingButtonVisibility(); // 新增：根据加载的数据更新按钮 // 已移除 MESSAGE_SWIPED 事件监听器，以避免与核心mvu脚本冲突。 // UI刷新现在通过 handleAction 内部的主动调用来完成。 eventOn(iframe_events.STREAM_TOKEN_RECEIVED_FULLY, (text) => this.handleStreamUpdate(text)); eventOn(iframe_events.GENERATION_ENDED, (text) => this.handleStreamEnd(text)); }, // --- 新增：流式处理函数 --- handleStreamUpdate(text) { if (!$1)) { this.isStreamingGametxt = true; this.updateWaitingMessage('梦星大人正在给你流式生成正文，赞美梦星大人！！！'); // 隐藏变量改变提醒（复用行动选项的逻辑） this.hideVariableChangesReminder(); } const gameTextDisplay = document.getElementById('game-text-display'); if (gameTextDisplay) { const displayText = this._getDisplayText(text); gameTextDisplay.innerHTML = this.formatMessageContent(displayText); } }, // --- 新增：完善的格式验证函数 --- validateResponseFormat(text) { // 定义标签检查配置 const tagConfig = { // 必需标签：必须存在且正确闭合 required: ['gametxt', '本世历程'], // 可选标签：如果存在则必须正确闭合 optional: ['UpdateVariable', 'thinking', 'action'] }; const errors = []; // 先移除thinking标签内的内容，避免其中的标签名称干扰检测 let cleanedText = text; const thinkingRegex = /<thinking>([\\s\\S]*?)<\\/thinking>/gi; cleanedText = cleanedText.replace(thinkingRegex, '<thinking></thinking>'); // 检查所有标签（必需 + 可选） const allTags = [...tagConfig.required, ...tagConfig.optional]; for (const tag of allTags) { const openTagCount = (cleanedText.match(new RegExp(`<${tag}>`, 'gi')) || []).length; const closeTagCount = (cleanedText.match(new RegExp(`</${tag}>`, 'gi')) || []).length; const isRequired = tagConfig.required.includes(tag); console.log(`[格式验证] 标签 ${tag} (${isRequired ? '必需' : '可选'}): 开始=${openTagCount}, 结束=${closeTagCount}`); // 1. 检查必需标签是否完全缺失 if ($1 === $2) { const errorMsg = `&lt;${tag}&gt;没有`; console.log(`[格式验证] 添加错误: ${errorMsg}`); errors.push({ tag: tag, type: 'missing', message: errorMsg }); } // 2. 检查标签闭合情况（对所有存在的标签） else if ($1 === $2) { const errorMsg = `&lt;${tag}&gt;标签没闭合`; console.log(`[格式验证] 添加错误: ${errorMsg}`); errors.push({ tag: tag, type: 'unclosed', message: errorMsg }); } // 3. 检查只有结束标签的情况 else if ($1 === $2) { const errorMsg = `&lt;${tag}&gt;标签缺失开始标签`; console.log(`[格式验证] 添加错误: ${errorMsg}`); errors.push({ tag: tag, type: 'incomplete', message: errorMsg }); } // 4. 检查标签数量不匹配的情况 else if ($1 === $2) { const errorMsg = `&lt;${tag}&gt;标签没闭合`; console.log(`[格式验证] 添加错误: ${errorMsg}`); errors.push({ tag: tag, type: 'mismatch', message: errorMsg }); } } return { isValid: errors.length === 0, errors: errors, summary: { total: errors.length, missing: errors.filter(e => e.type === 'missing').length, unclosed: errors.filter(e => e.type === 'unclosed').length, incomplete: errors.filter(e => e.type === 'incomplete').length, mismatch: errors.filter(e => e.type === 'mismatch').length } }; }, // --- 新增：显示格式审查详情界面 --- showFormatValidationDetails(errors, finalText) { const modal = document.getElementById('format-validation-modal'); const errorsList = document.getElementById('format-errors-list'); const rollbackBtn = document.getElementById('format-validation-rollback'); const continueBtn = document.getElementById('format-validation-continue'); if (!$1) return; // 清空并填充错误列表 errorsList.innerHTML = ''; // 按错误类型分组显示 const errorsByType = { missing: errors.filter(e => e.type === 'missing'), unclosed: errors.filter(e => e.type === 'unclosed'), incomplete: errors.filter(e => e.type === 'incomplete'), mismatch: errors.filter(e => e.type === 'mismatch') }; // 定义错误类型的显示信息 const typeInfo = { missing: { icon: '❌', title: '缺失必需标签', priority: 1 }, unclosed: { icon: '⚠️', title: '标签未闭合', priority: 2 }, incomplete: { icon: '🔧', title: '标签不完整', priority: 3 }, mismatch: { icon: '🔄', title: '标签数量不匹配', priority: 4 } }; // 按优先级显示错误 Object.keys(typeInfo) .sort((a, b) => typeInfo[a].priority - typeInfo[b].priority) .forEach(type => { const typeErrors = errorsByType[type]; if (typeErrors.length> 0) { // 创建错误类型标题 const typeHeader = document.createElement('div'); typeHeader.className = 'format-error-type-header'; typeHeader.innerHTML = ` <span class=\"$1\">${typeInfo[type].icon}</span><span class=\"$1\">${typeInfo[type].title} (${typeErrors.length})</span> `; errorsList.appendChild(typeHeader); // 显示该类型的所有错误 typeErrors.forEach(error => { console.log(`[格式验证显示] 错误对象:`, error); console.log(`[格式验证显示] 错误信息: \"${error.message}\"`); const errorItem = document.createElement('div'); errorItem.className = 'format-error-item'; const messageDiv = document.createElement('div'); messageDiv.className = 'format-error-message'; // 使用textContent而不是innerHTML，避免HTML解析 messageDiv.textContent = error.message.replace(/&lt;/g, '<').replace(/&gt;/g, '>'); errorItem.appendChild(messageDiv); console.log(`[格式验证显示] 生成的HTML: ${errorItem.innerHTML}`); errorsList.appendChild(errorItem); }); } }); // 如果没有错误，显示占位信息 if ($1 === $2) { errorsList.innerHTML = '<div class=\"$1\">✅ 所有标签格式正确</div>'; } // 更新模态框标题以显示错误统计 const modalTitle = modal.querySelector('.modal-title'); if (modalTitle) { const summary = []; if (errorsByType.missing.length> 0) summary.push(`${errorsByType.missing.length}个缺失`); if (errorsByType.unclosed.length> 0) summary.push(`${errorsByType.unclosed.length}个未闭合`); if (errorsByType.incomplete.length> 0) summary.push(`${errorsByType.incomplete.length}个不完整`); if (errorsByType.mismatch.length> 0) summary.push(`${errorsByType.mismatch.length}个不匹配`); const summaryText = summary.length> 0 ? ` (${summary.join(', ')})` : ''; modalTitle.textContent = `🔍 格式审查详情 - 发现 ${errors.length} 个问题${summaryText}`; } // 绑定按钮事件 rollbackBtn.onclick = () => { const gameTextDisplay = document.getElementById('game-text-display'); if (gameTextDisplay && this.lastValidGametxtHTML) { // 恢复到上一次有效的内容 gameTextDisplay.innerHTML = this.lastValidGametxtHTML; this.showTemporaryMessage('内容已回退。'); } this.closeModal('format-validation-modal'); // 关闭等待消息 this.hideWaitingMessage(); }; continueBtn.onclick = () => { this.closeModal('format-validation-modal'); // 接受当前有问题的内容，填充到0层 // 自动补全</UpdateVariable>标签（如果需要） // 继续正常的数据处理流程 // 更新内容缓存为当前版本 // 关闭等待消息并显示确认 // 更新缓存，以便下次出错时回退到这个版本 const gameTextDisplay = document.getElementById('game-text-display'); if (gameTextDisplay) { this.lastValidGametxtHTML = gameTextDisplay.innerHTML; } // 确保等待消息被关闭 this.hideWaitingMessage(); this.showTemporaryMessage('已保留内容，将继续进行数据处理。'); // 继续处理，包括UpdateVariable自动补全 this.continueProcessingWithAutoFix(finalText); }; this.openModal('format-validation-modal'); }, // --- 新增：带自动修复的继续处理函数 --- async continueProcessingWithAutoFix(textToProcess) { console.log('[归墟] continueProcessingWithAutoFix 接收到的文本:', textToProcess); // 检查文本是否为空或无效 if ($1 === $2) { console.error('[归墟] continueProcessingWithAutoFix 接收到空文本，停止处理'); this.hideWaitingMessage(); this.showTemporaryMessage('错误：接收到空内容，无法继续处理。'); return; } // 检查并自动补全UpdateVariable标签 let fixedText = this.autoFixUpdateVariable(textToProcess); // 调用原有的处理逻辑 await this.continueProcessing(fixedText); }, // --- 新增：UpdateVariable标签自动补全 --- autoFixUpdateVariable(text) { // 检查是否有UpdateVariable开始标签但没有结束标签 if (text.includes('<UpdateVariable>') && !text.includes('</UpdateVariable>')) { console.log('[归墟] 检测到UpdateVariable标签未闭合，自动补全中...'); const fixedText = text + '</UpdateVariable>'; this.showTemporaryMessage('已自动补全UpdateVariable结束标签', 3000); return fixedText; } return text; }, // --- 新增：专门用于格式验证后继续处理的函数 --- async continueProcessing(textToProcess) { console.log('[归墟] continueProcessing 被调用，文本长度:', textToProcess ? textToProcess.length : 0); this.updateWaitingMessage('梦星大人正在处理数据逻辑，请怀揣崇高敬意等待ing'); // 1. 提取所有数据 this.lastExtractedNovelText = this._extractLastTagContent('gametxt', textToProcess); this.lastExtractedJourney = this._extractLastTagContent('本世历程', textToProcess); this.lastExtractedPastLives = this._extractLastTagContent('往世涟漪', textToProcess); this.lastExtractedThinking = this._extractLastTagContent('thinking', textToProcess, true); this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', textToProcess, true); this.lastExtractedCharacterCard = this._extractLastTagContent('角色提取', textToProcess); this.lastExtractedMapCommands = this._extractLastTagContent('地图', textToProcess); this.saveLastThinking(); this.updateThinkingButtonVisibility(); this.updateVariableChangesReminder(); // 2. 更新变量 const updateScript = textToProcess; if (updateScript && this.currentMvuState) { const inputData = { old_variables: this.currentMvuState }; let mvuSucceeded = false; try { const mvuPromise = eventEmit('mag_invoke_mvu', updateScript, inputData); const createTimeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('MVU event timeout')), 3000)); await Promise.race([mvuPromise, timeoutPromise]); if (inputData.new_variables) { this.currentMvuState = inputData.new_variables; this.renderUI(this.currentMvuState.stat_data); mvuSucceeded = true; } else { console.log('[归墟] mvu 未返回新状态，尝试前端备用方案。'); } } catch (eventError) { console.error('[归墟] 调用 mag_invoke_mvu 事件时发生错误或超时，尝试前端备用方案:', eventError); } if (!$1) { const modifiedState = this._applyUpdateFallback(updateScript, this.currentMvuState); if (modifiedState) { this.currentMvuState = modifiedState; this.renderUI(this.currentMvuState.stat_data); } } } // 3. 处理地图指令 if (this.lastExtractedMapCommands) { await this.handleMapUpdateCommand(this.lastExtractedMapCommands); } // 4. 更新行动选项 let actionOptionsContent = this._extractLastTagContent('行动选项', textToProcess); if (!$1) { actionOptionsContent = this._extractLastTagContent('action', textToProcess); } this.renderActionOptions(actionOptionsContent); // 5. 静默保存到第0层 const messages = await getChatMessages('0'); if (messages && messages.length> 0) { const messageZero = messages[0]; messageZero.message = textToProcess; messageZero.data = this.currentMvuState; await TavernHelper.setChatMessages([messageZero], { refresh: 'none' }); } // 6. 清理工作 const input = document.getElementById('quick-send-input'); if (input) input.value = ''; this.pendingActions = []; this.savePendingActions(); this.showTemporaryMessage('伟大梦星已回应。'); // 7. 自动存档 if (this.isAutoSaveEnabled) { await this.performAutoSave(); } // 8. 最终刷新UI await this.updateDynamicData(); this.loadEquipmentState(); // 9. 如果是随机模式，切换背景图 if ($1 === $2) { this.applyRandomBackground(); } this.hideWaitingMessage(); }, async handleStreamEnd(finalText) { console.log('[归墟] 流式传输结束，最终文本:', finalText); // 将后续的数据处理逻辑包装成一个可复用的函数 const continueProcess = async (textToProcess) => { this.updateWaitingMessage('梦星大人正在处理数据逻辑，请怀揣崇高敬意等待ing'); // 1. 提取所有数据 this.lastExtractedNovelText = this._extractLastTagContent('gametxt', textToProcess); this.lastExtractedJourney = this._extractLastTagContent('本世历程', textToProcess); this.lastExtractedPastLives = this._extractLastTagContent('往世涟漪', textToProcess); this.lastExtractedThinking = this._extractLastTagContent('thinking', textToProcess, true); this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', textToProcess, true); this.lastExtractedCharacterCard = this._extractLastTagContent('角色提取', textToProcess); this.lastExtractedMapCommands = this._extractLastTagContent('地图', textToProcess); this.saveLastThinking(); // 新增：持久化保存思维过程 this.updateThinkingButtonVisibility(); this.updateVariableChangesReminder(); // 新增：更新变量改变提醒 // 2. 更新变量 const updateScript = textToProcess; if (updateScript && this.currentMvuState) { const inputData = { old_variables: this.currentMvuState }; let mvuSucceeded = false; try { const mvuPromise = eventEmit('mag_invoke_mvu', updateScript, inputData); const createTimeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('MVU event timeout')), 3000)); await Promise.race([mvuPromise, timeoutPromise]); if (inputData.new_variables) { this.currentMvuState = inputData.new_variables; this.renderUI(this.currentMvuState.stat_data); mvuSucceeded = true; } else { console.log('[归墟] mvu 未返回新状态，尝试前端备用方案。'); } } catch (eventError) { console.error('[归墟] 调用 mag_invoke_mvu 事件时发生错误或超时，尝试前端备用方案:', eventError); } if (!$1) { const modifiedState = this._applyUpdateFallback(updateScript, this.currentMvuState); if (modifiedState) { this.currentMvuState = modifiedState; this.renderUI(this.currentMvuState.stat_data); } } } // 3. 处理地图指令 if (this.lastExtractedMapCommands) { await this.handleMapUpdateCommand(this.lastExtractedMapCommands); } // 4. 更新行动选项 let actionOptionsContent = this._extractLastTagContent('行动选项', textToProcess); if (!$1) { actionOptionsContent = this._extractLastTagContent('action', textToProcess); } this.renderActionOptions(actionOptionsContent); // 5. 静默保存到第0层 const messages = await getChatMessages('0'); if (messages && messages.length> 0) { const messageZero = messages[0]; messageZero.message = textToProcess; messageZero.data = this.currentMvuState; await TavernHelper.setChatMessages([messageZero], { refresh: 'none' }); } // 6. 清理工作 const input = document.getElementById('quick-send-input'); if (input) input.value = ''; this.pendingActions = []; this.savePendingActions(); this.showTemporaryMessage('伟大梦星已回应。'); // 7. 自动存档 if (this.isAutoSaveEnabled) { await this.performAutoSave(); } // 8. 最终刷新UI await this.updateDynamicData(); this.loadEquipmentState(); // 9. 如果是随机模式，切换背景图 if ($1 === $2) { this.applyRandomBackground(); } this.hideWaitingMessage(); }; // 格式验证逻辑 if (this.isFormatValidationEnabled) { const validationResult = this.validateResponseFormat(finalText); if (!$1) { // 显示详细的格式审查界面 this.showFormatValidationDetails(validationResult.errors, finalText); } else { // 格式正确，检查UpdateVariable自动补全并继续处理 const gameTextDisplay = document.getElementById('game-text-display'); if (gameTextDisplay) { this.lastValidGametxtHTML = gameTextDisplay.innerHTML; } // 自动补全UpdateVariable标签（如果需要） const fixedText = this.autoFixUpdateVariable(finalText); await continueProcessing(fixedText); } } else { // 禁用审查，直接处理（包括UpdateVariable自动补全） const gameTextDisplay = document.getElementById('game-text-display'); if (gameTextDisplay) { this.lastValidGametxtHTML = gameTextDisplay.innerHTML; } // 自动补全UpdateVariable标签（如果需要） const fixedText = this.autoFixUpdateVariable(finalText); await continueProcessing(fixedText); } }, // --- 新增：全屏功能 --- toggleFullScreen() { const elem = document.querySelector(\\'$1\\'); if (!$1) { elem.requestFullscreen().catch(err => { alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`); }); } else { document.exitFullscreen(); } }, exitFullScreen() { if (document.fullscreenElement) { document.exitFullscreen(); } }, // --- 新增：面板折叠功能 --- toggleLeftPanel() { this.leftPanelCollapsed = !this.leftPanelCollapsed; this.updatePanelStates(); this.savePanelStates(); }, toggleRightPanel() { this.rightPanelCollapsed = !this.rightPanelCollapsed; this.updatePanelStates(); this.savePanelStates(); }, updatePanelStates() { const gameContainer = document.querySelector(\\'$1\\'); const leftPanel = document.querySelector(\\'$1\\'); const rightPanel = document.querySelector(\\'$1\\'); if (!$1) return; // 更新game-container的CSS类 gameContainer.classList.toggle('left-panel-collapsed', this.leftPanelCollapsed); gameContainer.classList.toggle('right-panel-collapsed', this.rightPanelCollapsed); gameContainer.classList.toggle('both-panels-collapsed', this.leftPanelCollapsed && this.rightPanelCollapsed); // 更新面板的折叠状态 leftPanel.classList.toggle('collapsed', this.leftPanelCollapsed); rightPanel.classList.toggle('collapsed', this.rightPanelCollapsed); // 更新箭头方向 - 隐藏/显示模式 const leftArrow = document.querySelector(\\'$1\\'); const rightArrow = document.querySelector(\\'$1\\'); if (leftArrow) { leftArrow.textContent = this.leftPanelCollapsed ? '▶' : '◀'; } if (rightArrow) { rightArrow.textContent = this.rightPanelCollapsed ? '◀' : '▶'; } }, loadPanelStates() { try { const savedStates = localStorage.getItem('guixu_panel_states'); if (savedStates) { const states = JSON.parse(savedStates); this.leftPanelCollapsed = states.leftPanelCollapsed || false; this.rightPanelCollapsed = states.rightPanelCollapsed || false; this.updatePanelStates(); } } catch (e) { console.error('加载面板状态失败:', e); } }, savePanelStates() { try { const states = { leftPanelCollapsed: this.leftPanelCollapsed, rightPanelCollapsed: this.rightPanelCollapsed }; localStorage.setItem('guixu_panel_states', JSON.stringify(states)); } catch (e) { console.error('保存面板状态失败:', e); } }, toggleCharacterPanel() { this.isCharacterPanelVisible = !this.isCharacterPanelVisible; const container = document.querySelector(\\'$1\\'); const floatingBtn = document.getElementById('floating-character-btn'); if (container) { container.classList.toggle('character-panel-visible', this.isCharacterPanelVisible); } if (floatingBtn) { floatingBtn.classList.toggle('active', this.isCharacterPanelVisible); floatingBtn.textContent = this.isCharacterPanelVisible ? '收起' : '角色'; } }, toggleInteractionPanel() { this.isInteractionPanelVisible = !this.isInteractionPanelVisible; const container = document.querySelector(\\'$1\\'); const floatingBtn = document.getElementById('floating-interaction-btn'); if (container) { container.classList.toggle('interaction-panel-visible', this.isInteractionPanelVisible); } if (floatingBtn) { floatingBtn.classList.toggle('active', this.isInteractionPanelVisible); floatingBtn.textContent = this.isInteractionPanelVisible ? '收起' : '功能'; } }, // --- 新增：初始化可拖动按钮功能 --- initDraggableButtons() { const characterBtn = document.getElementById('floating-character-btn'); const interactionBtn = document.getElementById('floating-interaction-btn'); if (characterBtn) { this.makeDraggable(characterBtn, () => this.toggleCharacterPanel()); } if (interactionBtn) { this.makeDraggable(interactionBtn, () => this.toggleInteractionPanel()); } }, // --- 新增：使元素可拖动 --- makeDraggable(element, clickCallback) { let isDragging = false; let startX, startY, startLeft, startTop; let hasMoved = false; // 鼠标事件 element.addEventListener('mousedown', (e) => { isDragging = true; hasMoved = false; startX = e.clientX; startY = e.clientY; startLeft = parseInt(window.getComputedStyle(element).left, 10); startTop = parseInt(window.getComputedStyle(element).top, 10); element.classList.add('dragging'); e.preventDefault(); }); document.addEventListener('mousemove', (e) => { if (!$1) return; const deltaX = e.clientX - startX; const deltaY = e.clientY - startY; // 如果有任何移动，立即认为是拖动（延迟为0） if (Math.abs(deltaX)> 0 || Math.abs(deltaY)> 0) { hasMoved = true; } const newLeft = startLeft + deltaX; const newTop = startTop + deltaY; // 限制在屏幕范围内 const maxLeft = window.innerWidth - element.offsetWidth; const maxTop = window.innerHeight - element.offsetHeight; element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px'; element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px'; }); document.addEventListener('mouseup', () => { if (isDragging) { isDragging = false; element.classList.remove('dragging'); // 如果没有移动，执行点击回调 if (!$1) { clickCallback(); } } }); // 触摸事件（移动端） element.addEventListener('touchstart', (e) => { isDragging = true; hasMoved = false; const touch = e.touches[0]; startX = touch.clientX; startY = touch.clientY; startLeft = parseInt(window.getComputedStyle(element).left, 10); startTop = parseInt(window.getComputedStyle(element).top, 10); element.classList.add('dragging'); e.preventDefault(); }); element.addEventListener('touchmove', (e) => { if (!$1) return; const touch = e.touches[0]; const deltaX = touch.clientX - startX; const deltaY = touch.clientY - startY; // 如果有任何移动，立即认为是拖动（延迟为0） if (Math.abs(deltaX)> 0 || Math.abs(deltaY)> 0) { hasMoved = true; } const newLeft = startLeft + deltaX; const newTop = startTop + deltaY; // 限制在屏幕范围内 const maxLeft = window.innerWidth - element.offsetWidth; const maxTop = window.innerHeight - element.offsetHeight; element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px'; element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px'; e.preventDefault(); }); element.addEventListener('touchend', () => { if (isDragging) { isDragging = false; element.classList.remove('dragging'); // 如果没有移动，执行点击回调 if (!$1) { clickCallback(); } } }); }, // --- 新增：窗口大小调整功能 (实时调整) --- toggleWindowSizePanel() { const panel = document.getElementById('window-size-panel'); if (panel) { const isVisible = panel.style.display === 'block'; panel.style.display = isVisible ? 'none' : 'block'; if (!$1) { this.loadCurrentWindowSize(); } } }, hideWindowSizePanel() { const panel = document.getElementById('window-size-panel'); if (panel) { panel.style.display = 'none'; } }, loadCurrentWindowSize() { const container = document.querySelector(\\'$1\\'); const gameContainer = document.querySelector(\\'$1\\'); if (container && gameContainer) { const currentWidth = parseInt(container.style.maxWidth) || 900; const currentHeight = parseInt(gameContainer.style.height) || 600; const widthSlider = document.getElementById('width-slider'); const heightSlider = document.getElementById('height-slider'); const widthDisplay = document.getElementById('width-display'); const heightDisplay = document.getElementById('height-display'); if (widthSlider) widthSlider.value = currentWidth; if (heightSlider) heightSlider.value = currentHeight; if (widthDisplay) widthDisplay.textContent = `${currentWidth}px`; if (heightDisplay) heightDisplay.textContent = `${currentHeight}px`; } }, updateWidthDisplay(value) { const widthDisplay = document.getElementById('width-display'); if (widthDisplay) { widthDisplay.textContent = `${value}px`; } this.applyWindowSize(value, null); }, updateHeightDisplay(value) { const heightDisplay = document.getElementById('height-display'); if (heightDisplay) { heightDisplay.textContent = `${value}px`; } this.applyWindowSize(null, value); }, applyWindowSize(newWidth, newHeight) { const container = document.querySelector(\\'$1\\'); const gameContainer = document.querySelector(\\'$1\\'); if (container && gameContainer) { if ($1 === $2) { container.style.maxWidth = `${newWidth}px`; } if ($1 === $2) { gameContainer.style.height = `${newHeight}px`; } } // 实时保存，可能会有性能问题，但按指示忽略lodash this.saveWindowSizeState(); }, resetWindowSize() { const defaultWidth = 900; const defaultHeight = 600; const widthSlider = document.getElementById('width-slider'); const heightSlider = document.getElementById('height-slider'); if (widthSlider) widthSlider.value = defaultWidth; if (heightSlider) heightSlider.value = defaultHeight; this.updateWidthDisplay(defaultWidth); this.updateHeightDisplay(defaultHeight); this.showTemporaryMessage('已重置为默认大小'); }, saveWindowSizeState() { try { const container = document.querySelector(\\'$1\\'); const gameContainer = document.querySelector(\\'$1\\'); if (container && gameContainer) { // 从实际的DOM样式中获取当前尺寸 const currentWidth = parseInt(container.style.maxWidth) || 900; const currentHeight = parseInt(gameContainer.style.height) || 600; const sizeState = { width: currentWidth, height: currentHeight }; localStorage.setItem('guixu_window_size', JSON.stringify(sizeState)); console.log(`窗口大小已保存: ${currentWidth}x${currentHeight}`); } } catch (e) { console.error('保存窗口大小状态失败:', e); } }, loadWindowSizeState() { try { const savedState = localStorage.getItem('guixu_window_size'); if (savedState) { const { width, height } = JSON.parse(savedState); if (width && height) { // 直接应用到DOM，避免循环调用saveWindowSizeState const container = document.querySelector(\\'$1\\'); const gameContainer = document.querySelector(\\'$1\\'); if (container && gameContainer) { container.style.maxWidth = `${width}px`; gameContainer.style.height = `${height}px`; // 更新滑块显示值 const widthSlider = document.getElementById('width-slider'); const heightSlider = document.getElementById('height-slider'); const widthDisplay = document.getElementById('width-display'); const heightDisplay = document.getElementById('height-display'); if (widthSlider) widthSlider.value = width; if (heightSlider) heightSlider.value = height; if (widthDisplay) widthDisplay.textContent = `${width}px`; if (heightDisplay) heightDisplay.textContent = `${height}px`; console.log(`窗口大小已从缓存恢复: ${width}x${height}`); } } } } catch (e) { console.error('加载窗口大小状态失败:', e); } }, // --- 新增：状态效果弹出窗口 --- toggleStatusPopup() { const popup = document.getElementById('status-effects-popup'); if (popup) { const isVisible = popup.style.display === 'flex'; popup.style.display = isVisible ? 'none' : 'flex'; } }, SafeGetValue(obj, path, defaultValue = 'N/A') { let keys = Array.isArray(path) ? path : path.split('.'); let current = obj; for (let $1 = 0; $1 <$2; $1+) { if ( current === undefined || current === null || typeof current !== 'object' || !current.hasOwnProperty(keys[i]) ) { return defaultValue; } current = current[keys[i]]; } if ($1 === $2) { return defaultValue; } // 如果是对象（但不是数组），直接返回 if ($1 === $2)) { return current; } if (Array.isArray(current)) { if (current.length> 0) { const actualValue = current[0]; if ($1 === $2) return actualValue; // 如果数组的第一个元素是对象，直接返回该对象 if ($1 === $2) { return actualValue; } return String(actualValue); } else { return defaultValue; } } if ($1 === $2) return current; return String(current); }, async updateDynamicData() { try { // 加载核心mvu数据 const messages = await getChatMessages(getCurrentMessageId()); if (messages && messages.length> 0 && messages[0].data) { // 缓存完整的 mvu 状态，而不仅仅是 stat_data this.currentMvuState = messages[0].data; this.renderUI(this.currentMvuState.stat_data); } else { console.warn('无法从当前消息中加载 mvu data。'); } // 新增：加载并显示当前场景正文 // 此函数现在处理自己的文本格式化。 await this.loadAndDisplayCurrentScene(); } catch (error) { console.error('更新归墟动态数据时出错:', error); } }, // 新增：统一的UI渲染函数 renderUI(data) { if (!$1) { console.warn('RenderUI 调用失败：没有提供数据。'); return; } const updateGameText = (id, value, style = '') => { const el = document.getElementById(id); if (el) { el.innerText = value; if (style) { el.setAttribute('style', style); } } }; // 变量结构更新：直接读取'当前境界' const jingjieValue = this.SafeGetValue(data, '当前境界', '...'); const match = jingjieValue.match(/^(\\S{2})/); const jingjieTier = match ? match[1] : ''; const jingjieStyle = this.getTierStyle(jingjieTier); updateText('val-jingjie', jingjieValue, jingjieStyle); updateText('val-jinian', this.SafeGetValue(data, '当前时间纪年')); const charge = this.SafeGetValue(data, '归墟充能时间', '0'); updateText('val-guixu-charge-text', `${charge}%`); const chargeBar = document.getElementById('bar-guixu-charge'); if (chargeBar) chargeBar.style.setProperty('--guixu-charge', `${charge}%`); // 此处不再需要填充 this.baseAttributes，因为 updateDisplayedAttributes 会直接从 stat_data 读取 this.updateTalentAndLinggen(data); this.loadEquipmentFromMVU(data); this.updateDisplayedAttributes(); // 核心渲染函数 // --- 变量适配：重构状态效果渲染逻辑 --- const summaryTextEl = document.getElementById('status-summary-text'); const popupListEl = document.getElementById('status-effects-popup-list'); if (summaryTextEl && popupListEl) { // 新结构：'当前状态' 是一个对象，键是状态名，值是描述 const statuses = this.SafeGetValue(data, '当前状态', {}); // 过滤掉元数据 const getStatusEntries = Object.entries(statuses).filter(([key]) => key !== '$meta'); if (statusEntries.length> 0) { summaryTextEl.textContent = `当前有 ${statusEntries.length} 个状态效果`; popupListEl.innerHTML = statusEntries.map(([name, description]) => { return ` <div class=\"$1\"><strong>${name}:</strong> ${description} </div> `; }).join(''); } else { summaryTextEl.textContent = '当前无状态效果'; popupListEl.innerHTML = '<div class=\"$1\">暂无</div>'; } } }, // --- Event Listeners for Buttons and Modals --- bindStaticListeners() { if (this.listenersBound) return; // 如果已经绑定过，则直接返回 // 新增：为视图切换按钮绑定监听器 document.getElementById('view-toggle-btn')?.addEventListener('click', () => this.toggleViewMode()); document.getElementById('fullscreen-btn')?.addEventListener('click', () => this.toggleFullScreen()); document.getElementById('exit-fullscreen-btn')?.addEventListener('click', () => this.exitFullScreen()); // 新增：为变量改变提醒绑定监听器 document.getElementById('variable-changes-header')?.addEventListener('click', () => this.toggleVariableChanges()); // 新增：为面板折叠按钮绑定监听器 document.getElementById('left-panel-toggle')?.addEventListener('click', () => this.toggleLeftPanel()); document.getElementById('right-panel-toggle')?.addEventListener('click', () => this.toggleRightPanel()); document.addEventListener('fullscreenchange', () => { const fullscreenBtn = document.getElementById('fullscreen-btn'); const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn'); if (document.fullscreenElement) { fullscreenBtn.style.display = 'none'; exitFullscreenBtn.style.display = 'flex'; } else { fullscreenBtn.style.display = 'flex'; exitFullscreenBtn.style.display = 'none'; } }); // 浮动按钮事件监听器和拖动功能 this.initDraggableButtons(); // 新增：为窗口大小调整按钮和控制面板绑定事件监听器 document.getElementById('window-size-btn')?.addEventListener('click', () => this.toggleWindowSizePanel()); document.getElementById('window-size-close')?.addEventListener('click', () => this.hideWindowSizePanel()); document.getElementById('width-slider')?.addEventListener('input', (e) => this.updateWidthDisplay(e.target.value)); document.getElementById('height-slider')?.addEventListener('input', (e) => this.updateHeightDisplay(e.target.value)); document.getElementById('reset-size-btn')?.addEventListener('click', () => this.resetWindowSize()); // --- 新增：为状态效果弹出窗口绑定事件 --- document.getElementById('status-summary-button')?.addEventListener('click', () => this.toggleStatusPopup()); document.getElementById('status-effects-popup-close')?.addEventListener('click', () => this.toggleStatusPopup()); // 新增：为世界书序号输入框绑定监听 // 新增：为统一的序号输入框绑定监听 document.getElementById('unified-index-input')?.addEventListener('change', (e) => { const newIndex = parseInt(e.target.value, 10); if (!$1) && newIndex> 0) { this.unifiedIndex = newIndex; this.saveUnifiedIndex(); this.showTemporaryMessage(`世界书读写序号已更新为 ${newIndex}`); // 如果自动开关是开启的，立即更新启用的条目 if (this.isAutoToggleLorebookEnabled) { this.startAutoTogglePolling(); } } else { e.target.value = this.unifiedIndex; // 如果输入无效，则恢复 } }); // 新增：为小说模式的序号输入框绑定监听 document.getElementById('novel-mode-index-input')?.addEventListener('change', (e) => { const newIndex = parseInt(e.target.value, 10); if (!$1) && newIndex> 0) { this.novelModeIndex = newIndex; this.saveNovelModeIndex(); // 立即刷新模态框内容 if ($1 === $2) { this.showNovelMode(); } } else { e.target.value = this.novelModeIndex; // 如果输入无效，则恢复 } }); // 新增：为自动开关世界书复选框绑定监听 document.getElementById('auto-toggle-lorebook-checkbox')?.addEventListener('change', (e) => { this.isAutoToggleLorebookEnabled = e.target.checked; this.saveAutoToggleState(); this.showTemporaryMessage(`自动开关世界书已${this.isAutoToggleLorebookEnabled ? '开启' : '关闭'}`); if (this.isAutoToggleLorebookEnabled) { this.startAutoTogglePolling(); } else { this.stopAutoTogglePolling(); } }); document.getElementById('btn-inventory')?.addEventListener('click', () => this.showInventory()); document.getElementById('btn-relationships')?.addEventListener('click', () => this.showRelationships()); document.getElementById('btn-guixu-system')?.addEventListener('click', () => this.showGuixuSystem()); document.getElementById('btn-toggle-thinking')?.addEventListener('click', () => this.toggleThinkingDisplay()); document.getElementById('btn-settings')?.addEventListener('click', () => this.showSettings()); // 设置模态框内的按钮事件 document.getElementById('btn-command-center-from-settings')?.addEventListener('click', () => { this.isFromSettingsModal = true; // 设置标志位 this.showCommandCenter(); }); document.getElementById('btn-show-extracted-from-settings')?.addEventListener('click', () => { this.isFromSettingsModal = true; // 设置标志位 this.showExtractedContent(); }); document.getElementById('btn-map-from-settings')?.addEventListener('click', () => { this.isFromSettingsModal = true; // 设置标志位 this.showMap(); }); document.getElementById('background-settings-btn')?.addEventListener('click', () => { this.isFromSettingsModal = true; // 设置标志位 this.showBackgroundSettings(); }); document.getElementById('background-settings-btn')?.addEventListener('click', () => { this.isFromSettingsModal = true; // 设置标志位 this.showBackgroundSettings(); }); // 文字设置相关事件监听器 document.getElementById('text-color-normal')?.addEventListener('change', (e) => { this.textSettings.colors.normal = e.target.value; this.applyTextSettings(); this.saveTextSettings(); }); document.getElementById('text-color-dialogue')?.addEventListener('change', (e) => { this.textSettings.colors.dialogue = e.target.value; this.applyTextSettings(); this.saveTextSettings(); }); document.getElementById('text-color-psychology')?.addEventListener('change', (e) => { this.textSettings.colors.psychology = e.target.value; this.applyTextSettings(); this.saveTextSettings(); }); document.getElementById('text-color-scenery')?.addEventListener('change', (e) => { this.textSettings.colors.scenery = e.target.value; this.applyTextSettings(); this.saveTextSettings(); }); document.getElementById('font-size-slider')?.addEventListener('input', (e) => { this.textSettings.fontSize = parseInt(e.target.value); document.getElementById('font-size-value').textContent = e.target.value + 'px'; this.applyTextSettings(); this.saveTextSettings(); }); document.getElementById('font-family-select')?.addEventListener('change', (e) => { if ($1 === $2) { // 触发文件选择 document.getElementById('font-file-input').click(); // 重置选择框到之前的值 setTimeout(() => { e.target.value = this.textSettings.fontFamily; }, 100); } else { // 应用选择的字体 this.textSettings.fontFamily = e.target.value; // 确保自定义字体样式已加载 this.ensureCustomFontLoaded(e.target.value).then(() => { this.applyTextSettings(); this.saveTextSettings(); }); // 检查是否为自定义字体 const checkCustomFont = this.textSettings.customFonts.some(font => font.family === e.target.value); const fontName = isCustomFont ? this.textSettings.customFonts.find(font => font.family === e.target.value).name : e.target.options[e.target.selectedIndex].text; this.showTemporaryMessage(`已应用字体: ${fontName}`); } }); document.getElementById('font-file-input')?.addEventListener('change', (e) => { this.handleFontUpload(e); }); document.getElementById('reset-text-settings-btn')?.addEventListener('click', () => { this.resetTextSettings(); }); document.getElementById('preview-text-settings-btn')?.addEventListener('click', () => { this.previewTextSettings(); }); document.getElementById('font-compress-help-btn')?.addEventListener('click', () => { this.showFontCompressHelp(); }); // 主界面的世界线回顾按钮 document.getElementById('btn-view-journey-main')?.addEventListener('click', () => this.showJourney()); document.getElementById('btn-view-past-lives-main')?.addEventListener('click', () => this.showPastLives()); document.getElementById('btn-save-load-manager')?.addEventListener('click', () => this.showSaveLoadManager()); document.getElementById('btn-novel-mode')?.addEventListener('click', () => this.showNovelMode()); document.getElementById('btn-clear-all-saves')?.addEventListener('click', () => this.clearAllSaves()); document.getElementById('btn-import-save')?.addEventListener('click', () => document.getElementById('import-file-input')?.click()); document.getElementById('import-file-input')?.addEventListener('change', (e) => this.handleFileImport(e)); // 时间线备份/恢复事件监听器已移除，功能已集成到存档系统中 // 为写入世界书按钮绑定监听器 document .getElementById('btn-write-journey') ?.addEventListener('click', () => this.writeJourneyToLorebook()); document .getElementById('btn-write-past-lives') ?.addEventListener('click', () => this.writePastLivesToLorebook()); document .getElementById('btn-write-novel-mode') ?.addEventListener('click', () => this.writeNovelModeToLorebook()); document .getElementById('btn-write-character-card') ?.addEventListener('click', () => this.writeCharacterCardToLorebook()); // 为自动写入复选框绑定监听器，并增加状态保存 document.getElementById('btn-execute-map-commands')?.addEventListener('click', () => { if (this.lastExtractedMapCommands) { this.handleMapUpdateCommand(this.lastExtractedMapCommands); } else { this.showTemporaryMessage('没有可解析的地图指令。'); } }); const autoWriteCheckbox = document.getElementById('auto-write-checkbox'); if (autoWriteCheckbox) { autoWriteCheckbox.addEventListener('change', e => { this.isAutoWriteEnabled = e.target.checked; this.saveAutoWriteState(this.isAutoWriteEnabled); this.showTemporaryMessage(`自动写入历程/涟漪已${this.isAutoWriteEnabled ? '开启' : '关闭'}`); if (this.isAutoWriteEnabled) { this.startAutoWritePolling(); } else { this.stopAutoWritePolling(); } }); } // 为小说模式复选框绑定监听器 const novelModeCheckbox = document.getElementById('novel-mode-enabled-checkbox'); if (novelModeCheckbox) { novelModeCheckbox.addEventListener('change', e => { this.isNovelModeEnabled = e.target.checked; this.saveNovelModeState(this.isNovelModeEnabled); this.showTemporaryMessage(`小说模式自动写入已${this.isNovelModeEnabled ? '开启' : '关闭'}`); // 新逻辑：此开关只控制轮询，不触发UI刷新 if (this.isNovelModeEnabled) { this.startNovelModeAutoWritePolling(); } else { this.stopNovelModeAutoWritePolling(); } // 手动更新标签文本以提供即时反馈 const label = document.querySelector(\\'$1\\'); if (label) { label.textContent = `开启小说模式`; // 恢复原始文本 } // 刷新打开的模态框以更新按钮状态和提示 if ($1 === $2) { this.showExtractedContent(); } }); } // 指令中心按钮 document .getElementById('btn-execute-commands') ?.addEventListener('click', () => this.executePendingActions()); document.getElementById('btn-clear-commands')?.addEventListener('click', () => this.clearPendingActions()); document.getElementById('btn-refresh-storage')?.addEventListener('click', () => this.refreshLocalStorage()); document.getElementById('action-options-enabled-checkbox')?.addEventListener('change', (e) => { this.isActionOptionsEnabled = e.target.checked; this.saveActionOptionsState(); this.showTemporaryMessage(`行动选项显示已${this.isActionOptionsEnabled ? '开启' : '关闭'}`); // 重新渲染行动选项以立即反映变化 this.renderActionOptions(this._extractLastTagContent('行动选项', this.lastExtractedVariables || '')); }); document.getElementById('auto-send-action-checkbox')?.addEventListener('change', (e) => { this.isActionAutoSend = e.target.checked; this.saveActionAutoSendState(); this.showTemporaryMessage(`行动选项点击即发送已${this.isActionAutoSend ? '开启' : '关闭'}`); }); document.getElementById('streaming-enabled-checkbox')?.addEventListener('change', (e) => { this.isStreamingEnabled = e.target.checked; this.saveStreamingState(); this.showTemporaryMessage(`流式响应已${this.isStreamingEnabled ? '开启' : '关闭'}`); }); document.getElementById('format-validation-enabled-checkbox')?.addEventListener('change', (e) => { this.isFormatValidationEnabled = e.target.checked; this.saveFormatValidationState(); this.showTemporaryMessage(`格式审查已${this.isFormatValidationEnabled ? '开启' : '关闭'}`); }); // 新增：为回车发送复选框绑定事件 document.getElementById('enter-send-checkbox')?.addEventListener('change', (e) => { this.isEnterSendEnabled = e.target.checked; this.saveEnterSendState(); this.showTemporaryMessage(`回车发送已${this.isEnterSendEnabled ? '开启' : '关闭'}`); }); // 新增：为快速发送输入框绑定回车键事件 document.getElementById('quick-send-input')?.addEventListener('keydown', (e) => { if ($1 === $2) { e.preventDefault(); // 阻止默认的换行行为 this.executeQuickSend(); } }); document .querySelectorAll('.modal-close-btn') .forEach(btn => btn.addEventListener('click', (e) => this.handleModalClose(e))); // 新增：为输入缓存模态框的内容列表添加事件委托 document.getElementById('input-cache-modal')?.addEventListener('click', e => { if (e.target && e.target.closest('.input-cache-item')) { const item = e.target.closest('.input-cache-item'); const content = item.dataset.content; if (content) { this.applyInputFromHistory(content); } } }); document.querySelectorAll(\\'$1\\').forEach(overlay => { overlay.addEventListener('click', e => { if ($1 === $2) this.handleModalClose(e); }); }); // 事件委托：背包内的点击事件 const inventoryModalBody = document.querySelector(\\'$1\\'); if (inventoryModalBody) { inventoryModalBody.addEventListener('click', e => { if (e.target.classList.contains('item-equip-btn')) { const itemElement = e.target.closest('.inventory-item'); const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, \"'\") || '{}'); const category = itemElement.dataset.category; // 新增：处理功法装备按钮 if ($1 === $2) { this.equipItem(itemData, category, e.target, 'zhuxiuGongfa'); } else if ($1 === $2) { this.equipItem(itemData, category, e.target, 'fuxiuXinfa'); } else { this.equipItem(itemData, category, e.target); } } else if (e.target.classList.contains('item-use-btn')) { const itemElement = e.target.closest('.inventory-item'); const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, \"'\") || '{}'); this.useItem(itemData, e.target); } else if (e.target.classList.contains('item-unequip-btn')) { const slotId = e.target.dataset.slotId; const slotElement = document.getElementById(slotId); if (slotElement) { this.unequipItem(slotId, slotElement, true, true); // 从背包卸载，需要刷新背包UI } } else if (e.target.classList.contains('item-discard-btn')) { const itemElement = e.target.closest('.inventory-item'); const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, \"'\") || '{}'); const category = itemElement.dataset.category; this.discardItem(itemData, category, itemElement); } }); } // 事件委托：左侧装备面板的事件 const characterPanel = document.querySelector(\\'$1\\'); if (characterPanel) { // 悬浮显示Tooltip characterPanel.addEventListener('mouseover', e => { const slot = e.target.closest('.equipment-slot'); if (slot && slot.classList.contains('equipped')) { this.showEquipmentTooltip(slot, e); } }); characterPanel.addEventListener('mouseout', e => { const slot = e.target.closest('.equipment-slot'); if (slot) { this.hideEquipmentTooltip(); } }); // 点击卸载装备 characterPanel.addEventListener('click', e => { const slot = e.target.closest('.equipment-slot'); if (slot && slot.classList.contains('equipped')) { this.unequipItem(slot.id, slot, true, false); // 从主面板卸载，不需要弹出背包 } }); } // 为快速发送按钮绑定事件 document.getElementById('btn-quick-send')?.addEventListener('click', () => this.executeQuickSend()); // --- 新增：为输入缓存绑定事件 --- document.getElementById('btn-show-cache')?.addEventListener('click', () => this.showInputCacheModal()); // 新增：为行动选项容器绑定事件委托 document.getElementById('action-options-container')?.addEventListener('click', (e) => { if (e.target && e.target.classList.contains('action-option-btn')) { const actionText = e.target.dataset.actionText; if (actionText) { if (this.isActionAutoSend) { // 开启时，直接点击发送 this.handleAction(actionText); } else { // 关闭时，加入指令中心 this.pendingActions.push({ action: 'do_action', text: actionText, }); this.savePendingActions(); this.showTemporaryMessage(`已将行动 [${actionText}] 加入指令中心`); } } } }); // 新增：为自动存档复选框绑定监听 document.getElementById('auto-save-checkbox')?.addEventListener('change', (e) => { this.isAutoSaveEnabled = e.target.checked; this.saveAutoSaveState(); this.showTemporaryMessage(`自动存档已${this.isAutoSaveEnabled ? '开启' : '关闭'}`); }); // 新增：为自动化系统修剪模态框的按钮绑定事件 document.getElementById('btn-confirm-trim')?.addEventListener('click', () => { const indexInput = document.getElementById('trim-journey-index-input'); const index = indexInput ? parseInt(indexInput.value, 10) : this.unifiedIndex; if (!$1) && index> 0) { this.trimJourneyAutomation(index); } else { this.showTemporaryMessage('请输入有效的序号。'); } }); document.getElementById('btn-cancel-trim')?.addEventListener('click', () => { this.closeModal('trim-journey-modal'); }); // 新增：人物关系排序和亲密关系事件委托 document.addEventListener('change', (e) => { if ($1 === $2) { this.handleRelationshipSort(e.target.value); } }); document.addEventListener('click', (e) => { // 处理标签页点击 if (e.target && e.target.closest('.tab-btn')) { const tabBtn = e.target.closest('.tab-btn'); const tabType = tabBtn.dataset.tab; if (tabType) { this.handleTabClick(tabType); } } // 处理亲密关系切换按钮（保留兼容性） if ($1 === $2) { this.toggleIntimateMode(); } // 处理人物卡片三连击 if (e.target && e.target.closest('.relationship-card')) { const card = e.target.closest('.relationship-card'); const characterName = card.dataset.characterName; if (characterName) { this.handleTripleClick(characterName, e); } } }); this.listenersBound = true; // 设置标志位，确保此代码块只运行一次 // 新增：为存档/读档模态框添加统一的事件委托 const saveLoadModalBody = document.querySelector(\\'$1\\'); if (saveLoadModalBody) { saveLoadModalBody.addEventListener('click', (e) => { const target = e.target; const slotDiv = target.closest('.save-slot'); if (!$1) return; const slotId = slotDiv.dataset.slotId; if (!$1) return; if (target.classList.contains('btn-save-slot')) { this.saveGame(slotId); } else if (target.classList.contains('btn-load-slot')) { this.loadGame(slotId); } else if (target.classList.contains('btn-delete-slot')) { this.deleteSave(slotId); } else if (target.classList.contains('btn-export-slot')) { this.exportSave(slotId); } }); } // 绑定背景图设置模态框中的静态事件 this.bindBackgroundSettingsListeners(); }, // --- Modal Control --- showSettings() { this.openModal('settings-modal'); // 初始化透明度滑块 this.initOpacitySlider(); // 初始化文字设置UI this.updateTextSettingsUI(); this.updateCustomFontsList(); // 确保当前字体样式立即生效 this.applyTextSettings(); }, // 新增：初始化透明度滑块 initOpacitySlider() { const slider = document.getElementById('opacity-slider'); const valueDisplay = document.getElementById('opacity-value'); if (slider && valueDisplay) { // 设置当前值 slider.value = this.mainOpacity; valueDisplay.textContent = `当前设置: ${this.mainOpacity}%`; // 绑定事件监听器 slider.addEventListener('input', (e) => { this.updateOpacity(parseInt(e.target.value)); }); } }, // 新增：更新透明度 updateOpacity(value) { this.mainOpacity = value; const valueDisplay = document.getElementById('opacity-value'); if (valueDisplay) { valueDisplay.textContent = `当前设置: ${value}%`; } // 应用透明度到主界面 this.applyOpacityToMainInterface(value); // 保存设置 this.saveOpacitySettings(); }, // 新增：应用透明度到主界面 applyOpacityToMainInterface(opacity) { // 将透明度值转换为0-1的范围 const opacityValue = opacity / 100; // 通过动态创建CSS规则来控制伪元素的透明度 let styleElement = document.getElementById('dynamic-overlay-style'); if (!$1) { styleElement = document.createElement('style'); styleElement.id = 'dynamic-overlay-style'; document.head.appendChild(styleElement); } // 创建CSS规则来控制伪元素的透明度 styleElement.textContent = ` .guixu-root::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(26, 26, 46, ${opacityValue}) !important; pointer-events: none; z-index: -1; } `; console.log(`[归墟透明度] 设置覆盖层透明度为: ${opacityValue}`); }, // 新增：保存透明度设置 saveOpacitySettings() { try { localStorage.setItem('guixu_main_opacity', this.mainOpacity.toString()); } catch (e) { console.error('保存透明度设置失败:', e); } }, // 新增：加载透明度设置 loadOpacitySettings() { try { const saved = localStorage.getItem('guixu_main_opacity'); if (saved) { this.mainOpacity = parseInt(saved); this.applyOpacityToMainInterface(this.mainOpacity); } } catch (e) { console.error('加载透明度设置失败:', e); this.mainOpacity = 100; // 默认值 } }, // --- 新增：文字设置相关函数 --- // 应用文字设置到页面 async applyTextSettings() { try { // 确保自定义字体的CSS样式存在 await this.ensureCustomFontsLoaded(); // 更新CSS变量或直接修改样式 const style = document.createElement('style'); style.id = 'guixu-text-settings-style'; // 移除旧的样式 const oldStyle = document.getElementById('guixu-text-settings-style'); if (oldStyle) { oldStyle.remove(); } style.textContent = ` .game-text-container { color: ${this.textSettings.colors.normal} !important; font-size: ${this.textSettings.fontSize}px !important; font-family: ${this.textSettings.fontFamily} !important; } .text-language { color: ${this.textSettings.colors.dialogue} !important; font-style: italic; } .text-psychology { color: ${this.textSettings.colors.psychology} !important; font-style: italic; } .text-scenery { color: ${this.textSettings.colors.scenery} !important; } `; document.head.appendChild(style); // 强制刷新页面上的文字显示 this.refreshTextDisplay(); console.log('[归墟文字设置] 已应用文字设置，当前字体:', this.textSettings.fontFamily); } catch (e) { console.error('应用文字设置失败:', e); } }, // 确保自定义字体已加载 async ensureCustomFontsLoaded() { try { const getLoadPromises = this.textSettings.customFonts.map(async (font) => { const existingStyle = document.getElementById(`font-style-${font.hash}`); if (!$1) { try { // 如果字体样式不存在，尝试从缓存重新加载 const cachedFont = await this.loadFontFromIndexedDB(font.cacheKey); const style = document.createElement('style'); style.id = `font-style-${font.hash}`; style.textContent = ` @font-face { font-family: ${font.family}; src: url(${cachedFont.data}); font-display: swap; } `; document.head.appendChild(style); console.log('[归墟文字设置] 重新加载字体样式:', font.name); return true; } catch (error) { console.warn('[归墟文字设置] 无法重新加载字体:', font.name, error); return false; } } return true; }); await Promise.all(loadPromises); console.log('[归墟文字设置] 所有自定义字体检查完成'); } catch (e) { console.error('确保自定义字体加载失败:', e); } }, // 强制刷新文字显示 refreshTextDisplay() { try { // 找到所有文字容器并强制重新渲染 const textContainers = document.querySelectorAll(\\'$1\\'); textContainers.forEach(container => { // 触发重新渲染 const display = container.style.display; container.style.display = 'none'; container.offsetHeight; // 强制重排 container.style.display = display; }); // 刷新所有文字样式元素 const textElements = document.querySelectorAll(\\'$1\\'); textElements.forEach(element => { // 强制重新应用样式 const className = element.className; element.className = ''; element.offsetHeight; // 强制重排 element.className = className; }); console.log('[归墟文字设置] 已刷新文字显示'); } catch (e) { console.error('刷新文字显示失败:', e); } }, // 保存文字设置 saveTextSettings() { try { localStorage.setItem('guixu_text_settings', JSON.stringify(this.textSettings)); console.log('[归墟文字设置] 已保存文字设置'); } catch (e) { console.error('保存文字设置失败:', e); } }, // 加载文字设置 loadTextSettings() { try { const saved = localStorage.getItem('guixu_text_settings'); if (saved) { const settings = JSON.parse(saved); this.textSettings = { ...this.textSettings, ...settings }; // 加载并应用自定义字体（从IndexedDB缓存） if (this.textSettings.customFonts && this.textSettings.customFonts.length> 0) { // 使用Promise.all确保所有字体都加载完成 const getFontLoadPromises = this.textSettings.customFonts.map(async (font) => { try { if (font.cacheKey) { // 新版本：从IndexedDB加载 const cachedFont = await this.loadFontFromIndexedDB(font.cacheKey); // 移除可能存在的旧样式 const oldStyle = document.getElementById(`font-style-${font.hash}`); if (oldStyle) { oldStyle.remove(); } const style = document.createElement('style'); style.id = `font-style-${font.hash}`; style.textContent = ` @font-face { font-family: ${font.family}; src: url(${cachedFont.data}); font-display: swap; } `; document.head.appendChild(style); console.log(`[归墟文字设置] 已从缓存加载字体: ${font.name}`); return true; } else if (font.data) { // 旧版本兼容：直接使用保存的数据 const style = document.createElement('style'); style.id = `font-style-${font.hash || 'legacy'}`; style.textContent = ` @font-face { font-family: ${font.family}; src: url(${font.data}); font-display: swap; } `; document.head.appendChild(style); console.log(`[归墟文字设置] 已加载字体（兼容模式）: ${font.name}`); return true; } } catch (error) { console.warn(`[归墟文字设置] 无法加载字体 ${font.name}:`, error); return false; } }); // 等待所有字体加载完成后再应用设置 Promise.all(fontLoadPromises).then((results) => { // 移除加载失败的字体 this.textSettings.customFonts = this.textSettings.customFonts.filter((font, index) => results[index]); // 应用文字设置 this.updateTextSettingsUI(); this.applyTextSettings(); console.log('[归墟文字设置] 所有字体加载完成，已应用设置'); }); } else { // 没有自定义字体，直接应用设置 this.updateTextSettingsUI(); this.applyTextSettings(); } } else { // 没有保存的设置，使用默认设置 this.updateTextSettingsUI(); this.applyTextSettings(); } console.log('[归墟文字设置] 已加载文字设置'); } catch (e) { console.error('加载文字设置失败:', e); // 出错时也要应用默认设置 this.updateTextSettingsUI(); this.applyTextSettings(); } }, // 更新文字设置UI updateTextSettingsUI() { try { const normalInput = document.getElementById('text-color-normal'); const dialogueInput = document.getElementById('text-color-dialogue'); const psychologyInput = document.getElementById('text-color-psychology'); const sceneryInput = document.getElementById('text-color-scenery'); const fontSizeSlider = document.getElementById('font-size-slider'); const fontSizeValue = document.getElementById('font-size-value'); const fontFamilySelect = document.getElementById('font-family-select'); if (normalInput) normalInput.value = this.textSettings.colors.normal; if (dialogueInput) dialogueInput.value = this.textSettings.colors.dialogue; if (psychologyInput) psychologyInput.value = this.textSettings.colors.psychology; if (sceneryInput) sceneryInput.value = this.textSettings.colors.scenery; if (fontSizeSlider) fontSizeSlider.value = this.textSettings.fontSize; if (fontSizeValue) fontSizeValue.textContent = this.textSettings.fontSize + 'px'; if (fontFamilySelect) { // 更新字体选择下拉框，包含自定义字体 this.updateFontFamilyOptions(); fontFamilySelect.value = this.textSettings.fontFamily; } } catch (e) { console.error('更新文字设置UI失败:', e); } }, // 更新字体选择下拉框选项 updateFontFamilyOptions() { const fontFamilySelect = document.getElementById('font-family-select'); if (!$1) return; // 保存当前选择的值 const currentValue = fontFamilySelect.value; // 清空现有选项 fontFamilySelect.innerHTML = ''; // 添加预设字体选项 const presetFonts = [ { value: \"'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif\", text: \"默认字体\" }, { value: \"'Microsoft YaHei', sans-serif\", text: \"微软雅黑\" }, { value: \"'SimSun', serif\", text: \"宋体\" }, { value: \"'KaiTi', serif\", text: \"楷体\" }, { value: \"'FangSong', serif\", text: \"仿宋\" }, { value: \"'Arial', sans-serif\", text: \"Arial\" }, { value: \"'Times New Roman', serif\", text: \"Times New Roman\" } ]; presetFonts.forEach(font => { const option = document.createElement('option'); option.value = font.value; option.textContent = font.text; fontFamilySelect.appendChild(option); }); // 添加分隔线（如果有自定义字体） if (this.textSettings.customFonts.length> 0) { const separator = document.createElement('option'); separator.disabled = true; separator.textContent = '--- 自定义字体 ---'; fontFamilySelect.appendChild(separator); // 添加自定义字体选项 this.textSettings.customFonts.forEach(font => { const option = document.createElement('option'); option.value = font.family; option.textContent = font.name; fontFamilySelect.appendChild(option); }); } // 添加上传新字体选项 const uploadOption = document.createElement('option'); uploadOption.value = 'upload_new'; uploadOption.textContent = '+ 上传新字体'; fontFamilySelect.appendChild(uploadOption); // 恢复之前的选择 if ($1 === $2) { fontFamilySelect.value = currentValue; } }, // 重置文字设置 resetTextSettings() { this.textSettings = { colors: { normal: '#e8dcc6', dialogue: '#ff1493', psychology: '#ffffff', scenery: '#98fb98' }, fontSize: 14, fontFamily: \"'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif\", customFonts: [] }; this.updateTextSettingsUI(); this.applyTextSettings(); this.saveTextSettings(); this.showTemporaryMessage('文字设置已重置为默认值'); }, // 预览文字设置效果 previewTextSettings() { const previewText = ` <div style=\"\"><div style=\"\">文字效果预览：</div><div class=\"$1\">这是对话文字的效果预览</div><div class=\"$1\">这是心理活动文字的效果预览</div><div class=\"$1\">这是景物描写文字的效果预览</div></div> `; // 创建预览模态框 const modal = document.createElement('div'); modal.className = 'modal-overlay'; modal.style.display = 'flex'; modal.style.zIndex = '2002'; modal.innerHTML = ` <div class=\"$1\" style=\"\"><div class=\"$1\"><h2 class=\"$1\">文字效果预览</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"> ${previewText} <div style=\"\"><button class=\"$1\" onclick=\"this.closest('.modal-overlay').remove()\">关闭预览</button></div></div></div> `; document.body.appendChild(modal); // 绑定关闭事件 modal.querySelector('.modal-close-btn').addEventListener('click', () => { modal.remove(); }); modal.addEventListener('click', (e) => { if ($1 === $2) modal.remove(); }); }, // 显示字体压缩帮助 showFontCompressHelp() { const helpContent = ` <div style=\"\"><h3 style=\"\">字体文件压缩指南</h3><div style=\"\"><h4 style=\"\">推荐在线工具：</h4><ul style=\"\"><li><strong>FontSquirrel Webfont Generator</strong><br> 网址：fontsquirrel.com/tools/webfont-generator<br> 支持TTF转WOFF2，压缩率高</li><li><strong>CloudConvert</strong><br> 网址：cloudconvert.com<br> 支持多种字体格式转换</li><li><strong>Convertio</strong><br> 网址：convertio.co<br> 简单易用的在线转换工具</li></ul></div><div style=\"\"><h4 style=\"\">压缩建议：</h4><ul style=\"\"><li>优先选择WOFF2格式（压缩率最高）</li><li>移除不需要的字符集（如只保留中文+英文）</li><li>降低字体精度（适当减少曲线点数）</li><li>移除字体提示信息和元数据</li></ul></div><div style=\"\"><div style=\"\"><strong>提示：</strong>如果字体仍然过大，建议选择系统预设字体或寻找更轻量的替代字体。 </div></div></div> `; // 创建帮助模态框 const modal = document.createElement('div'); modal.className = 'modal-overlay'; modal.style.display = 'flex'; modal.style.zIndex = '2002'; modal.innerHTML = ` <div class=\"$1\" style=\"\"><div class=\"$1\"><h2 class=\"$1\">字体压缩帮助</h2><button class=\"$1\">&times;</button></div><div class=\"$1\"> ${helpContent} <div style=\"\"><button class=\"$1\" onclick=\"this.closest('.modal-overlay').remove()\">关闭</button></div></div></div> `; document.body.appendChild(modal); // 绑定关闭事件 modal.querySelector('.modal-close-btn').addEventListener('click', () => { modal.remove(); }); modal.addEventListener('click', (e) => { if ($1 === $2) modal.remove(); }); }, // 处理字体文件上传 handleFontUpload(event) { const file = event.target.files[0]; if (!$1) return; // 重置文件输入框，允许重新选择相同文件 event.target.value = ''; const allowedTypes = ['font/ttf', 'font/otf', 'font/woff', 'font/woff2', 'application/font-woff', 'application/font-woff2']; const fileExtension = file.name.split('.').pop().toLowerCase(); const allowedExtensions = ['ttf', 'otf', 'woff', 'woff2']; if (!$1)) { this.showTemporaryMessage('请选择有效的字体文件 (.ttf, .otf, .woff, .woff2)'); return; } // 检查文件大小（限制为10MB，但给出警告） if (file.size> 10 * 1024 * 1024) { this.showTemporaryMessage('字体文件过大，请选择小于10MB的文件'); return; } // 对于大于2MB的文件给出警告 if (file.size> 2 * 1024 * 1024) { const sizeMB = (file.size / (1024 * 1024)).toFixed(1); const shouldContinue = confirm(`字体文件较大 (${sizeMB}MB)，可能影响加载速度和存储空间。是否继续上传？`); if (!$1) { this.showTemporaryMessage('上传已取消'); return; } this.showTemporaryMessage(`正在上传大字体文件 (${sizeMB}MB)，请稍候...`); } // 显示上传开始提示 this.showTemporaryMessage(`正在处理字体文件: ${file.name}`); const reader = new FileReader(); reader.onload = (e) => { try { const fontData = e.target.result; const fontName = file.name.replace(/\\.[^/.]+$/, \"\"); // 移除扩展名 const fontFamily = `'${fontName}'`; // 检查是否已存在同名字体 const findExistingFont = this.textSettings.customFonts.find(f => f.name === fontName); if (existingFont) { const shouldReplace = confirm(`字体 \"${fontName}\" 已存在，是否替换？`); if (!$1) { this.showTemporaryMessage('上传已取消'); return; } // 移除旧字体 const index = this.textSettings.customFonts.indexOf(existingFont); this.removeCustomFont(index); } // 生成字体文件的哈希值作为缓存键 const fontHash = this.generateFontHash(fontName, file.size, file.lastModified); const cacheKey = `guixu_font_${fontHash}`; // 使用IndexedDB存储字体文件 this.storeFontInIndexedDB(cacheKey, fontData, fontName, fontFamily) .then(() => { // 创建字体样式 const style = document.createElement('style'); style.id = `font-style-${fontHash}`; style.textContent = ` @font-face { font-family: ${fontFamily}; src: url(${fontData}); font-display: swap; } `; document.head.appendChild(style); // 添加到自定义字体列表（只保存元数据，不保存文件数据） const customFont = { name: fontName, family: fontFamily, hash: fontHash, cacheKey: cacheKey, size: file.size, lastModified: file.lastModified }; this.textSettings.customFonts.push(customFont); this.updateCustomFontsList(); // 更新字体选择下拉框 this.updateFontFamilyOptions(); // 自动应用新上传的字体 this.textSettings.fontFamily = fontFamily; const fontFamilySelect = document.getElementById('font-family-select'); if (fontFamilySelect) { fontFamilySelect.value = fontFamily; } this.applyTextSettings(); this.saveTextSettings(); const sizeMB = (file.size / (1024 * 1024)).toFixed(1); this.showTemporaryMessage(`字体 \"${fontName}\" (${sizeMB}MB) 上传成功并已应用`); }) .catch(error => { console.error('字体缓存失败:', error); this.showTemporaryMessage(`字体缓存失败: ${error.message}`); // 即使缓存失败，也创建临时样式 const style = document.createElement('style'); style.textContent = ` @font-face { font-family: ${fontFamily}; src: url(${fontData}); font-display: swap; } `; document.head.appendChild(style); // 添加临时字体到列表（不保存到localStorage） const tempFont = { name: fontName + ' (临时)', family: fontFamily, hash: fontHash, size: file.size, temporary: true }; this.textSettings.customFonts.push(tempFont); this.updateCustomFontsList(); }); } catch (error) { console.error('字体处理失败:', error); this.showTemporaryMessage(`字体处理失败: ${error.message}`); } }; reader.onerror = (error) => { console.error('文件读取失败:', error); this.showTemporaryMessage('文件读取失败，请重试'); }; reader.readAsDataURL(file); }, // 生成字体文件哈希值 generateFontHash(name, size, lastModified) { const str = `${name}_${size}_${lastModified}`; let hash = 0; for (let $1 = 0; $1 <$2; $1+) { const char = str.charCodeAt(i); hash = ((hash <<5) - hash) + char; hash = hash & hash; // 转换为32位整数 } return Math.abs(hash).toString(36); }, // 使用IndexedDB存储字体文件 storeFontInIndexedDB(cacheKey, fontData, fontName, fontFamily) { return new Promise((resolve, reject) => { const request = indexedDB.open('GuixuFontCache', 1); request.onerror = () => { console.error('IndexedDB打开失败:', request.error); reject(request.error); }; request.onupgradeneeded = (event) => { console.log('IndexedDB升级中...'); const db = event.target.result; // 删除旧的对象存储（如果存在） if (db.objectStoreNames.contains('fonts')) { db.deleteObjectStore('fonts'); } // 创建新的对象存储 const store = db.createObjectStore('fonts', { keyPath: 'cacheKey' }); store.createIndex('name', 'name', { unique: false }); store.createIndex('timestamp', 'timestamp', { unique: false }); console.log('IndexedDB对象存储创建完成'); }; request.onsuccess = (event) => { const db = event.target.result; try { // 检查对象存储是否存在，如果不存在则创建 if (!$1)) { console.warn('fonts对象存储不存在，尝试重新初始化数据库'); db.close(); // 重新打开数据库并强制升级 const upgradeRequest = indexedDB.open('GuixuFontCache', db.version + 1); upgradeRequest.onupgradeneeded = (upgradeEvent) => { const upgradeDb = upgradeEvent.target.result; if (!$1)) { const store = upgradeDb.createObjectStore('fonts', { keyPath: 'cacheKey' }); store.createIndex('name', 'name', { unique: false }); store.createIndex('timestamp', 'timestamp', { unique: false }); console.log('fonts对象存储创建成功'); } }; upgradeRequest.onsuccess = () => { const newDb = upgradeRequest.result; const transaction = newDb.transaction(['fonts'], 'readwrite'); const store = transaction.objectStore('fonts'); const fontRecord = { cacheKey: cacheKey, name: fontName, family: fontFamily, data: fontData, timestamp: Date.now() }; const addRequest = store.put(fontRecord); addRequest.onsuccess = () => { console.log('字体缓存成功:', fontName); newDb.close(); resolve(); }; addRequest.onerror = () => { console.error('字体缓存失败:', addRequest.error); newDb.close(); reject(addRequest.error); }; }; upgradeRequest.onerror = () => { console.error('数据库升级失败:', upgradeRequest.error); reject(upgradeRequest.error); }; return; } const transaction = db.transaction(['fonts'], 'readwrite'); const store = transaction.objectStore('fonts'); const fontRecord = { cacheKey: cacheKey, name: fontName, family: fontFamily, data: fontData, timestamp: Date.now() }; const addRequest = store.put(fontRecord); addRequest.onsuccess = () => { console.log('字体缓存成功:', fontName); resolve(); }; addRequest.onerror = () => { console.error('字体缓存失败:', addRequest.error); reject(addRequest.error); }; transaction.onerror = () => { console.error('事务失败:', transaction.error); reject(transaction.error); }; } catch (error) { console.error('IndexedDB操作异常:', error); reject(error); } }; }); }, // 从IndexedDB加载字体文件 loadFontFromIndexedDB(cacheKey) { return new Promise((resolve, reject) => { const request = indexedDB.open('GuixuFontCache', 1); request.onerror = () => { console.error('IndexedDB打开失败:', request.error); reject(request.error); }; request.onupgradeneeded = (event) => { // 如果数据库不存在，创建它 const db = event.target.result; if (!$1)) { const store = db.createObjectStore('fonts', { keyPath: 'cacheKey' }); store.createIndex('name', 'name', { unique: false }); store.createIndex('timestamp', 'timestamp', { unique: false }); } }; request.onsuccess = (event) => { const db = event.target.result; try { // 检查对象存储是否存在 if (!$1)) { console.warn('fonts对象存储不存在，字体缓存为空'); db.close(); reject(new Error('fonts对象存储不存在')); return; } const transaction = db.transaction(['fonts'], 'readonly'); const store = transaction.objectStore('fonts'); const getRequest = store.get(cacheKey); getRequest.onsuccess = () => { if (getRequest.result) { console.log('字体缓存加载成功:', getRequest.result.name); resolve(getRequest.result); } else { console.warn('字体缓存未找到:', cacheKey); reject(new Error('Font not found in cache')); } }; getRequest.onerror = () => { console.error('字体缓存读取失败:', getRequest.error); reject(getRequest.error); }; transaction.onerror = () => { console.error('读取事务失败:', transaction.error); reject(transaction.error); }; } catch (error) { console.error('IndexedDB读取异常:', error); reject(error); } }; }); }, // 更新自定义字体列表显示 updateCustomFontsList() { const container = document.getElementById('uploaded-fonts-list'); if (!$1) return; if ($1 === $2) { container.innerHTML = '<div style=\"\">暂无上传的字体</div>'; return; } let html = ''; this.textSettings.customFonts.forEach((font, index) => { html += ` <div style=\"\"><span style=\"\">${font.name}</span><div><button class=\"$1\" style=\"\" data-$1=\"$2\">使用</button><button class=\"$1\" style=\"\" data-$1=\"$2\">删除</button></div></div> `; }); container.innerHTML = html; // 绑定事件委托 container.addEventListener('click', (e) => { const index = parseInt(e.target.dataset.fontIndex); if (isNaN(index)) return; if (e.target.classList.contains('font-use-btn')) { this.useCustomFont(index); } else if (e.target.classList.contains('font-remove-btn')) { this.removeCustomFont(index); } }); }, // 确保自定义字体已加载 async ensureCustomFontLoaded(fontFamily) { // 检查是否是自定义字体 const customFont = this.textSettings.customFonts.find(font => font.family === fontFamily); if (!$1) { return; // 不是自定义字体，直接返回 } // 检查字体样式是否已存在 const existingStyle = document.getElementById(`font-style-${customFont.hash}`); if (existingStyle) { return; // 字体样式已存在，直接返回 } // 字体样式不存在，需要重新加载 if (customFont.cacheKey) { try { const cachedFont = await this.loadFontFromIndexedDB(customFont.cacheKey); const style = document.createElement('style'); style.id = `font-style-${customFont.hash}`; style.textContent = ` @font-face { font-family: '${cachedFont.name}'; src: url(data:font/truetype;base64,${cachedFont.data}) format('truetype'); } `; document.head.appendChild(style); console.log('自定义字体重新加载成功:', cachedFont.name); } catch (error) { console.error('自定义字体加载失败:', error); } } }, // 使用自定义字体 useCustomFont(index) { if (index>= 0 && index <this.textSettings.customFonts.length) { const font = this.textSettings.customFonts[index]; this.textSettings.fontFamily = font.family; // 更新字体选择下拉框为对应的自定义字体 const fontFamilySelect = document.getElementById('font-family-select'); if (fontFamilySelect) { fontFamilySelect.value = font.family; } if (customFontSection) { customFontSection.style.display = 'block'; } // 确保字体已加载后再应用 this.ensureCustomFontLoaded(font.family).then(() => { this.applyTextSettings(); this.saveTextSettings(); }); this.showTemporaryMessage(`已应用字体 \"${font.name}\"`); console.log('[归墟文字设置] 已应用自定义字体:', font.name, font.family); } }, // 删除自定义字体 removeCustomFont(index) { if (index>= 0 && index <this.textSettings.customFonts.length) { const font = this.textSettings.customFonts[index]; this.showCustomConfirm(`确定要删除字体 \"${font.name}\" 吗？`, async () => { try { // 从IndexedDB中删除缓存的字体文件 if (font.cacheKey) { await this.removeFontFromIndexedDB(font.cacheKey); } // 移除页面中的字体样式 if (font.hash) { const styleElement = document.getElementById(`font-style-${font.hash}`); if (styleElement) { styleElement.remove(); } } // 检查当前是否正在使用被删除的字体 const isCurrentFont = this.textSettings.fontFamily === font.family; // 从设置中移除 this.textSettings.customFonts.splice(index, 1); this.updateCustomFontsList(); // 更新字体选择下拉框 this.updateFontFamilyOptions(); // 如果删除的是当前使用的字体，切换到默认字体 if (isCurrentFont) { this.textSettings.fontFamily = \"'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif\"; const fontFamilySelect = document.getElementById('font-family-select'); if (fontFamilySelect) { fontFamilySelect.value = this.textSettings.fontFamily; } this.applyTextSettings(); } this.saveTextSettings(); this.showTemporaryMessage(`字体 \"${font.name}\" 已删除`); } catch (error) { console.error('删除字体缓存失败:', error); // 即使缓存删除失败，也要从设置中移除 this.textSettings.customFonts.splice(index, 1); this.updateCustomFontsList(); this.updateFontFamilyOptions(); this.saveTextSettings(); this.showTemporaryMessage(`字体 \"${font.name}\" 已删除（缓存清理可能失败）`); } }); } }, // 从IndexedDB中删除字体文件 removeFontFromIndexedDB(cacheKey) { return new Promise((resolve, reject) => { const request = indexedDB.open('GuixuFontCache', 1); request.onerror = () => { console.error('IndexedDB打开失败:', request.error); reject(request.error); }; request.onupgradeneeded = (event) => { // 如果数据库不存在，创建它 const db = event.target.result; if (!$1)) { const store = db.createObjectStore('fonts', { keyPath: 'cacheKey' }); store.createIndex('name', 'name', { unique: false }); store.createIndex('timestamp', 'timestamp', { unique: false }); } }; request.onsuccess = (event) => { const db = event.target.result; try { // 检查对象存储是否存在 if (!$1)) { console.warn('fonts对象存储不存在，无需删除'); resolve(); // 不存在就当作删除成功 return; } const transaction = db.transaction(['fonts'], 'readwrite'); const store = transaction.objectStore('fonts'); const deleteRequest = store.delete(cacheKey); deleteRequest.onsuccess = () => { console.log('字体缓存删除成功:', cacheKey); resolve(); }; deleteRequest.onerror = () => { console.error('字体缓存删除失败:', deleteRequest.error); reject(deleteRequest.error); }; transaction.onerror = () => { console.error('删除事务失败:', transaction.error); reject(transaction.error); }; } catch (error) { console.error('IndexedDB删除异常:', error); reject(error); } }; }); }, // 清理过期的字体缓存（可选功能） cleanupExpiredFontCache() { const request = indexedDB.open('GuixuFontCache', 1); request.onsuccess = (event) => { const db = event.target.result; const transaction = db.transaction(['fonts'], 'readwrite'); const store = transaction.objectStore('fonts'); const now = Date.now(); const expireTime = 30 * 24 * 60 * 60 * 1000; // 30天过期 store.openCursor().onsuccess = (event) => { const cursor = event.target.result; if (cursor) { const record = cursor.value; if (now - record.timestamp> expireTime) { cursor.delete(); console.log(`[归墟文字设置] 清理过期字体缓存: ${record.name}`); } cursor.continue(); } }; }; }, async showGuixuSystem() { this.openModal('guixu-system-modal'); const body = document.querySelector(\\'$1\\'); if (!$1) return; body.innerHTML = '<p class=\"$1\" style=\"\">正在连接归墟...</p>'; try { const messages = await getChatMessages(getCurrentMessageId()); const stat_data = messages?.[0]?.data?.stat_data; if (!$1) { body.innerHTML = '<p class=\"$1\" style=\"\">无法连接归墟。</p>'; return; } const currentLife = this.SafeGetValue(stat_data, '当前第x世', '1'); const guixuSpace = this.SafeGetValue(stat_data, '归墟空间', '空无一物'); const currentChoice = this.SafeGetValue(stat_data, '本世归墟选择', '无'); const chargeTime = this.SafeGetValue(stat_data, '归墟充能时间', '0'); const shengli = this.SafeGetValue(stat_data, '生理年龄', 'N/A'); const shengliMax = this.SafeGetValue(stat_data, '生理年龄上限', 'N/A'); const xinli = this.SafeGetValue(stat_data, '心理年龄', 'N/A'); const xinliMax = this.SafeGetValue(stat_data, '心理年龄上限', 'N/A'); body.innerHTML = ` <div class=\"$1\"><div class=\"$1\"><div class=\"$1\"><span class=\"$1\">当前世数</span><span class=\"$1\">第 ${currentLife} 世</span></div><div class=\"$1\"><span class=\"$1\">生理年龄</span><span class=\"$1\">${shengli} / ${shengliMax}</span></div><div class=\"$1\"><span class=\"$1\">心理年龄</span><span class=\"$1\">${xinli} / ${xinliMax}</span></div><div class=\"$1\"><span class=\"$1\">归墟空间</span><span class=\"$1\">${guixuSpace}</span></div><div class=\"$1\"><span class=\"$1\">本世抉择</span><span class=\"$1\">${currentChoice}</span></div><div class=\"$1\" style=\"\"><span class=\"$1\">归墟充能</span><span class=\"$1\">${chargeTime}%</span></div><div class=\"$1\"></div></div></div><div style=\"\"><button id=\"btn-trigger-guixu\" class=\"$1\" style=\"\">归 墟</button></div> `; // 为动态添加的按钮绑定事件 document.getElementById('btn-trigger-guixu').addEventListener('click', () => { if (chargeTime>= 100) { this.showCustomConfirm('你确定要开启下一次轮回吗？所有未储存的记忆都将消散。', async () => { try { const command = '{{user}}选择归墟，世界将回到最初的锚点'; await this.handleAction(command); // 改为调用 handleAction this.showTemporaryMessage('轮回已开启...'); this.closeAllModals(); } catch (error) { console.error('执行归墟指令时出错:', error); this.showTemporaryMessage('执行归墟指令失败！'); } }); } else { this.showTemporaryMessage('归墟充能进度不足'); } }); } catch (error) { console.error('加载归墟系统时出错:', error); body.innerHTML = '<p class=\"$1\" style=\"\">加载数据时出错。</p>'; } }, openModal(modalId, keepOpen = false) { if (!$1) { this.closeAllModals(); } const modal = document.getElementById(modalId); if (modal) { // --- 新增修复逻辑 --- const rootContainer = document.querySelector(\\'$1\\'); // 检查模态框是否不在根容器内 if ($1 === $2) { // 如果是，则将其移动到根容器的末尾，以确保它在全屏时可见 rootContainer.appendChild(modal); console.log(`[归墟修复] 已将模态框 #${modalId} 移动到主容器内以兼容全屏模式。`); } // --- 修复逻辑结束 --- modal.style.display = 'flex'; if (keepOpen) { // Find the highest z-index among visible modals and set the new one higher const highestZ = Array.from(document.querySelectorAll(\\'$1\\')) .filter(el => el.style.display === 'flex' && el.id !== modalId) .reduce((maxZ, el) => Math.max(maxZ, parseInt(window.getComputedStyle(el).zIndex, 10) || 1000), 1000); modal.style.zIndex = highestZ + 1; } else { modal.style.zIndex = ''; // Reset to default CSS z-index } } }, closeModal(modalId) { const modal = document.getElementById(modalId); if (modal) { modal.style.display = 'none'; modal.style.zIndex = ''; // Reset z-index } }, // 新增：处理模态框关闭的统一方法 handleModalClose(event) { const modalOverlay = event.target.closest('.modal-overlay'); if (!$1) { this.closeAllModals(); return; } const modalId = modalOverlay.id; // 特殊处理格式验证模态框关闭 if ($1 === $2) { // 关闭等待消息 this.hideWaitingMessage(); // 填充原始内容而不是清空 const gameTextDisplay = document.getElementById('game-text-display'); if (gameTextDisplay && this.lastValidGametxtHTML) { gameTextDisplay.innerHTML = this.lastValidGametxtHTML; } this.closeModal(modalId); this.showTemporaryMessage('已取消格式验证，内容已恢复。'); return; } // 检查是否是从设置界面进入的子窗口 if (this.isFromSettingsModal && (modalId === 'command-center-modal' || modalId === 'extracted-content-modal' || modalId === 'map-modal' || modalId === 'background-settings-modal')) { // 关闭当前子窗口并返回设置界面 this.closeModal(modalId); this.isFromSettingsModal = false; // 重置状态 this.showSettings(); } else { // 正常关闭所有模态框 this.closeAllModals(); } }, closeAllModals() { document.querySelectorAll(\\'$1\\').forEach(modal => { modal.style.display = 'none'; }); // 新增：关闭地图时重置其状态 this.resetMapState(); // 注释掉：不在这里重置设置状态标志，让handleModalClose来处理 // this.isFromSettingsModal = false; }, showCustomConfirm(message, onConfirm, onCancel = null, keepCurrentModal = false) { const modal = document.getElementById('custom-confirm-modal'); const messageEl = document.getElementById('custom-confirm-message'); const okBtn = document.getElementById('custom-confirm-btn-ok'); const cancelBtn = document.getElementById('custom-confirm-btn-cancel'); if (!$1) return; messageEl.textContent = message; // 使用 .cloneNode(true) 来移除旧的事件监听器 const newOkBtn = okBtn.cloneNode(true); okBtn.parentNode.replaceChild(newOkBtn, okBtn); const newCancelBtn = cancelBtn.cloneNode(true); cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn); const closeAction = () => { if (keepCurrentModal) { this.closeModal('custom-confirm-modal'); } else { this.closeAllModals(); } }; newOkBtn.addEventListener('click', () => { closeAction(); if ($1 === $2) { onConfirm(); } }); newCancelBtn.addEventListener('click', () => { closeAction(); if ($1 === $2) { onCancel(); } }); this.openModal('custom-confirm-modal', keepCurrentModal); }, // --- Feature Implementations (now simplified) --- async showMap() { // 优化：只在首次打开时读取数据，之后只显示/隐藏 const modal = document.getElementById('map-modal'); const body = document.querySelector(\\'$1\\'); if (!$1) return; // 如果地图内容尚未加载，则执行一次性加载 if (!$1) { body.innerHTML = '<p class=\"$1\" style=\"\">正在加载地图数据...</p>'; this.openModal('map-modal'); try { const bookName = '1归墟'; const mapEntryKey = '地图'; const allEntries = await TavernHelper.getLorebookEntries(bookName); const mapEntry = allEntries.find(entry => entry.comment === mapEntryKey); if (!$1) { body.innerHTML = '<p class=\"$1\" style=\"\">在世界书“1归墟”中未找到“地图”条目或内容为空。</p>'; return; } const locations = this.parseMapData(mapEntry.content); console.log('[归墟地图] 解析出的地点数据:', locations); const stat_data = this.currentMvuState?.stat_data; const playerPos = stat_data ? this.SafeGetValue(stat_data, '当前位置', null) : null; // 渲染地图内容 this.renderMap(body, locations, playerPos); // 为地图容器绑定一次性事件 this.bindMapEvents(body); // 标记为已加载 body.dataset.loaded = 'true'; } catch (error) { console.error('加载地图数据时出错:', error); body.innerHTML = `<p class=\"$1\" style=\"\">加载地图失败: ${error.message}</p>`; } } else { // 如果已加载，直接打开模态框 this.openModal('map-modal'); } }, parseMapData(content) { if ($1 === $2) return []; const locations = []; const lines = content.trim().split('\\n'); lines.forEach(line => { if (!$1) || !line.endsWith(']')) return; // 跳过格式不正确的行 const parts = line.substring(1, line.length - 1).split('|'); if (parts.length <3) return; // 至少需要 名称, x, y const locationData = { name: parts[0].trim() }; let hasX = false; let hasY = false; // 从索引1开始遍历，因为索引0是名称 for (let i = 1; i <parts.length; i+) { const part = parts[i].trim(); const separatorIndex = part.indexOf(':'); // 强制要求所有字段都必须是 key:value 格式 if ($1 === $2) { console.warn(`[归墟地图] 无效的键值对格式，已跳过部分: \"${part}\" in line: \"${line}\"`); continue; // 跳过这个格式错误的部分 } const key = part.substring(0, separatorIndex).trim(); const value = part.substring(separatorIndex + 1).trim(); if (key && value) { locationData[key] = value; if ($1 === $2) hasX = true; if ($1 === $2) hasY = true; } } // 只有当明确包含x和y坐标时，才将地点添加到列表中 if (hasX && hasY) { locations.push(locationData); } else { console.warn(`[归墟地图] 跳过不包含有效x,y坐标的地点:`, line); } }); return locations; }, renderMap(container, locations, playerPos = null) { if (!$1) return; container.innerHTML = ''; // 清空旧内容 const mapContainer = document.createElement('div'); mapContainer.className = 'map-container'; // --- 最终的、完善的JS动态网格 --- const gridContainer = document.createElement('div'); const mapSize = 10000; // 创建一个巨大的虚拟网格尺寸 const gridSize = 15; // 您期望的网格密度 const gridColor = '#cccccc'; // 清晰的淡灰色 // 使用 transform 居中这个巨大的网格 gridContainer.style.cssText = ` position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: ${mapSize}px; height: ${mapSize}px; z-index: 0; pointer-events: none; `; for (let i = 0; i <mapSize; i += gridSize) { // 垂直线 const vLine = document.createElement('div'); vLine.style.cssText = `position: absolute; left: ${i}px; top: 0; width: 1px; height: 100%; background-color: ${gridColor};`; gridContainer.appendChild(vLine); // 水平线 const hLine = document.createElement('div'); hLine.style.cssText = `position: absolute; left: 0; top: ${i}px; width: 100%; height: 1px; background-color: ${gridColor};`; gridContainer.appendChild(hLine); } mapContainer.appendChild(gridContainer); // --- 网格绘制结束 --- const SCALE_FACTOR = 100; // 将世界坐标缩小100倍以适应像素 locations.forEach(loc => { const dot = document.createElement('div'); dot.className = 'map-location-dot'; const width = parseInt(loc.w || loc.width || 10, 10); const height = parseInt(loc.h || loc.height || 10, 10); const area = width * height; // 面积越小，z-index越高。设置一个基础值（如10），然后加上一个与面积成反比的值。 // 100000 是一个调节因子，可以根据实际情况调整。 dot.style.zIndex = 10 + Math.floor(100000 / (area + 1)); const x = parseFloat(loc.x) / SCALE_FACTOR; const y = parseFloat(loc.y) / SCALE_FACTOR; if (isNaN(x) || isNaN(y)) { console.warn('[归墟地图] 地点坐标无效，跳过渲染:', loc.name, loc.x, loc.y); return; // 跳过无效坐标的地点 } // 坐标相对于中心点 (50%, 50%) 进行偏移 dot.style.left = `calc(50% + ${x}px)`; dot.style.top = `calc(50% + ${y}px)`; dot.textContent = loc.name; // 直接将名称作为内容 dot.dataset.state = loc.state || '正常'; dot.dataset.type = loc.type || '中立'; // 确保总有一个type dot.style.width = `${width}px`; dot.style.height = `${height}px`; // 修正字体大小计算逻辑，确保文本完全容纳 const FONT_SCALING_FACTOR = 0.9; // 使用小于1的系数来增加水平边距 const minHeightBasedSize = height * 0.8; // 垂直方向最多占80% const minWidthBasedSize = (width / loc.name.length) * FONT_SCALING_FACTOR; const baseFontSize = Math.max(4, Math.min(minHeightBasedSize, minWidthBasedSize)); dot.style.fontSize = `${baseFontSize}px`; // 根据类型设置不同背景颜色 const typeColors = { '宗门': 'rgba(66, 165, 245, 0.8)', // 蓝色 '险地': 'rgba(239, 83, 80, 0.8)', // 红色 '仙宫': 'rgba(255, 215, 0, 0.8)', // 金色 '中立': 'rgba(189, 189, 189, 0.8)', // 灰色 '城池': 'rgba(161, 136, 127, 0.8)', // 棕色 }; if (loc.type && typeColors[loc.type]) { dot.style.backgroundColor = typeColors[loc.type]; // 修改为设置背景色 } dot.addEventListener('click', (e) => { e.stopPropagation(); // 新增：点击后弹出确认框，确认后将指令加入队列 // 第三个参数 true 让确认框叠加在当前地图上，而不是关闭地图 this.showCustomConfirm(`你确定要前往【${loc.name}】吗？`, () => { this.addTravelAction(loc); }, true); }); mapContainer.appendChild(dot); }); // 在循环之后，添加渲染玩家光标的逻辑 if ($1 === $2) { const cursor = document.createElement('div'); cursor.className = 'player-cursor'; // 统一使用像素定位 const playerX = parseFloat(playerPos.x) / SCALE_FACTOR; const playerY = parseFloat(playerPos.y) / SCALE_FACTOR; if (!$1) && !isNaN(playerY)) { cursor.style.left = `calc(50% + ${playerX}px)`; cursor.style.top = `calc(50% + ${playerY}px)`; cursor.title = `你在这里：${playerPos.area_name || '未知区域'} (x:${playerPos.x}, y:${playerPos.y})`; cursor.style.zIndex = '10'; // 确保在地点之上 mapContainer.appendChild(cursor); // 新增：缓存玩家在地图容器中的像素位置 this.mapState.playerMapPos = { x: playerX, y: playerY }; } else { this.mapState.playerMapPos = null; } } else { this.mapState.playerMapPos = null; } // 根据是否存在玩家位置来启用/禁用按钮 const centerBtn = document.getElementById('btn-center-player'); if(centerBtn) { centerBtn.disabled = !this.mapState.playerMapPos; } container.appendChild(mapContainer); this.updateMapTransform(); this.updateZoomSliderUI(); // 新增：初始化滑块UI }, async showInventory() { this.openModal('inventory-modal'); const body = document.querySelector(\\'$1\\'); if (!$1) return; body.innerHTML = '<p class=\"$1\" style=\"\">正在清点行囊...</p>'; try { const messages = await getChatMessages(getCurrentMessageId()); if ($1 === $2) { body.innerHTML = '<p class=\"$1\" style=\"\">无法获取背包数据。</p>'; console.warn('无法从当前消息中加载 stat_data 用于背包。'); return; } const stat_data = messages[0].data.stat_data; body.innerHTML = this.renderInventory(stat_data || {}); } catch (error) { console.error('加载背包时出错:', error); body.innerHTML = `<p class=\"$1\" style=\"\">加载背包时出错: ${error.message}</p>`; } }, async showRelationships() { this.openModal('relationships-modal'); const body = document.querySelector(\\'$1\\'); if (!$1) return; body.innerHTML = '<p class=\"$1\" style=\"\">正在梳理人脉...</p>'; try { const messages = await getChatMessages(getCurrentMessageId()); if ($1 === $2) { body.innerHTML = '<p class=\"$1\" style=\"\">无法获取人物关系数据。</p>'; return; } const stat_data = messages[0].data.stat_data; this.loadIntimateList(); // 渲染前加载亲密列表 // 变量适配: '人物关系列表' 现在是一个对象 const relationships = this.SafeGetValue(stat_data, '人物关系列表', {}); body.innerHTML = this.renderRelationships(relationships); // Intimate marking functionality removed as requested } catch (error) { console.error('加载人物关系时出错:', error); body.innerHTML = `<p class=\"$1\" style=\"\">加载人物关系时出错: ${error.message}</p>`; } }, renderRelationships(relationships) { // 变量适配: 遍历对象而不是数组 const allRelationshipEntries = Object.entries(relationships).filter(([name, rel]) => { return name && name !== '$meta' && rel && typeof rel === 'object'; }); // 根据显示模式过滤条目 let entriesToShow; if (this.intimateDisplayMode) { // 亲密关系模式：只显示亲密关系 entriesToShow = allRelationshipEntries.filter(([name, rel]) => this.intimateCharacters.has(name)); } else { // 全部关系模式：显示所有关系 entriesToShow = allRelationshipEntries; } const sortedEntries = this.sortRelationshipEntries(entriesToShow); let html = ` <div class=\"$1\"><!-- 标签页导航 --><div class=\"$1\"><button class=\"$1\"active' : ''}\" data-$1=\"$2\"><span class=\"$1\">👥</span><span class=\"$1\">全部关系</span><span class=\"$1\">${allRelationshipEntries.length}</span></button><button class=\"$1\"active' : ''}\" data-$1=\"$2\"><span class=\"$1\">❤️</span><span class=\"$1\">亲密关系</span><span class=\"$1\">${allRelationshipEntries.filter(([name]) => this.intimateCharacters.has(name)).length}</span></button></div><!-- 排序控制 --><div class=\"$1\"><div class=\"$1\"><label>排序方式：</label><select id=\"relationship-sort\"><option value=\"default\">默认</option><option value=\"cultivation-high\">修为高→低</option><option value=\"cultivation-low\">修为低→高</option><option value=\"favorability-high\">好感度高→低</option><option value=\"favorability-low\">好感度低→高</option></select></div></div></div><!-- 内容区域 --><div class=\"$1\"><div class=\"$1\"intimate-mode' : 'all-mode'}\">`; // 如果没有任何数据，显示完整的空状态界面 if ($1 === $2) { html += ` <div class=\"$1\"><div class=\"$1\">👥</div><div class=\"$1\">还没有人物关系记录</div><div class=\"$1\"><p>随着剧情的发展，你遇到的重要人物会在这里显示</p><p>包括他们的修为、好感度、详细信息等</p></div><div class=\"$1\"><div class=\"$1\"><span class=\"$1\">📊</span><span class=\"$1\">修为等级显示</span></div><div class=\"$1\"><span class=\"$1\">💖</span><span class=\"$1\">好感度追踪</span></div><div class=\"$1\"><span class=\"$1\">📝</span><span class=\"$1\">详细信息记录</span></div><div class=\"$1\"><span class=\"$1\">🔄</span><span class=\"$1\">过往交集历史</span></div></div></div>`; } else if ($1 === $2) { // 如果有数据但过滤后没有条目，显示相应的提示 const message = this.intimateDisplayMode ? '暂无亲密关系之人。' : '暂无需要特别留意的人物关系。'; html += `<p class=\"$1\">${message}</p>`; } else { sortedEntries.forEach(([name, rel]) => { const tier = this.SafeGetValue(rel, 'tier', '凡人'); const level = this.SafeGetValue(rel, '等级', ''); const relationship = this.SafeGetValue(rel, 'relationship', '萍水相逢'); const favorability = parseInt(this.SafeGetValue(rel, 'favorability', 0), 10); const eventHistory = this.SafeGetValue(rel, 'event_history', {}); const identity = this.SafeGetValue(rel, '身份背景', '暂无'); const personality = this.SafeGetValue(rel, '性格', '暂无'); const appearance = this.SafeGetValue(rel, '外貌', '暂无'); const call = this.SafeGetValue(rel, '称呼', '暂无'); const attributes = this.SafeGetValue(rel, 'attributes', {}); const tierStyle = this.getTierStyle(tier); const favorabilityPercent = Math.max(0, Math.min(100, (favorability / 200) * 100)); const cultivationDisplay = level ? `${tier} ${level}` : tier; const isIntimate = this.intimateCharacters.has(name); let eventHistoryHtml = ''; const eventEntries = Object.entries(eventHistory).filter(([key, value]) => key !== '$meta'); if (eventEntries.length> 0) { eventHistoryHtml += `<details class=\"$1\"><summary class=\"$1\">过往交集</summary><ul class=\"$1\">`; eventEntries.forEach(([eventKey, eventDesc]) => { // 将键和值合并，并移除可能存在的内部HTML标签以保持纯文本 const fullEventText = `${eventKey}, ${eventDesc}`.replace(/<[^>]*>/g, ''); eventHistoryHtml += `<li>${fullEventText}</li>`; }); eventHistoryHtml += '</ul></details>'; } html += ` <div class=\"$1\" data-$1=\"$2\"><div class=\"$1\"><!-- 右下角亲密关系标识 --><div class=\"$1\"is-intimate' : ''}\" title=\"${isIntimate ? '亲密关系' : '普通关系'}\"> ${isIntimate ? '❤' : ''} </div><!-- 第一行：姓名 + 关系 + 四维属性 --><div class=\"$1\"><div class=\"$1\"><span class=\"$1\" style=\"\">${name}</span><span class=\"$1\">${relationship}</span></div><div class=\"$1\"><span class=\"$1\">法力:${attributes.法力 || '??'}</span><span class=\"$1\">神海:${attributes.神海 || '??'}</span><span class=\"$1\">道心:${attributes.道心 || '??'}</span><span class=\"$1\">空速:${attributes.空速 || '??'}</span><span class=\"$1\">气运:${attributes.气运 || '??'}</span></div></div><!-- 第二行：修为 --><div class=\"$1\"> 修为：<span style=\"\">${cultivationDisplay}</span></div><!-- 第三行：好感度数值 --><div class=\"$1\"> 好感度：${favorability} </div><!-- 第四行：好感度进度条 --><div class=\"$1\"></div><!-- 第五行：详情和过往交集并列区域 --><div class=\"$1\"><div class=\"$1\"><div class=\"$1\"><button class=\"$1\" onclick=\"this.classList.toggle('collapsed'); this.nextElementSibling.classList.toggle('hidden');\"> 详情 </button><div class=\"$1\"><div class=\"$1\"><strong>性格:</strong> ${personality} </div><div class=\"$1\"><strong>外貌:</strong> ${appearance} </div><div class=\"$1\"><strong>称呼:</strong> ${call} </div><div class=\"$1\"><strong>身份:</strong> ${identity} </div></div></div><div class=\"$1\"> ${eventHistoryHtml} </div></div></div></div></div> `; }); } html += '</div></div>'; // 关闭 relationships-grid 和 relationships-content // 设置排序下拉框的值 this.setRelationshipSortValue(); return html; }, renderIntimateRelationships(relationships) { // 变量适配: 遍历对象而不是数组 const relationshipEntries = Object.entries(relationships).filter(([name, rel]) => { return name && name !== '$meta' && rel && typeof rel === 'object' && this.intimateCharacters.has(name); }); if ($1 === $2) { return '<p class=\"$1\" style=\"\">暂无亲密关系之人。</p>'; } let html = '<div class=\"$1\">'; relationshipEntries.forEach(([name, rel]) => { const tier = this.SafeGetValue(rel, 'tier', '凡人'); const level = this.SafeGetValue(rel, '等级', ''); const relationship = this.SafeGetValue(rel, 'relationship', '萍水相逢'); const favorability = parseInt(this.SafeGetValue(rel, 'favorability', 0), 10); const eventHistory = this.SafeGetValue(rel, 'event_history', {}); const identity = this.SafeGetValue(rel, '身份背景', '暂无'); const personality = this.SafeGetValue(rel, '性格', '暂无'); const appearance = this.SafeGetValue(rel, '外貌', '暂无'); const call = this.SafeGetValue(rel, '称呼', '暂无'); const attributes = this.SafeGetValue(rel, 'attributes', {}); const tierStyle = this.getTierStyle(tier); const favorabilityPercent = Math.max(0, Math.min(100, (favorability / 200) * 100)); const cultivationDisplay = level ? `${tier} ${level}` : tier; let eventHistoryHtml = ''; const eventEntries = Object.entries(eventHistory).filter(([key, value]) => key !== '$meta'); if (eventEntries.length> 0) { eventHistoryHtml += `<details class=\"$1\"><summary class=\"$1\">过往交集</summary><ul class=\"$1\">`; eventEntries.forEach(([eventKey, eventDesc]) => { // 将键和值合并，并移除可能存在的内部HTML标签以保持纯文本 const fullEventText = `${eventKey}, ${eventDesc}`.replace(/<[^>]*>/g, ''); eventHistoryHtml += `<li>${fullEventText}</li>`; }); eventHistoryHtml += '</ul></details>'; } const isIntimate = this.intimateCharacters.has(name); html += ` <details class=\"$1\" open><summary class=\"$1\"><span class=\"$1\" style=\"\">${name}</span><div class=\"$1\"><div class=\"$1\"><div class=\"$1\">身份</div><div class=\"$1\">${identity}</div></div><div class=\"$1\"><div class=\"$1\">修为</div><div class=\"$1\" style=\"\">${cultivationDisplay}</div></div><div class=\"$1\"><div class=\"$1\">好感度</div><div class=\"$1\">${favorability}</div><div class=\"$1\"></div></div></div><button class=\"$1\"is-intimate' : ''}\" data-$1=\"$2\" title=\"取消亲密关系\">❤</button></summary><div class=\"$1\"><div class=\"$1\"><div class=\"$1\"><div class=\"$1\">基础信息</div><div class=\"$1\"><p><strong>性格:</strong> ${personality}</p><p><strong>外貌:</strong> ${appearance}</p><p><strong>称呼:</strong> ${call}</p><p><strong>关系:</strong> ${relationship}</p></div></div><div class=\"$1\"><div class=\"$1\">四维属性</div><div class=\"$1\"><div class=\"$1\"><div class=\"$1\">法力</div><div class=\"$1\">${attributes.法力 || '??'}</div></div><div class=\"$1\"><div class=\"$1\">神海</div><div class=\"$1\">${attributes.神海 || '??'}</div></div><div class=\"$1\"><div class=\"$1\">道心</div><div class=\"$1\">${attributes.道心 || '??'}</div></div><div class=\"$1\"><div class=\"$1\">空速</div><div class=\"$1\">${attributes.空速 || '??'}</div></div><div class=\"$1\"><div class=\"$1\">气运</div><div class=\"$1\">${attributes.气运 || '??'}</div></div></div></div></div> ${eventHistoryHtml} </div></details> `; }); html += '</div>'; return html; }, // --- 新增：亲密关系相关函数 --- async showIntimateRelationships() { this.openModal('intimate-relationships-modal'); const body = document.querySelector(\\'$1\\'); if (!$1) return; body.innerHTML = '<p class=\"$1\" style=\"\">正在加载亲密关系...</p>'; try { const messages = await getChatMessages(getCurrentMessageId()); if ($1 === $2) { body.innerHTML = '<p class=\"$1\" style=\"\">无法获取人物关系数据。</p>'; return; } const stat_data = messages[0].data.stat_data; this.loadIntimateList(); // 渲染前加载亲密列表 // 变量适配: '人物关系列表' 现在是一个对象 const relationships = this.SafeGetValue(stat_data, '人物关系列表', {}); body.innerHTML = this.renderIntimateRelationships(relationships); // Add event listener for un-marking body.addEventListener('click', e => { const button = e.target.closest('.btn-unmark-intimate'); if (button) { const characterId = button.dataset.characterId; if (characterId) { this.toggleIntimateStatus(characterId, false); } } }); } catch (error) { console.error('加载亲密关系时出错:', error); body.innerHTML = `<p class=\"$1\" style=\"\">加载亲密关系时出错: ${error.message}</p>`; } }, saveIntimateList() { try { localStorage.setItem('guixu_intimate_characters', JSON.stringify(Array.from(this.intimateCharacters))); } catch (e) { console.error('保存亲密关系列表失败:', e); } }, loadIntimateList() { try { const savedList = localStorage.getItem('guixu_intimate_characters'); if (savedList) { this.intimateCharacters = new Set(JSON.parse(savedList) || []); } else { this.intimateCharacters = new Set(); // 关键：如果没有保存的列表，确保初始化为空Set } } catch (e) { console.error('加载亲密关系列表失败:', e); this.intimateCharacters = new Set(); // 出错时也要确保是Set } }, // 新增：加载人物关系设置 loadRelationshipSettings() { try { // 加载排序设置 const savedSort = localStorage.getItem('guixu_relationship_sort'); this.relationshipSortType = savedSort || 'default'; // 加载显示模式设置 const savedDisplayMode = localStorage.getItem('guixu_intimate_display_mode'); this.intimateDisplayMode = savedDisplayMode === 'true'; console.log('加载的排序设置:', this.relationshipSortType); console.log('加载的显示模式:', this.intimateDisplayMode); } catch (e) { console.error('加载人物关系设置失败:', e); this.relationshipSortType = 'default'; this.intimateDisplayMode = false; } }, // 新增：设置排序下拉框的值（在渲染后调用） setRelationshipSortValue() { setTimeout(() => { const sortSelect = document.getElementById('relationship-sort'); if (sortSelect && this.relationshipSortType) { sortSelect.value = this.relationshipSortType; console.log('设置排序下拉框值为:', this.relationshipSortType); } }, 100); }, toggleIntimateStatus(characterName, markAsIntimate) { const id = String(characterName); if (markAsIntimate) { if (!$1)) { this.intimateCharacters.add(id); this.showTemporaryMessage(`已将 [${id}] 添加到亲密关系`); } } else { if (this.intimateCharacters.has(id)) { this.intimateCharacters.delete(id); this.showTemporaryMessage(`已将 [${id}] 从亲密关系中移除`); } } this.saveIntimateList(); // Refresh the currently open modal to reflect the change immediately if ($1 === $2) { this.showRelationships(); } }, // 新增：排序关系条目的函数 sortRelationshipEntries(entries) { const sortType = this.relationshipSortType || 'default'; if ($1 === $2) { // 按修为排序 - 使用与代码中一致的境界顺序 const tierOrder = ['练气', '筑基', '金丹', '元婴', '化神', '合体', '飞升', '神桥']; return entries.sort(([nameA, relA], [nameB, relB]) => { const tierA = this.SafeGetValue(relA, 'tier', '凡人'); const tierB = this.SafeGetValue(relB, 'tier', '凡人'); const levelA = this.SafeGetValue(relA, '等级', ''); const levelB = this.SafeGetValue(relB, '等级', ''); const tierIndexA = tierOrder.indexOf(tierA); const tierIndexB = tierOrder.indexOf(tierB); let result = 0; if ($1 === $2) { result = tierIndexB - tierIndexA; // 高修为在前 } else if (levelA && levelB) { // 同修为境界时，按等级排序 - 尝试数字比较，失败则用字符串比较 const numA = parseInt(levelA.match(/\\d+/)?.[0] || '0', 10); const numB = parseInt(levelB.match(/\\d+/)?.[0] || '0', 10); if ($1 === $2) { result = numB - numA; // 高等级在前 } else { result = levelB.localeCompare(levelA); } } else if (levelA && !levelB) { result = -1; // 有等级的在前 } else if (!$1) { result = 1; // 有等级的在前 } else { result = nameA.localeCompare(nameB); } // 如果是低→高排序，反转结果 return sortType === 'cultivation-low' ? -result : result; }); } else if ($1 === $2) { // 按好感度排序 return entries.sort(([nameA, relA], [nameB, relB]) => { const favA = parseInt(this.SafeGetValue(relA, 'favorability', 0), 10); const favB = parseInt(this.SafeGetValue(relB, 'favorability', 0), 10); let result = 0; if ($1 === $2) { result = favB - favA; // 高好感度在前 } else { result = nameA.localeCompare(nameB); } // 如果是低→高排序，反转结果 return sortType === 'favorability-low' ? -result : result; }); } // 默认排序：亲密关系在前，然后按名字排序 return entries.sort(([nameA, relA], [nameB, relB]) => { const isIntimateA = this.intimateCharacters.has(nameA); const isIntimateB = this.intimateCharacters.has(nameB); if ($1 === $2) { return isIntimateB - isIntimateA; // 亲密关系在前 } return nameA.localeCompare(nameB); }); }, // 新增：处理排序变更 handleRelationshipSort(sortType) { this.relationshipSortType = sortType; localStorage.setItem('guixu_relationship_sort', sortType); this.showRelationships(); // 重新渲染 }, // 新增：三连击相关变量和函数 clickCount: 0, clickTimer: null, lastClickTarget: null, handleTripleClick(characterName, event) { if (event) { event.preventDefault(); event.stopPropagation(); } console.log(`点击角色: ${characterName}, 当前计数: ${this.clickCount}, 目标: ${this.lastClickTarget}`); // 如果点击的是不同的角色，重置计数 if ($1 === $2) { this.clickCount = 0; this.lastClickTarget = characterName; } this.clickCount+; // 清除之前的计时器 if (this.clickTimer) { clearTimeout(this.clickTimer); } // 如果达到3次点击，触发亲密关系切换 if (this.clickCount>= 3) { console.log(`三连击成功，切换 ${characterName} 的亲密关系状态`); this.toggleIntimateStatus(characterName, !this.intimateCharacters.has(characterName)); this.clickCount = 0; this.lastClickTarget = null; // 添加视觉反馈 const card = event ? event.target.closest('.relationship-card') : null; if (card) { card.classList.add('triple-clicked'); setTimeout(() => { card.classList.remove('triple-clicked'); }, 500); } } else { // 设置1秒后重置计数器 this.clickTimer = setTimeout(() => { console.log(`重置点击计数器`); this.clickCount = 0; this.lastClickTarget = null; }, 1000); } }, // 新增：切换亲密关系显示模式（带动画效果） toggleIntimateMode(targetMode = null) { // 如果指定了目标模式，则切换到该模式 if ($1 === $2) { this.intimateDisplayMode = targetMode === 'intimate'; } else { this.intimateDisplayMode = !this.intimateDisplayMode; } localStorage.setItem('guixu_intimate_display_mode', this.intimateDisplayMode); // 添加切换动画 const grid = document.querySelector(\\'$1\\'); if (grid) { grid.classList.add('switching'); setTimeout(() => { this.showRelationships(); // 重新渲染 // 渲染完成后移除切换状态并添加进入动画 setTimeout(() => { const newGrid = document.querySelector(\\'$1\\'); if (newGrid) { newGrid.classList.remove('switching'); } }, 50); }, 200); } else { this.showRelationships(); // 如果没有找到grid，直接重新渲染 } }, // 新增：处理标签页点击 handleTabClick(tabType) { const targetMode = tabType === 'intimate'; if ($1 === $2) { this.toggleIntimateMode(tabType); } }, getTierStyle(tier) { const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; animation: god-tier-animation 3s linear infinite; font-weight: bold;'; const styles = { 练气: 'color: #FFFFFF;', 筑基: 'color: #66CDAA;', 金丹: 'color: #FFD700;', 元婴: `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle}`, 化神: `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle}`, 合体: `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle}`, 飞升: `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle}`, 神桥: `background: linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc); ${animatedStyle}`, }; const baseStyle = 'font-style: italic;'; return (styles[tier] || 'color: #e0dcd1;') + baseStyle; }, // --- 新增：品阶排序核心函数 --- getTierOrder(tier) { // 品阶等级映射：数值越高，品阶越高 // 支持两种品阶系统： // 1. 物品品阶：神品> 仙品> 天品> 极品> 上品> 中品> 下品> 凡品 // 2. 修仙境界：神桥> 飞升> 合体> 化神> 元婴> 金丹> 筑基> 练气 const tierOrder = { // 物品品阶系统 '凡品': 1, '下品': 2, '中品': 3, '上品': 4, '极品': 5, '天品': 6, '仙品': 7, '神品': 8, // 修仙境界系统 '练气': 1, '筑基': 2, '金丹': 3, '元婴': 4, '化神': 5, '合体': 6, '飞升': 7, '神桥': 8 }; return tierOrder[tier] || 0; // 未知品阶排在最前 }, // --- 新增：通用品阶排序函数 --- sortByTier(items, getTierFn) { if (!$1)) return items; return [...items].sort((a, b) => { const tierA = getTierFn(a); const tierB = getTierFn(b); const orderA = this.getTierOrder(tierA); const orderB = this.getTierOrder(tierB); // 按品阶从高到低排序，支持两种品阶系统： // 物品品阶：神品> 仙品> 天品> 极品> 上品> 中品> 下品> 凡品 // 修仙境界：神桥> 飞升> 合体> 化神> 元婴> 金丹> 筑基> 练气 // 如果品阶相同，则保持原有顺序（稳定排序） if ($1 === $2) { return 0; } return orderB - orderA; }); }, getTierColorStyle(tier) { const tierColors = { 凡品: '#FFFFFF', 下品: '#66CDAA', 中品: '#FFD700', 上品: 'linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6)', 极品: 'linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C)', 天品: 'linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585)', 仙品: 'linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C)', 神品: 'linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc)', }; const animatedTiers = ['上品', '极品', '天品', '仙品', '神品']; const color = tierColors[tier] || '#e0dcd1'; if (animatedTiers.includes(tier)) { return `background: ${color}; background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; animation: god-tier-animation 3s linear infinite; font-weight: bold;`; } return `color: ${color};`; }, updateTalentAndLinggen(data) { const container = document.getElementById('talent-linggen-list'); if (!$1) return; container.innerHTML = ''; let html = ''; // 变量适配: 处理对象形式的灵根列表 const linggenList = this.SafeGetValue(data, '灵根列表', {}); const linggenEntries = Object.entries(linggenList).filter(([name]) => name !== '$meta'); if (linggenEntries.length> 0) { const sortedLinggen = this.sortByTier(linggenEntries, ([, linggen]) => this.SafeGetValue(linggen, '品阶', '凡品') ); sortedLinggen.forEach(([name, linggen]) => { const tier = this.SafeGetValue(linggen, '品阶', '凡品'); const description = this.SafeGetValue(linggen, '描述', '无描述'); const tierStyle = this.getTierColorStyle(tier); const itemDetailsHtml = this.renderItemDetailsForInventory(linggen); html += ` <details class=\"$1\"><summary><span class=\"$1\">灵根</span><span class=\"$1\" style=\"\">【${tier}】 ${name}</span></summary><div class=\"$1\"><p>${description}</p> ${itemDetailsHtml ? `<div class=\"$1\">${itemDetailsHtml}</div>` : ''} </div></details> `; }); } else { html += ` <div class=\"$1\"><span class=\"$1\">灵根</span><span class=\"$1\">未觉醒</span></div> `; } // 变量适配: 处理对象形式的天赋列表 const tianfuList = this.SafeGetValue(data, '天赋列表', {}); const tianfuEntries = Object.entries(tianfuList).filter(([name]) => name !== '$meta'); if (tianfuEntries.length> 0) { const sortedTianfu = this.sortByTier(tianfuEntries, ([, tianfu]) => this.SafeGetValue(tianfu, 'tier', '凡品') ); sortedTianfu.forEach(([name, tianfu]) => { const tier = this.SafeGetValue(tianfu, 'tier', '凡品'); const description = this.SafeGetValue(tianfu, 'description', '无描述'); const tierStyle = this.getTierColorStyle(tier); const itemDetailsHtml = this.renderItemDetailsForInventory(tianfu); html += ` <details class=\"$1\"><summary><span class=\"$1\">天赋</span><span class=\"$1\" style=\"\">【${tier}】 ${name}</span></summary><div class=\"$1\"><p>${description}</p> ${itemDetailsHtml ? `<div class=\"$1\">${itemDetailsHtml}</div>` : ''} </div></details> `; }); } else { html += ` <div class=\"$1\"><span class=\"$1\">天赋</span><span class=\"$1\">未觉醒</span></div> `; } container.innerHTML = html; }, renderInventory(stat_data) { if ($1 === $2) { return '<p class=\"$1\" style=\"\">背包数据为空。</p>'; } const categories = [ { title: '功法', key: '功法列表', equipable: true }, { title: '武器', key: '武器列表', equipable: true }, { title: '防具', key: '防具列表', equipable: true }, { title: '饰品', key: '饰品列表', equipable: true }, { title: '法宝', key: '法宝列表', equipable: true }, { title: '丹药', key: '丹药列表', equipable: false }, { title: '杂物', key: '其他列表', equipable: false }, ]; let html = ''; categories.forEach(cat => { // 变量适配: rawItems 现在是对象 const rawItems = this.SafeGetValue(stat_data, cat.key, {}); html += `<details class=\"$1\" open>`; html += `<summary class=\"$1\">${cat.title}</summary>`; const itemEntries = Object.entries(rawItems).filter(([name]) => name !== '$meta'); if (itemEntries.length> 0) { html += '<div class=\"$1\">'; const sortedItems = this.sortByTier(itemEntries, ([, item]) => this.SafeGetValue(item, 'tier', '凡品') ); sortedItems.forEach(([name, item]) => { try { const itemWithFixName = { ...item, name }; const itemJson = JSON.stringify(itemWithFixName).replace(/'/g, \"'\"); const tier = this.SafeGetValue(item, 'tier', '无'); const hasQuantity = item.hasOwnProperty('quantity'); const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10); const description = this.SafeGetValue( item, 'description', this.SafeGetValue(item, 'effect', '无描述'), ); const pendingUses = this.pendingActions .filter(action => action.action === 'use' && action.itemName === name) .reduce((total, action) => total + action.quantity, 0); const pendingDiscards = this.pendingActions .filter(action => action.action === 'discard' && action.itemName === name) .reduce((total, action) => total + action.quantity, 0); const displayQuantity = quantity - pendingUses - pendingDiscards; if (hasQuantity && displayQuantity <= 0) { return; } if (!$1) { return; } const tierStyle = this.getTierStyle(tier); const tierDisplay = tier !== '无' ? `<span style=\"\">品阶: ${tier}</span>` : ''; const quantityDisplay = hasQuantity ? `<span class=\"$1\">数量: ${displayQuantity}</span>` : ''; const isEquipped = Object.values(this.equippedItems).some(equippedItem => equippedItem && equippedItem.name === name); let actionButton = ''; if ($1 === $2) { const isEquippedAsMain = this.equippedItems.zhuxiuGongfa && this.equippedItems.zhuxiuGongfa.name === name; const isEquippedAsAux = this.equippedItems.fuxiuXinfa && this.equippedItems.fuxiuXinfa.name === name; if (isEquippedAsMain) { actionButton = ` <button class=\"$1\" data-$1=\"$2\" style=\"\">卸下</button><button class=\"$1\" data-$1=\"$2\" style=\"\" disabled>辅修</button> `; } else if (isEquippedAsAux) { actionButton = ` <button class=\"$1\" data-$1=\"$2\" style=\"\" disabled>主修</button><button class=\"$1\" data-$1=\"$2\" style=\"\">卸下</button> `; } else { actionButton = ` <button class=\"$1\" data-$1=\"$2\" style=\"\">主修</button><button class=\"$1\" data-$1=\"$2\" style=\"\">辅修</button> `; } } else if (cat.equipable) { if (isEquipped) { const slotKey = Object.keys(this.equippedItems).find( key => this.equippedItems[key] && this.equippedItems[key].name === name, ); actionButton = `<button class=\"$1\" data-$1=\"$2\">卸下</button>`; } else { actionButton = `<button class=\"$1\">装备</button>`; } } else if ($1 === $2) { if (displayQuantity <= 0) { actionButton = `<button class=\"$1\" disabled>已用完</button>`; } else { actionButton = `<button class=\"$1\">使用</button>`; } } if ($1 === $2) { actionButton += `<button class=\"$1\" style=\"\">丢弃</button>`; } else { actionButton += `<button class=\"$1\" style=\"\">丢弃</button>`; } let itemDetailsHtml = this.renderItemDetailsForInventory(item); html += ` <div class=\"$1\" data-$1=\"$2\" data-$1=\"$2\"><div class=\"$1\" style=\"\">${name}</div><div class=\"$1\"><div class=\"$1\"> ${tierDisplay} ${quantityDisplay} </div><div class=\"$1\"> ${actionButton} </div></div><div class=\"$1\">${description}</div> ${itemDetailsHtml ? `<div class=\"$1\">${itemDetailsHtml}</div>` : ''} </div> `; } catch (e) { console.error('解析背包物品失败:', item, e); html += `<div class=\"$1\"><p class=\"$1\">物品数据格式错误</p></div>`; } }); html += '</div>'; } else { html += '<div class=\"$1\"><p class=\"$1\">空空如也</p></div>'; } html += `</details>`; }); return html; }, // --- Tooltip and Equip Logic (重构后) --- renderTooltipContent(item) { // 根据最新的变量结构解析 const tierStyle = this.getTierStyle(this.SafeGetValue(item, 'tier')); const level = this.SafeGetValue(item, 'level', ''); const tierDisplay = level ? `${this.SafeGetValue(item, 'tier', '凡品')} ${level}` : this.SafeGetValue(item, 'tier', '凡品'); let attributesHtml = ''; const attributes = item.attributes_bonus; // 直接使用新key if ($1 === $2).length> 0) { attributesHtml += `<div class=\"$1\">固定加成</div>`; for (const [key, value] of Object.entries(attributes)) { attributesHtml += `<p><strong>${key}:</strong> ${value> 0 ? '+' : ''}${value}</p>`; } } const percentBonuses = item['百分比加成']; if ($1 === $2).length> 0) { attributesHtml += `<div class=\"$1\" style=\"\">百分比加成</div>`; for (const [key, value] of Object.entries(percentBonuses)) { attributesHtml += `<p><strong>${key}:</strong> +${value}</p>`; } } let effectsHtml = ''; const effects = item.special_effects; // 直接使用新key if (Array.isArray(effects) && effects.length> 0) { effectsHtml += `<div class=\"$1\">特殊词条</div>`; effectsHtml += effects.filter(eff => eff !== '$__META_EXTENSIBLE__$').map(eff => `<p>${eff}</p>`).join(''); } return ` <div class=\"$1\" style=\"\">${this.SafeGetValue(item, 'name')}</div><p><strong>品阶:</strong> ${tierDisplay}</p><p><i>${this.SafeGetValue(item, 'description', '无描述')}</i></p> ${ attributesHtml ? `<div class=\"$1\">${attributesHtml}</div>` : '' } ${effectsHtml ? `<div class=\"$1\">${effectsHtml}</div>` : ''} `; }, showEquipmentTooltip(element, event) { const tooltip = document.getElementById('equipment-tooltip'); const itemDataString = element.dataset.itemDetails; if (!$1) return; try { const item = JSON.parse(itemDataString.replace(/'/g, \"'\")); tooltip.innerHTML = this.renderTooltipContent(item); tooltip.style.display = 'block'; // **关键修复**: 调整Tooltip位置以防止超出视口 const tooltipRect = tooltip.getBoundingClientRect(); const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; let left = event.pageX + 15; let top = event.pageY + 15; // 如果Tooltip超出右边界，则显示在鼠标左侧 if (left + tooltipRect.width> viewportWidth) { left = event.pageX - tooltipRect.width - 15; } // 如果Tooltip超出下边界，则显示在鼠标上侧 if (top + tooltipRect.height> viewportHeight) { top = event.pageY - tooltipRect.height - 15; } tooltip.style.left = `${left}px`; tooltip.style.top = `${top}px`; } catch (e) { console.error('解析装备Tooltip数据失败:', e); } }, hideEquipmentTooltip() { const tooltip = document.getElementById('equipment-tooltip'); if (tooltip) tooltip.style.display = 'none'; }, renderItemDetailsForInventory(item) { let attributesHtml = ''; const attributes = item.attributes_bonus; if ($1 === $2).length> 0) { attributesHtml += '<div class=\"$1\" style=\"\">固定加成</div>'; for (const [key, value] of Object.entries(attributes)) { attributesHtml += `<p><strong>${key}:</strong> ${value> 0 ? '+' : ''}${value}</p>`; } } const percentBonuses = item['百分比加成']; if ($1 === $2).length> 0) { attributesHtml += '<div class=\"$1\" style=\"\">百分比加成</div>'; for (const [key, value] of Object.entries(percentBonuses)) { attributesHtml += `<p><strong>${key}:</strong> +${value}</p>`; } } let effectsHtml = ''; let effects = item.special_effects; // 关键修复：处理 special_effects 可能是字符串（用\\n分隔）或数组两种情况 if ($1 === $2) !== '') { effects = effects.split('\\n').map(e => e.trim()).filter(e => e); } if (Array.isArray(effects) && effects.length> 0) { effectsHtml += `<div class=\"$1\" style=\"\">特殊词条</div>`; effectsHtml += effects.filter(eff => eff !== '$__META_EXTENSIBLE__$').map(eff => `<p>${eff}</p>`).join(''); } return `${attributesHtml}${effectsHtml}`; }, equipItem(item, category, buttonElement, equipType = null) { const itemName = this.SafeGetValue(item, 'name'); if ($1 === $2) { this.showTemporaryMessage('物品无名称，无法装备。'); return; } // Bug修复：检查功法是否已被装备在另一个槽位 if ($1 === $2) { const isEquippedAsMain = this.equippedItems.zhuxiuGongfa && this.equippedItems.zhuxiuGongfa.name === itemName; const isEquippedAsAux = this.equippedItems.fuxiuXinfa && this.equippedItems.fuxiuXinfa.name === itemName; if ($1 === $2) || (equipType === 'zhuxiuGongfa' && isEquippedAsAux) ) { this.showTemporaryMessage('该功法已被装备在另一槽位。'); return; } } const categoryMap = { 武器: 'wuqi', 防具: 'fangju', 饰品: 'shipin', 法宝: 'fabao1', 功法: equipType }; const slotKey = categoryMap[category]; if (!$1) { this.showTemporaryMessage('错误的装备分类或类型。'); return; } // **关键修复**: 检查物品是否已装备在其他槽位，如果是，则先卸载 const currentlyEquippedSlot = Object.keys(this.equippedItems).find( key => this.equippedItems[key] && this.equippedItems[key].name === itemName, ); if ($1 === $2) { const oldSlotElement = document.getElementById(`equip-${currentlyEquippedSlot}`); if (oldSlotElement) { this.unequipItem(`equip-${currentlyEquippedSlot}`, oldSlotElement, false); // 静默卸载 } } const slotElement = document.getElementById(`equip-${slotKey}`); if (!$1) return; // 如果该槽位已有装备，先执行卸载操作 const oldItem = this.equippedItems[slotKey]; if (oldItem) { this.unequipItem(`equip-${slotKey}`, slotElement, false); } // 更新前端状态和UI（乐观更新） this.equippedItems[slotKey] = item; // **逻辑修正**: 存储完整对象 const tier = this.SafeGetValue(item, 'tier', '凡品'); const tierStyle = this.getTierStyle(tier); slotElement.textContent = this.SafeGetValue(item, 'name'); slotElement.setAttribute('style', tierStyle); slotElement.classList.add('equipped'); slotElement.dataset.itemDetails = JSON.stringify(item).replace(/'/g, \"'\"); // 更新背包UI，使其能反映最新状态 if (buttonElement.closest('#inventory-modal')) { this.showInventory(); } // 添加到指令队列（优化：先移除旧指令，再添加新指令） const defaultTextMap = { wuqi: '武器', fangju: '防具', shipin: '饰品', fabao1: '法宝', zhuxiuGongfa: '主修功法', fuxiuXinfa: '辅修心法', }; const slotFriendlyName = defaultTextMap[slotKey] || category; this.pendingActions = this.pendingActions.filter(action => action.itemName !== itemName); this.pendingActions.push({ action: 'equip', itemName: itemName, category: slotFriendlyName, }); this.showTemporaryMessage(`已装备 ${this.SafeGetValue(item, 'name')}`); this.updateDisplayedAttributes(); this.saveEquipmentState(); // 保存状态 this.savePendingActions(); // 保存指令状态 }, unequipItem(slotId, slotElement, showMessage = true, refreshInventoryUI = true) { const slotKey = slotId.replace('equip-', ''); const defaultTextMap = { wuqi: '武器', fangju: '防具', shipin: '饰品', fabao1: '法宝', zhuxiuGongfa: '主修功法', fuxiuXinfa: '辅修心法', }; const itemDataString = slotElement.dataset.itemDetails; if (!$1) return; // 如果没有物品，则不执行任何操作 let itemName = '一件装备'; try { const item = JSON.parse(itemDataString.replace(/'/g, \"'\")); itemName = this.SafeGetValue(item, 'name'); } catch (e) { console.error('卸载时解析物品数据失败', e); } // 清理前端状态和UI this.equippedItems[slotKey] = null; slotElement.textContent = defaultTextMap[slotKey] || '空'; slotElement.classList.remove('equipped'); slotElement.removeAttribute('style'); delete slotElement.dataset.itemDetails; // **关键修复**: 不再进行复杂的局部DOM更新，而是直接重新渲染整个背包以确保UI同步 if (refreshInventoryUI) { this.showInventory(); } // 添加到指令队列（优化：先移除旧指令，再添加新指令） this.pendingActions = this.pendingActions.filter(action => action.itemName !== itemName); this.pendingActions.push({ action: 'unequip', itemName: itemName, category: defaultTextMap[slotKey], }); if (showMessage) { this.showTemporaryMessage(`已卸下 ${itemName}`); } this.updateDisplayedAttributes(); this.saveEquipmentState(); // 保存状态 this.savePendingActions(); // 保存指令状态 // 注意：showInventory() 已经包含了关闭模态框再打开的过程，所以UI会刷新 }, loadEquipmentFromMVU(data) { const equipmentMap = { 武器: 'wuqi', 主修功法: 'zhuxiuGongfa', 辅修心法: 'fuxiuXinfa', 防具: 'fangju', 饰品: 'shipin', 法宝栏1: 'fabao1', }; const defaultTextMap = { wuqi: '武器', fangju: '防具', shipin: '饰品', fabao1: '法宝', zhuxiuGongfa: '主修功法', fuxiuXinfa: '辅修心法', }; for (const [mvuKey, slotKey] of Object.entries(equipmentMap)) { const slot = document.getElementById(`equip-${slotKey}`); if (!$1) continue; // mvu中的装备数据通常是 [ { item_object } ] 的形式 // **局部修复**: 直接使用 _.get 获取装备数组，避免 SafeGetValue 将其错误地转为字符串 const itemArray = _.get(data, mvuKey, null); const item = Array.isArray(itemArray) && itemArray.length> 0 ? itemArray[0] : null; if ($1 === $2) { const tier = this.SafeGetValue(item, 'tier', '凡品'); const tierStyle = this.getTierStyle(tier); // **逻辑修正**: 此处不再主动修改 this.equippedItems // this.equippedItems 的状态由 localStorage 和 equip/unequip 动作管理 // this.equippedItems[slotKey] = item; slot.textContent = this.SafeGetValue(item, 'name'); slot.setAttribute('style', tierStyle); slot.classList.add('equipped'); slot.dataset.itemDetails = JSON.stringify(item).replace(/'/g, \"'\"); } else { // this.equippedItems[slotKey] = null; // **关键修复**: 此函数不应修改核心状态，只渲染从mvu得到的数据 slot.textContent = defaultTextMap[slotKey]; slot.classList.remove('equipped'); slot.removeAttribute('style'); delete slot.dataset.itemDetails; } } }, updateDisplayedAttributes() { // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 // V2 Refactor: Optimistic update based on MVU max values + equipment bonuses only. if (!$1) { console.warn('无法更新属性：mvu状态不可用，使用默认显示。'); // 当数据不可用时，显示默认的\"...\"而不是\"0 / 0\" document.getElementById('attr-fali').innerText = '...'; document.getElementById('attr-shenhai').innerText = '...'; document.getElementById('attr-daoxin').innerText = '...'; document.getElementById('attr-kongsu').innerText = '...'; document.getElementById('attr-qiyun').innerText = '...'; return; } const stat_data = this.currentMvuState.stat_data; // 1. 基础显示：直接使用mvu变量中的上限属性作为基础值 // 修复：使用更合理的默认值，避免显示0/0 const mvuMaxAttrs = { fali: parseInt(this.SafeGetValue(stat_data, '法力', 100), 10) || 100, shenhai: parseInt(this.SafeGetValue(stat_data, '神海', 50), 10) || 50, daoxin: parseInt(this.SafeGetValue(stat_data, '道心', 10), 10) || 10, kongsu: parseInt(this.SafeGetValue(stat_data, '空速', 5), 10) || 5, qiyun: parseInt(this.SafeGetValue(stat_data, '气运', 10), 10) || 10, }; // 2. 前端乐观更新：只计算新装备的武器等物品的加成 const equipmentFlatBonuses = { fali: 0, shenhai: 0, daoxin: 0, kongsu: 0, qiyun: 0 }; const equipmentPercentBonuses = { fali: 0, shenhai: 0, daoxin: 0, kongsu: 0, qiyun: 0 }; const attributeMapping = { 法力: 'fali', 神海: 'shenhai', 道心: 'daoxin', 空速: 'kongsu', 气运: 'qiyun' }; const processEquipmentBonuses = (item) => { if ($1 === $2) return; const flatBonuses = item.attributes_bonus; if ($1 === $2) { for (const [attrName, bonusValue] of Object.entries(flatBonuses)) { const attrKey = attributeMapping[attrName]; if (attrKey) { equipmentFlatBonuses[attrKey] += parseInt(bonusValue, 10) || 0; } } } const percentBonuses = item['百分比加成']; if ($1 === $2) { for (const [attrName, bonusValue] of Object.entries(percentBonuses)) { const attrKey = attributeMapping[attrName]; if (attrKey) { equipmentPercentBonuses[attrKey] += parseFloat(String(bonusValue).replace('%','')) / 100 || 0; } } } }; // 只遍历 this.equippedItems Object.values(this.equippedItems).forEach(processEquipmentBonuses); // 计算最终乐观更新后的上限 const finalMaxAttrs = { fali: Math.floor((mvuMaxAttrs.fali + equipmentFlatBonuses.fali) * (1 + equipmentPercentBonuses.fali)), shenhai: Math.floor((mvuMaxAttrs.shenhai + equipmentFlatBonuses.shenhai) * (1 + equipmentPercentBonuses.shenhai)), daoxin: Math.floor((mvuMaxAttrs.daoxin + equipmentFlatBonuses.daoxin) * (1 + equipmentPercentBonuses.daoxin)), kongsu: Math.floor((mvuMaxAttrs.kongsu + equipmentFlatBonuses.kongsu) * (1 + equipmentPercentBonuses.kongsu)), qiyun: Math.floor((mvuMaxAttrs.qiyun + equipmentFlatBonuses.qiyun) * (1 + equipmentPercentBonuses.qiyun)), }; this.calculatedMaxAttributes = finalMaxAttrs; // 缓存计算结果 // 3. 去除当前值不能超出上限的bug，直接读取变量数据 // 修复：使用与上限属性对应的默认值，确保当前值不会显示为0 const currentAttrs = { fali: parseInt(this.SafeGetValue(stat_data, '当前法力', mvuMaxAttrs.fali), 10) || mvuMaxAttrs.fali, shenhai: parseInt(this.SafeGetValue(stat_data, '当前神海', mvuMaxAttrs.shenhai), 10) || mvuMaxAttrs.shenhai, daoxin: parseInt(this.SafeGetValue(stat_data, '当前道心', mvuMaxAttrs.daoxin), 10) || mvuMaxAttrs.daoxin, kongsu: parseInt(this.SafeGetValue(stat_data, '当前空速', mvuMaxAttrs.kongsu), 10) || mvuMaxAttrs.kongsu, }; // 4. 更新UI - 直接显示数值，允许负值和任何数值 const updateAttr = (elementId, current, max) => { const element = document.getElementById(elementId); if (element) { element.innerText = `${current} / ${max}`; } }; updateAttr('attr-fali', currentAttrs.fali, finalMaxAttrs.fali); updateAttr('attr-shenhai', currentAttrs.shenhai, finalMaxAttrs.shenhai); updateAttr('attr-daoxin', currentAttrs.daoxin, finalMaxAttrs.daoxin); updateAttr('attr-kongsu', currentAttrs.kongsu, finalMaxAttrs.kongsu); // 气运只显示最大值 const qiyunElement = document.getElementById('attr-qiyun'); if (qiyunElement) { qiyunElement.innerText = finalMaxAttrs.qiyun; } // 年龄相关属性已从主界面移除，仅在归墟系统中显示 // 修为进度相关属性更新 const xiuxingjindu = this.SafeGetValue(stat_data, '修为进度', '0'); const xiuxingpingjing = this.SafeGetValue(stat_data, '修为瓶颈', '无'); const jingjieYingshe = this.SafeGetValue(stat_data, '境界映射', '1'); document.getElementById('attr-xiuxing-jindu').innerText = `${xiuxingjindu}%`; document.getElementById('attr-xiuxing-pingjing').innerText = xiuxingpingjing; document.getElementById('attr-jingjie-yingshe').innerText = jingjieYingshe; // 更新修为进度条 const progressBar = document.getElementById('progress-xiuxing'); if (progressBar) { progressBar.style.width = `${xiuxingjindu}%`; } }, showTemporaryMessage(message, duration = 2000) { const existingMsg = document.querySelector(\\'$1\\'); if (existingMsg) existingMsg.remove(); const msgElement = document.createElement('div'); msgElement.className = 'temp-message-popup'; msgElement.textContent = message; msgElement.style.cssText = ` position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(45, 27, 61, 0.9); color: var(--color-primary); padding: 10px 20px; border-radius: 5px; z-index: 2000; font-size: 14px; box-shadow: 0 2px 10px rgba(0,0,0,0.5); text-align: center; transition: opacity 0.5s ease-out; `; document.querySelector(\\'$1\\').appendChild(msgElement); setTimeout(() => { msgElement.style.opacity = '0'; setTimeout(() => msgElement.remove(), 500); }, duration - 500); }, showCommandCenter() { this.openModal('command-center-modal'); const body = document.querySelector(\\'$1\\'); if (!$1) return; if ($1 === $2) { body.innerHTML = '<p class=\"$1\" style=\"\">暂无待执行的指令。</p>'; return; } let html = '<ul class=\"$1\">'; this.pendingActions.forEach(cmd => { let actionText = ''; switch (cmd.action) { case 'equip': actionText = `[装备] ${cmd.itemName} 到 ${cmd.category}`; break; case 'unequip': actionText = `[卸下] ${cmd.itemName} 从 ${cmd.category}`; break; case 'use': actionText = `[使用] ${cmd.itemName} x ${cmd.quantity}`; break; case 'discard': if (cmd.quantity && cmd.quantity> 1) { actionText = `[丢弃] ${cmd.itemName} x ${cmd.quantity}`; } else { actionText = `[丢弃] ${cmd.itemName}`; } break; case 'travel': // 新增 actionText = `[前往] ${cmd.locationName}`; break; case 'do_action': // 新增 actionText = `[行动] ${cmd.text}`; break; } html += `<li class=\"$1\">${actionText}</li>`; }); html += '</ul>'; body.innerHTML = html; }, clearPendingActions() { this.pendingActions = []; this.showCommandCenter(); // 重新渲染指令中心以显示空状态 this.showTemporaryMessage('指令已清空'); this.savePendingActions(); }, refreshLocalStorage() { this.showCustomConfirm('这是为了刷新上一个聊天缓存数据，如果不是打开新聊天，请不要点击', () => { try { localStorage.removeItem('guixu_equipped_items'); localStorage.removeItem('guixu_pending_actions'); localStorage.removeItem('guixu_auto_write_enabled'); this.showTemporaryMessage('缓存已清除，页面即将刷新...'); setTimeout(() => { window.location.reload(); }, 1500); } catch (e) { console.error('清除本地存储失败:', e); this.showTemporaryMessage('清除缓存失败！'); } }); }, async executePendingActions() { // 指令中心的执行按钮现在总是直接发送 await this.handleAction(); }, useItem(item, buttonElement) { const itemName = this.SafeGetValue(item, 'name'); if ($1 === $2) { this.showTemporaryMessage('物品信息错误，无法使用。'); return; } // **BUG修复**: 不再手动操作DOM，而是通过刷新背包来更新UI // 检查待定队列中的数量，以防止用户超额使用 const originalQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10); const pendingUses = this.pendingActions .filter(action => action.action === 'use' && action.itemName === itemName) .reduce((total, action) => total + action.quantity, 0); if (originalQuantity - pendingUses <= 0) { this.showTemporaryMessage(`${itemName} 已用完或已在指令队列中。`); return; } // 更新指令队列 const existingAction = this.pendingActions.find( action => action.action === 'use' && action.itemName === itemName, ); if (existingAction) { existingAction.quantity+; } else { this.pendingActions.push({ action: 'use', itemName: itemName, quantity: 1, }); } this.showTemporaryMessage(`已将 [使用 ${itemName}] 加入指令队列`); this.savePendingActions(); // 通过重新渲染整个背包来保证UI一致性 this.showInventory(); }, discardItem(item, category, itemElement) { const itemName = this.SafeGetValue(item, 'name'); if ($1 === $2) { this.showTemporaryMessage('物品信息错误，无法丢弃。'); return; } const hasQuantity = item.hasOwnProperty('quantity'); if ($1 === $2)) { // 有数量的物品，需要输入丢弃数量 this.promptDiscardQuantity(item, category, itemElement); } else { // 装备类物品，直接确认丢弃 this.confirmDiscardItem(item, category, itemElement, 1); } }, async promptDiscardQuantity(item, category, itemElement) { const itemName = this.SafeGetValue(item, 'name'); const currentQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10); // 计算可丢弃的数量（减去待处理队列中的使用和丢弃数量） const pendingUses = this.pendingActions .filter(action => action.action === 'use' && action.itemName === itemName) .reduce((total, action) => total + action.quantity, 0); const pendingDiscards = this.pendingActions .filter(action => action.action === 'discard' && action.itemName === itemName) .reduce((total, action) => total + action.quantity, 0); const availableQuantity = currentQuantity - pendingUses - pendingDiscards; if (availableQuantity <= 0) { this.showTemporaryMessage(`${itemName} 没有可丢弃的数量。`); return; } return new Promise((resolve) => { // 创建数量输入模态框 const modal = document.createElement('div'); modal.className = 'modal-overlay'; modal.style.display = 'flex'; modal.style.zIndex = '2000'; modal.innerHTML = ` <div class=\"$1\" style=\"\"><div class=\"$1\"><h2 class=\"$1\">丢弃物品</h2></div><div class=\"$1\" style=\"\"><p style=\"\">请输入要丢弃的 <strong>${itemName}</strong> 数量：</p><p style=\"\">当前可丢弃数量：${availableQuantity}</p><input type=\"number\" id=\"discard-quantity-input\" min=\"1\" max=\"${availableQuantity}\" value=\"1\" style=\"\"><div style=\"\"><button id=\"discard-quantity-cancel\" class=\"$1\">取消</button><button id=\"discard-quantity-confirm\" class=\"$1\" style=\"\">确认丢弃</button></div></div></div> `; const container = document.querySelector(\\'$1\\'); container.appendChild(modal); const input = modal.querySelector('#discard-quantity-input'); const confirmBtn = modal.querySelector('#discard-quantity-confirm'); const cancelBtn = modal.querySelector('#discard-quantity-cancel'); confirmBtn.addEventListener('click', () => { const quantity = parseInt(input.value, 10); if (isNaN(quantity) || quantity <= 0 || quantity> availableQuantity) { this.showTemporaryMessage('请输入有效的丢弃数量'); return; } modal.remove(); this.confirmDiscardItem(item, category, itemElement, quantity); resolve(); }); cancelBtn.addEventListener('click', () => { modal.remove(); resolve(); }); // 自动聚焦 setTimeout(() => input.focus(), 100); }); }, confirmDiscardItem(item, category, itemElement, quantity = 1) { const itemName = this.SafeGetValue(item, 'name'); const hasQuantity = item.hasOwnProperty('quantity'); let confirmMessage; if (hasQuantity) { confirmMessage = `确定要丢弃 ${quantity} 个 ${itemName} 吗？此操作不可恢复。`; } else { confirmMessage = `确定要丢弃 ${itemName} 吗？此操作不可恢复。`; } this.showCustomConfirm(confirmMessage, () => { // 添加到指令队列 this.pendingActions.push({ action: 'discard', itemName: itemName, category: category, quantity: quantity }); this.savePendingActions(); // 前端乐观显示：刷新背包以反映变化 this.showInventory(); if (hasQuantity) { this.showTemporaryMessage(`已将 [丢弃 ${quantity} 个 ${itemName}] 加入指令队列`); } else { this.showTemporaryMessage(`已将 [丢弃 ${itemName}] 加入指令队列`); } }); }, showExtractedContent() { this.openModal('extracted-content-modal'); const journeyEl = document.getElementById('extracted-journey'); const pastLivesEl = document.getElementById('extracted-past-lives'); const mapCommandsEl = document.getElementById('extracted-map-commands'); const variablesEl = document.getElementById('extracted-variable-changes'); const sentPromptEl = document.getElementById('sent-prompt-display'); const currentMvuEl = document.getElementById('current-mvu-variables'); if (currentMvuEl) { if (this.currentMvuState) { currentMvuEl.textContent = JSON.stringify(this.currentMvuState, null, 2); } else { currentMvuEl.textContent = 'MVU 状态尚未加载。'; } } if (sentPromptEl) { sentPromptEl.textContent = this.lastSentPrompt || '尚未发送任何内容'; } if (journeyEl) { journeyEl.textContent = this.lastExtractedJourney || '未提取到内容'; } if (pastLivesEl) { pastLivesEl.textContent = this.lastExtractedPastLives || '未提取到内容'; } if (mapCommandsEl) { mapCommandsEl.textContent = this.lastExtractedMapCommands || '未提取到地图指令。'; } if (variablesEl) { variablesEl.textContent = this.lastExtractedVariables || '本次无变量改变'; } const novelModeEl = document.getElementById('extracted-novel-mode'); const novelModeBtn = document.getElementById('btn-write-novel-mode'); if (novelModeEl && novelModeBtn) { // 新逻辑：始终显示提取到的内容。按钮可用性仅取决于内容是否存在。 novelModeEl.textContent = this.lastExtractedNovelText || '当前AI回复中未提取到正文内容。'; novelModeBtn.disabled = !this.lastExtractedNovelText; // 更新标签文本以提供关于自动写入状态的即时反馈 const label = document.querySelector(\\'$1\\'); if (label) { const statusText = this.isNovelModeEnabled ? '开启' : '关闭'; label.title = `点击切换自动写入状态，当前为：${statusText}`; } } // 新增：处理提取的角色卡 const characterCardEl = document.getElementById('extracted-character-card'); const characterCardBtn = document.getElementById('btn-write-character-card'); if (characterCardEl && characterCardBtn) { characterCardEl.textContent = this.lastExtractedCharacterCard || '未提取到角色卡内容。'; characterCardBtn.disabled = !this.lastExtractedCharacterCard; } }, async showJourney() { this.openModal('history-modal'); this.loadUnifiedIndex(); // 确保输入框显示正确的序号 const titleEl = document.getElementById('history-modal-title'); if (titleEl) titleEl.textContent = '本世历程'; // 新增：向模态框头部注入修剪相关的UI元素 const headerControls = document.querySelector(\\'$1\\'); if (headerControls) { headerControls.innerHTML = ``; // 清空旧的修剪按钮 } // 显示修剪控制台并加载状态 const trimConsole = document.getElementById('trim-console'); if (trimConsole) { trimConsole.style.display = 'block'; this.loadTrimFieldsState(); // 确保每次打开都加载最新的状态 } const body = document.getElementById('history-modal-body'); if (!$1) return; // 修复BUG：不再完全覆盖innerHTML，而是只更新时间线部分 const timelinePlaceholder = document.createElement('div'); timelinePlaceholder.id = 'timeline-placeholder'; timelinePlaceholder.innerHTML = '<p class=\"$1\" style=\"\">正在读取命运之卷...</p>'; // 清理旧的时间线并插入占位符 const existingTimeline = body.querySelector('.timeline-container'); if (existingTimeline) { existingTimeline.remove(); } body.appendChild(timelinePlaceholder); try { const bookName = '1归墟'; const index = this.unifiedIndex; const journeyKey = index> 1 ? `本世历程(${index})` : '本世历程'; const allEntries = await TavernHelper.getLorebookEntries(bookName); const journeyEntry = allEntries.find(entry => entry.comment === journeyKey); if (!$1) { console.warn(`在世界书 \"${bookName}\" 中未找到标题为 \"${journeyKey}\" 的条目。`); } // 将渲染好的时间线内容替换掉占位符 timelinePlaceholder.innerHTML = this.renderJourneyFromContent(journeyEntry); // 绑定点击事件监听器 this.bindJourneyListeners(); // 新增：为动态添加的修剪UI绑定事件 document.querySelectorAll(\\'$1\\').forEach(checkbox => { checkbox.addEventListener('change', () => this.saveTrimFieldsState()); }); document.getElementById('btn-precise-trim')?.addEventListener('click', () => this.handlePreciseTrim()); document.getElementById('btn-auto-trim')?.addEventListener('click', () => this.handleAutoTrim()); document.getElementById('btn-full-trim')?.addEventListener('click', () => this.handleFullTrim()); } catch (error) { console.error('读取\"本世历程\"时出错:', error); body.innerHTML = `<p class=\"$1\" style=\"\">读取记忆时出现错误：${error.message}</p>`; } }, async showPastLives() { this.openModal('history-modal'); this.loadUnifiedIndex(); // 确保输入框显示正确的序号 const titleEl = document.getElementById('history-modal-title'); if (titleEl) titleEl.textContent = '往世涟漪'; const body = document.getElementById('history-modal-body'); if (!$1) return; body.innerHTML = '<p class=\"$1\" style=\"\">正在回溯时光长河...</p>'; try { const bookName = '1归墟'; const index = this.unifiedIndex; const pastLivesKey = index> 1 ? `往世涟漪(${index})` : '往世涟漪'; const allEntries = await TavernHelper.getLorebookEntries(bookName); const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey); if (!$1) { console.warn(`在世界书 \"${bookName}\" 中未找到标题为 \"${pastLivesKey}\" 的条目。`); } body.innerHTML = this.renderPastLives(pastLivesEntry); } catch (error) { console.error('读取“往世涟漪”时出错:', error); body.innerHTML = `<p class=\"$1\" style=\"\">回溯时光长河时出现错误：${error.message}</p>`; } }, async showNovelMode() { this.openModal('novel-mode-modal'); this.loadNovelModeIndex(); // 确保输入框显示正确的序号 const titleEl = document.getElementById('novel-mode-modal-title'); if (titleEl) titleEl.textContent = '小说模式'; const body = document.getElementById('novel-mode-modal-body'); if (!$1) return; body.innerHTML = '<p class=\"$1\" style=\"\">正在加载小说内容...</p>'; try { const bookName = '1归墟'; const index = this.novelModeIndex; // 使用独立的序号 const novelModeKey = index> 1 ? `小说模式(${index})` : '小说模式'; const allEntries = await TavernHelper.getLorebookEntries(bookName); const novelModeEntry = allEntries.find(entry => entry.comment === novelModeKey); if (novelModeEntry && novelModeEntry.content) { // 使用 pre-wrap 来保留换行和空格，更适合小说阅读 body.innerHTML = `<div class=\"$1\" style=\"\">${this.formatMessageContent(novelModeEntry.content)}</div>`; } else { body.innerHTML = '<p style=\"\">该序号下没有小说内容。</p>'; } } catch (error) { console.error('读取\"小说模式\"时出错:', error); body.innerHTML = `<p class=\"$1\" style=\"\">读取小说时出现错误：${error.message}</p>`; } }, // --- Rendering Logic for Dynamic Content (Lorebooks) --- parseJourneyEntry(contentString) { if ($1 === $2) return []; try { const events = []; const eventBlocks = contentString .trim() .split(/序号\\|/g) .slice(1); eventBlocks.forEach(block => { const fullBlock = `序号|${block}`.trim(); const event = {}; // 定义字段顺序，用于正确解析多行内容 const fieldOrder = ['序号', '日期', '标题', '地点', '人物', '描述', '人物关系', '标签', '重要信息', '暗线与伏笔', '自动化系统']; let currentFieldIndex = 0; let currentKey = ''; let currentValue = ''; const lines = fullBlock.split('\\n'); for (let $1 = 0; $1 <$2; $1+) { const line = lines[i]; let foundField = false; // 检查是否是新字段的开始 for (let j = currentFieldIndex; j <fieldOrder.length; j+) { const field = fieldOrder[j]; if (line.startsWith(field + '|')) { // 保存前一个字段的值 if (currentKey && currentValue.trim()) { event[currentKey] = currentValue.trim(); } // 开始新字段 currentKey = field; currentValue = line.substring(field.length + 1); currentFieldIndex = j; foundField = true; break; } } // 如果不是新字段，则追加到当前字段值 if (!$1) { currentValue += '\\n' + line; } } // 保存最后一个字段 if (currentKey && currentValue.trim()) { event[currentKey] = currentValue.trim(); } if (event['序号']) { events.push(event); } }); return events; } catch (e) { console.error('解析本世历程条目失败:', e); return []; } }, parsePastLifeEntry(contentString) { if ($1 === $2) return {}; try { const data = {}; // 通过前瞻断言 (?=...) 按每个字段的起始标志进行分割，同时保留分隔符 const parts = contentString.trim().split(/\\n(?=^(?:第\\d+世|事件脉络|本世概述|本世成就|本世获得物品|本世人物关系网|死亡原因|本世总结|本世评价)\\|)/m); for (const part of parts) { if (!$1)) continue; const separatorIndex = part.indexOf('|'); if (separatorIndex> 0) { const key = part.substring(0, separatorIndex).trim(); const value = part.substring(separatorIndex + 1).trim(); data[key] = value; } } return data; } catch (e) { console.error('解析往世涟漪条目失败:', e); return {}; } }, renderJourneyFromContent(entry) { if (!$1) return '<p style=\"\">此生尚未留下任何印记。</p>'; const events = this.parseJourneyEntry(entry.content); if ($1 === $2) return '<p style=\"\">内容格式有误，无法解析事件。</p>'; events.sort((a, b) => (parseInt(a.序号, 10) || 0) - (parseInt(b.序号, 10) || 0)); let html = '<div class=\"$1\">'; events.forEach((eventData, index) => { const eventId = `event-${entry.uid}-${index}`; const date = eventData['日期'] || '未知时间'; const sequence = eventData['序号'] || '?'; const title = eventData['标题'] || '无标题'; const displayTitle = `第${sequence}章 ${title}`; const location = eventData['地点'] || '未知地点'; const description = eventData['描述'] || '无详细描述。'; const characters = eventData['人物'] || ''; const relationships = eventData['人物关系'] || ''; const importantInfo = eventData['重要信息'] || ''; const hiddenPlot = eventData['暗线与伏笔'] || ''; const autoSystem = eventData['自动化系统'] || ''; const tagsHtml = (eventData['标签'] || '') .split('|') .map(tag => tag.trim()) .filter(tag => tag) .map(tag => `<span class=\"$1\">${tag}</span>`) .join(''); // 基本信息（默认显示） - 调整了HTML结构以适应新的复选框位置 const basicInfo = ` <div style=\"\"><div class=\"$1\">${date}</div><input type=\"checkbox\" class=\"$1\" data-$1=\"$2\"序号']}\" style=\"\"></div><div class=\"$1\">${tagsHtml}</div><div class=\"$1\">${displayTitle}</div><div class=\"$1\" style=\"\">地点：${location}</div><div class=\"$1\">${description}</div> `; // 详细信息（需要点击3次才显示） const detailedInfo = ` <div class=\"$1\" id=\"detailed-${eventId}\" style=\"\"> ${characters ? `<div class=\"$1\"><strong>人物：</strong>${characters}</div>` : ''} ${relationships ? `<div class=\"$1\"><strong>人物关系：</strong>${relationships}</div>` : ''} ${importantInfo ? `<div class=\"$1\"><strong>重要信息：</strong>${importantInfo}</div>` : ''} ${hiddenPlot ? `<div class=\"$1\"><strong>暗线与伏笔：</strong>${hiddenPlot}</div>` : ''} ${autoSystem ? `<div class=\"$1\"><strong>自动化系统：</strong><pre style=\"\">${autoSystem}</pre></div>` : ''} </div> `; html += ` <div class=\"$1\" data-$1=\"$2\" data-$1=\"$2\" style=\"\"><div class=\"$1\"> ${basicInfo} ${detailedInfo} </div></div>`; }); html += '</div>'; return html; }, renderPastLives(entry) { if (!$1)) return '<p style=\"\">未发现任何往世的痕迹。</p>'; // 使用前瞻断言来分割，这样不会消耗分隔符，可以正确处理每一世的记录 const pastLifeBlocks = entry.content.trim().split(/\\n\\n?(?=第\\d+世\\|)/); if ($1 === $2) return '<p style=\"\">内容格式有误，无法解析往世记录。</p>'; let html = '<div class=\"$1\">'; pastLifeBlocks.forEach(block => { if (!$1)) return; // 跳过可能产生的空块 const data = this.parsePastLifeEntry(block); const titleKey = Object.keys(data).find(k => k.startsWith('第') && k.endsWith('世')); let title; // 修复：检查属性是否存在，而不是值的真假，并为无题的情况提供回退 if (titleKey && data.hasOwnProperty(titleKey)) { const titleValue = data[titleKey] || '无题'; title = `${titleKey} | ${titleValue}`; } else { // 如果解析失败，则将块的第一行作为标题 title = block.split('\\n')[0].trim(); } let detailsHtml = ''; const fieldOrder = ['事件脉络', '本世概述', '本世成就', '本世获得物品', '本世人物关系网', '死亡原因', '本世总结', '本世评价']; fieldOrder.forEach(field => { if (data[field]) { // 使用<pre>标签来保留多行文本的换行和格式 const fieldClassMap = { '死亡原因': 'death-reason', '本世成就': 'achievement', '本世获得物品': 'items-obtained', '本世总结': 'summary-evaluation', '本世评价': 'summary-evaluation' }; const specificClass = fieldClassMap[field] || ''; const itemClass = `detail-item ${specificClass}`.trim(); detailsHtml += `<div class=\"$1\"><strong>${field}:</strong><pre style=\"\">${data[field]}</pre></div>`; } }); html += ` <div class=\"$1\"><div class=\"$1\"><div class=\"$1\">${title}</div><div class=\"$1\"> ${detailsHtml || '<div class=\"$1\">内容不详</div>'} </div></div></div>`; }); html += '</div>'; return html; }, async renderPastLifeDetails(bookName) { const detailsContainer = document.getElementById('past-life-details'); if (!$1) return; detailsContainer.style.display = 'block'; detailsContainer.innerHTML = '<p class=\"$1\" style=\"\">正在读取此世记忆...</p>'; try { const entries = await TavernHelper.getLorebookEntries(bookName, 'summary'); if (entries && entries.length> 0) { const summaryData = JSON.parse(entries[0].content); detailsContainer.innerHTML = ` <h4>${bookName} - 结局总览</h4><p><strong>最终境界:</strong> ${summaryData.finalStats.境界}</p><p><strong>存活时间:</strong> ${summaryData.finalStats.存活时间}</p><p><strong>主要成就:</strong> ${summaryData.achievements.join('、 ')}</p><p><strong>最终悔憾:</strong> ${summaryData.regrets}</p><p><strong>关键事件:</strong></p><ul style=\"\">${summaryData.keyEvents .map(e => `<li>${e}</li>`) .join('')}</ul>`; } else { detailsContainer.innerHTML = '<p class=\"$1\" style=\"\">未能找到此世的结局总览。</p>'; } } catch (error) { console.error(`Error fetching details for ${bookName}:`, error); detailsContainer.innerHTML = `<p class=\"$1\" style=\"\">读取此世记忆时出错：${error.message}</p>`; } }, // --- Dynamic Event Listeners for Lorebook content --- bindJourneyListeners() { // 为本世历程事件绑定点击监听器 const timelineContainer = document.querySelector(\\'$1\\'); if (timelineContainer) { timelineContainer.addEventListener('click', (e) => { const timelineEvent = e.target.closest('.timeline-event'); if (timelineEvent) { this.handleJourneyEventClick(timelineEvent); } }); } }, handleJourneyEventClick(eventElement) { const detailedInfo = eventElement.querySelector('.timeline-detailed-info'); // 检查详细信息是否已经显示 if ($1 === $2) { // 如果已显示，则隐藏 detailedInfo.style.display = 'none'; eventElement.style.cursor = 'pointer'; // 重置点击计数，允许重新开始3次点击 eventElement.dataset.clickCount = '0'; } else { // 如果未显示，继续原有的3次点击逻辑 const currentCount = parseInt(eventElement.dataset.clickCount || '0', 10); const newCount = currentCount + 1; eventElement.dataset.clickCount = newCount; // 当点击3次时显示详细信息 if (newCount>= 3) { if (detailedInfo) { detailedInfo.style.display = 'block'; } // 保持点击样式，允许再次点击隐藏 eventElement.style.cursor = 'pointer'; } } }, async handleRewind(eventId, eventTitle) { // “回溯”按钮相关逻辑已移除 }, // 此函数不再需要，提取逻辑已合并到 loadAndDisplayCurrentScene processAIResponse() { // 空函数或可直接删除 }, // --- 新增：写入世界书的核心逻辑 --- // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 async writeJourneyToLorebook(silent = false) { const content = this.lastExtractedJourney; await this.writeToLorebook('本世历程', content, silent); }, async writePastLivesToLorebook(silent = false) { const content = this.lastExtractedPastLives; await this.writeToLorebook('往世涟漪', content, silent); }, async writeNovelModeToLorebook(silent = false) { const novelText = this.lastExtractedNovelText; // 如果没有正文内容，则不执行任何操作 if ($1 === $2) { if (!$1) this.showTemporaryMessage('没有可写入的小说正文。'); return; } const journeyText = this.lastExtractedJourney; let chapterHeader = ''; // 尝试从本世历程中提取章节信息 if (journeyText) { try { const events = this.parseJourneyEntry(journeyText); if (events.length> 0) { // 假设数组中最后一个事件是最新的 const latestEvent = events[events.length - 1]; const sequence = this.SafeGetValue(latestEvent, '序号', null); const title = this.SafeGetValue(latestEvent, '标题', null); if (sequence && title) { chapterHeader = `第${sequence}章 ${title}\\n\\n`; } } } catch (e) { console.error('为小说模式解析章节标题时出错:', e); } } const finalContent = chapterHeader + novelText; await this.writeToLorebook('小说模式', finalContent, silent); }, // 最终版：重构写入逻辑，支持动态索引和条目创建 async writeToLorebook(baseEntryKey, contentToWrite, silent = false) { if ($1 === $2) { if (!$1) this.showTemporaryMessage('没有可写入的内容。'); return; } // 1. 根据序号生成最终的条目名称 const index = baseEntryKey === '小说模式' ? this.novelModeIndex : this.unifiedIndex; const finalEntryKey = index> 1 ? `${baseEntryKey}(${index})` : baseEntryKey; const bookName = '1归墟'; let reformattedContent = contentToWrite.trim(); let buttonId; // 2. 内容格式化 (逻辑保持不变) if ($1 === $2) { const parsePastLivesRobust = (text) => { const data = {}; const lines = text.trim().split('\\n'); let currentKey = null; let tempValue = []; const keyRegex = /^(第\\d+世|事件脉络|本世概述|本世成就|本世获得物品|本世人物关系网|死亡原因|本世总结|本世评价)\\|/; for (const line of lines) { const match = line.match(keyRegex); if (match) { if (currentKey) { data[currentKey] = tempValue.join('\\n').trim(); } currentKey = match[1]; tempValue = [line.substring(match[0].length)]; } else if (currentKey) { tempValue.push(line); } } if (currentKey) { data[currentKey] = tempValue.join('\\n').trim(); } return data; }; const parsedData = parsePastLivesRobust(contentToWrite); if ($1 === $2) { if (!$1) this.showTemporaryMessage(`无法解析“${baseEntryKey}”的内容，写入操作已取消。`); return; } const dynamicKey = Object.keys(parsedData).find(k => k.startsWith('第') && k.endsWith('世')); const fields = [ dynamicKey, '事件脉络', '本世概述', '本世成就', '本世获得物品', '本世人物关系网', '死亡原因', '本世总结', '本世评价', ].filter(Boolean); reformattedContent = fields .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null)) .filter(Boolean) .join('\\n'); buttonId = 'btn-write-past-lives'; } else if ($1 === $2) { const journeyFields = ['序号', '日期', '标题', '描述', '标签']; const parseContent = (text, fieldList) => { const data = {}; let tempText = text.replace(/\\r\\n/g, '\\n'); fieldList.forEach((field, fIndex) => { const nextField = fieldList[fIndex + 1]; const startMarker = `${field}|`; const startIndex = tempText.indexOf(startMarker); if ($1 === $2) { let endIndex; if (nextField) { const nextMarkerIndex = tempText.indexOf(`${nextField}|`, startIndex); endIndex = nextMarkerIndex !== -1 ? nextMarkerIndex : undefined; } let value = tempText.substring(startIndex + startMarker.length, endIndex); data[field] = value.trim(); } }); return data; }; const parsedData = parseContent(contentToWrite, journeyFields); if ($1 === $2) { if (!$1) this.showTemporaryMessage(`无法解析“${baseEntryKey}”的内容，写入操作已取消。`); return; } reformattedContent = journeyFields .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null)) .filter(Boolean) .join('\\n'); buttonId = 'btn-write-journey'; } else if ($1 === $2) { buttonId = 'btn-write-novel-mode'; } const button = document.getElementById(buttonId); if (button && !silent) button.textContent = '写入中...'; try { // 3. 检查条目是否存在，如果不存在则创建 const allEntries = await TavernHelper.getLorebookEntries(bookName); let targetEntry = allEntries.find(entry => entry.comment === finalEntryKey); if (!$1) { if (!$1) this.showTemporaryMessage(`条目 \"${finalEntryKey}\" 不存在，正在创建...`); let finalContentToWrite = reformattedContent; // 新增：如果是本世历程且开启了自动修剪，则对新创建的内容也进行一次检查（虽然通常是第一个事件，但逻辑上完整） if ($1 === $2) { finalContentToWrite = this._getTrimmedJourneyContent(finalContentToWrite); } const baseEntryTemplate = allEntries.find(entry => entry.comment === baseEntryKey); const newEntryData = { comment: finalEntryKey, content: finalContentToWrite, // 使用可能被修剪过的内容 keys: baseEntryTemplate ? [...baseEntryTemplate.keys, finalEntryKey] : [finalEntryKey], enabled: false, selective: baseEntryTemplate?.selective, constant: baseEntryTemplate?.constant, position: baseEntryTemplate?.position, case_sensitive: baseEntryTemplate?.case_sensitive, }; await TavernHelper.createLorebookEntries(bookName, [newEntryData]); if (!$1) this.showTemporaryMessage(`已成功创建并写入到“${finalEntryKey}”。`); if (this.isAutoToggleLorebookEnabled) { this.updateAutoToggledEntries(); } } else { // 4. 如果条目存在，则根据类型决定是追加还是覆盖 let updatedContent; if ($1 === $2) { // 对于小说模式，检查重复后追加内容 const existingContent = targetEntry.content || ''; if (existingContent.includes(reformattedContent.trim())) { if (!$1) this.showTemporaryMessage(`内容已存在，跳过写入。`); console.log(`[归墟] 内容重复 (小说模式)，跳过写入: ${finalEntryKey}`); if (button && !silent) { button.textContent = '写入世界书'; } return; } updatedContent = existingContent + (existingContent ? '\\n\\n' : '') + reformattedContent; if (!$1) this.showTemporaryMessage(`已成功追加内容到“${finalEntryKey}”`); } else { // 对于其他类型（如本世历程），检查重复后追加内容 const existingContent = targetEntry.content || ''; // 新增：基于序号的更可靠的重复检查，以解决修剪冲突 const getSeq = (text) => { if (!$1) return null; // Match '序号|' at the very beginning of the block const match = text.match(/^序号\\|(\\d+)/); return match ? match[1] : null; }; const newEventSeq = getSeq(reformattedContent.trim()); let isDuplicate = false; if ($1 === $2) { const existingSequences = (existingContent) .split('\\n\\n') // Events are separated by double newlines .map(block => getSeq(block.trim())) .filter(seq => seq !== null); if (existingSequences.includes(newEventSeq)) { isDuplicate = true; } } else { // 如果新内容没有序号，或不是“本世历程”，则退回旧的基于内容的检查 isDuplicate = existingContent.includes(reformattedContent.trim()); } if (isDuplicate) { const message = newEventSeq ? `事件 (序号 ${newEventSeq}) 已存在` : '内容已存在'; if (!$1) this.showTemporaryMessage(`${message}，跳过写入。`); console.log(`[归墟] 内容重复 (${message})，跳过写入: ${finalEntryKey}`); if ($1 === $2) this.lastWrittenJourney = this.lastExtractedJourney; if ($1 === $2) this.lastWrittenPastLives = this.lastExtractedPastLives; if (button && !silent) { button.textContent = '写入世界书'; } return; // 提前退出函数 } updatedContent = existingContent + (existingContent ? '\\n\\n' : '') + reformattedContent; if (!$1) this.showTemporaryMessage(`已成功追加内容到“${finalEntryKey}”`); } // 核心修复：在合并内容后、写入之前执行修剪 if ($1 === $2) { console.log('[归墟] 自动修剪已开启，正在处理合并后的内容...'); updatedContent = this._getTrimmedJourneyContent(updatedContent); } await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: updatedContent }]); } if (button && !silent) { button.textContent = '写入成功'; setTimeout(() => { button.textContent = '写入世界书'; }, 2000); } } catch (error) { console.error(`写入世界书 \"${finalEntryKey}\" 时出错:`, error); if (!$1) { this.showTemporaryMessage(`写入失败: ${error.message}`); if (button) button.textContent = '写入失败'; } } finally { if ($1 === $2) { button.textContent = '写入世界书'; } } }, async writeCharacterCardToLorebook() { const content = this.lastExtractedCharacterCard; if (!$1) { this.showTemporaryMessage('没有可写入的角色内容。'); return; } const button = document.getElementById('btn-write-character-card'); if (button) button.textContent = '写入中...'; try { const lines = content.trim().split('\\n'); const characterData = {}; lines.forEach(line => { const parts = line.split('|'); if (parts.length>= 2) { const key = parts[0].trim(); const value = parts.slice(1).join('|').trim(); characterData[key] = value; } }); const characterName = characterData['姓名']; if (!$1) { throw new Error('无法从提取内容中找到角色“姓名”。'); } const bookName = '1归墟'; const allEntries = await TavernHelper.getLorebookEntries(bookName); const existingEntry = allEntries.find(entry => entry.comment === characterName); if (existingEntry) { this.showTemporaryMessage(`角色“${characterName}”已存在，请手动修改。`); if (button) button.textContent = '写入世界书'; return; } await TavernHelper.createLorebookEntries(bookName, [ { comment: characterName, keys: [characterName], content: content.trim(), enabled: true, }, ]); this.showTemporaryMessage(`已成功创建角色“${characterName}”。`); if (button) button.textContent = '写入成功'; setTimeout(() => { if (button) button.textContent = '写入世界书'; }, 2000); } catch (error) { console.error('写入角色卡到世界书时出错:', error); this.showTemporaryMessage(`写入失败: ${error.message}`); if (button) button.textContent = '写入失败'; } }, async updateCurrentSceneLorebook(sceneContent) { // 增加健壮性检查，防止写入空内容 if ($1 === $2) { console.warn('[归墟] 尝试向“当前场景”写入空内容，操作已取消。'); return; } const bookName = '1归墟'; const sceneKey = '当前场景'; try { const allEntries = await TavernHelper.getLorebookEntries(bookName); const sceneEntry = allEntries.find(entry => entry.comment === sceneKey); if (!$1) { console.warn( `[归墟] 未找到世界书条目 \"${sceneKey}\"，无法更新场景正文。请在'${bookName}'世界书中创建它。`, ); // 如果条目不存在，我们可以选择创建一个 await TavernHelper.createLorebookEntries(bookName, [ { comment: sceneKey, content: sceneContent, keys: [], }, ]); console.log(`[归墟] 已创建并更新 \"${sceneKey}\" 内容。`); return; } // 使用覆盖式更新 await TavernHelper.setLorebookEntries(bookName, [{ uid: sceneEntry.uid, content: sceneContent }]); console.log(`[归墟] 成功更新 \"${sceneKey}\" 内容。`); } catch (error) { console.error(`[归墟] 更新 \"${sceneKey}\" 时出错:`, error); } }, async loadAndDisplayCurrentScene(messageContent = null) { const gameTextDisplay = document.getElementById('game-text-display'); if (!$1) return; try { let contentToParse = messageContent; // 如果没有直接提供内容，则从聊天记录中获取 if ($1 === $2) { const messages = await getChatMessages(getCurrentMessageId()); if ($1 === $2) return; const lastAiMessage = [...messages].reverse().find(m => m.role === 'assistant'); if (lastAiMessage) { contentToParse = lastAiMessage.message; } } if (contentToParse) { // 1. 更新主界面正文 (使用新的健壮的提取函数) const displayText = this._getDisplayText(contentToParse); gameTextDisplay.innerHTML = this.formatMessageContent(displayText); // 2. 同步提取所有标签内容到变量，用于“查看提取内容”模态框 this.lastExtractedNovelText = this._extractLastTagContent('gametxt', contentToParse); this.lastExtractedJourney = this._extractLastTagContent('本世历程', contentToParse); this.lastExtractedPastLives = this._extractLastTagContent('往世涟漪', contentToParse); this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', contentToParse, true); // ignore case this.lastExtractedCharacterCard = this._extractLastTagContent('角色提取', contentToParse); this.lastExtractedMapCommands = this._extractLastTagContent('地图', contentToParse); // 新增：更新变量改变提醒 this.updateVariableChangesReminder(); // 3. 新增：提取并渲染行动选项 let actionOptionsContent = this._extractLastTagContent('行动选项', contentToParse); if (!$1) { actionOptionsContent = this._extractLastTagContent('action', contentToParse); } this.renderActionOptions(actionOptionsContent); } } catch (error) { console.error(`[归墟] 加载并显示当前场景时出错:`, error); gameTextDisplay.innerHTML = `<gametxt>加载场景时出错。</gametxt>`; } }, // --- 新增：行动选项渲染函数 --- renderActionOptions(content) { const container = document.getElementById('action-options-container'); if (!$1) return; container.innerHTML = ''; // 清空旧选项 // 如果开关关闭，则不显示任何选项 if (!$1) { return; } if ($1 === $2) { return; // 如果没有内容，直接返回 } const lines = content.trim().split('\\n'); lines.forEach(line => { line = line.trim(); const match = line.match(/^(\\d+)\\.(.+)$/); if (match) { const optionText = match[2].trim(); const btn = document.createElement('button'); btn.className = 'action-option-btn'; btn.textContent = optionText; btn.dataset.actionText = optionText; // 将选项文本存入data属性 container.appendChild(btn); } }); }, // --- 新增：状态保存与自动写入逻辑 --- saveAutoWriteState(state) { try { localStorage.setItem('guixu_auto_write_enabled', state); } catch (e) { console.error('保存自动写入状态失败:', e); } }, loadAutoWriteState() { try { const savedState = localStorage.getItem('guixu_auto_write_enabled'); // 如果localStorage中没有保存过状态，则默认为true (开启) this.isAutoWriteEnabled = savedState === null ? true : savedState === 'true'; const checkbox = document.getElementById('auto-write-checkbox'); if (checkbox) { checkbox.checked = this.isAutoWriteEnabled; } // 根据加载的状态决定是否启动轮询 if (this.isAutoWriteEnabled) { this.startAutoWritePolling(); } } catch (e) { console.error('加载自动写入状态失败:', e); this.isAutoWriteEnabled = false; } }, saveNovelModeState(state) { try { localStorage.setItem('guixu_novel_mode_enabled', state); } catch (e) { console.error('保存小说模式状态失败:', e); } }, loadNovelModeState() { try { const savedState = localStorage.getItem('guixu_novel_mode_enabled'); // 小说模式默认为 false (关闭) this.isNovelModeEnabled = savedState === 'true'; const checkbox = document.getElementById('novel-mode-enabled-checkbox'); if (checkbox) { checkbox.checked = this.isNovelModeEnabled; } // 根据加载的状态决定是否启动小说模式的轮询 if (this.isNovelModeEnabled) { this.startNovelModeAutoWritePolling(); } } catch (e) { console.error('加载小说模式状态失败:', e); this.isNovelModeEnabled = false; } }, startAutoWritePolling() { this.stopAutoWritePolling(); console.log('[归墟] 启动自动写入轮询 (setTimeout模式)...'); const poll = async () => { if (!$1) return; // Check for new Journey content if ($1 === $2) { await this.writeJourneyToLorebook(true); this.lastWrittenJourney = this.lastExtractedJourney; // Mark as written } // Check for new Past Lives content if ($1 === $2) { await this.writePastLivesToLorebook(true); this.lastWrittenPastLives = this.lastExtractedPastLives; // Mark as written } // Schedule next poll if (this.isAutoWriteEnabled) { this.autoWriteIntervalId = setTimeout(poll, 2000); } }; this.autoWriteIntervalId = setTimeout(poll, 2000); }, stopAutoWritePolling() { if (this.autoWriteIntervalId) { console.log('[归墟] 停止自动写入轮询。'); clearTimeout(this.autoWriteIntervalId); // 改为 clearTimeout this.autoWriteIntervalId = null; } }, // --- 新增：小说模式自动写入轮询 --- startNovelModeAutoWritePolling() { this.stopNovelModeAutoWritePolling(); console.log('[归墟] 启动小说模式自动写入轮询 (setTimeout模式)...'); const poll = async () => { if (!$1) return; // Check for new Novel Mode content if ($1 === $2) { await this.writeNovelModeToLorebook(true); this.lastWrittenNovelText = this.lastExtractedNovelText; // Mark as written } if (this.isNovelModeEnabled) { this.novelModeAutoWriteIntervalId = setTimeout(poll, 2000); } }; this.novelModeAutoWriteIntervalId = setTimeout(poll, 2000); }, stopNovelModeAutoWritePolling() { if (this.novelModeAutoWriteIntervalId) { console.log('[归墟] 停止小说模式自动写入轮询。'); clearTimeout(this.novelModeAutoWriteIntervalId); // 改为 clearTimeout this.novelModeAutoWriteIntervalId = null; } }, // --- 新增：装备状态保存与加载 --- startMapUpdatePolling() { this.stopMapUpdatePolling(); console.log('[归墟] 启动地图指令自动解析轮询 (setTimeout模式)...'); const poll = async () => { if (this.lastExtractedMapCommands) { await this.handleMapUpdateCommand(this.lastExtractedMapCommands); this.lastExtractedMapCommands = null; } // 地图轮询应该持续进行，所以不需要检查特定开关 this.mapUpdateIntervalId = setTimeout(poll, 2500); }; this.mapUpdateIntervalId = setTimeout(poll, 2500); }, stopMapUpdatePolling() { if (this.mapUpdateIntervalId) { console.log('[归墟] 停止地图指令自动解析轮询。'); clearTimeout(this.mapUpdateIntervalId); // 改为 clearTimeout this.mapUpdateIntervalId = null; } }, saveEquipmentState() { try { localStorage.setItem('guixu_equipped_items', JSON.stringify(this.equippedItems)); } catch (e) { console.error('保存装备状态失败:', e); } }, // **逻辑重构**: 彻底简化的加载函数 loadEquipmentState() { try { const savedState = localStorage.getItem('guixu_equipped_items'); if (savedState) { const loadedItems = JSON.parse(savedState); if (!$1) return; this.equippedItems = loadedItems; const defaultTextMap = { wuqi: '武器', fangju: '防具', shipin: '饰品', fabao1: '法宝', zhuxiuGongfa: '主修功法', fuxiuXinfa: '辅修心法', }; // 直接用 localStorage 的数据渲染UI for (const slotKey in defaultTextMap) { const slotElement = document.getElementById(`equip-${slotKey}`); if (!$1) continue; const itemData = this.equippedItems[slotKey]; if ($1 === $2) { const tier = this.SafeGetValue(itemData, 'tier', '凡品'); const tierStyle = this.getTierStyle(tier); slotElement.textContent = this.SafeGetValue(itemData, 'name'); slotElement.setAttribute('style', tierStyle); slotElement.classList.add('equipped'); slotElement.dataset.itemDetails = JSON.stringify(itemData).replace(/'/g, \"'\"); } else { slotElement.textContent = defaultTextMap[slotKey]; slotElement.classList.remove('equipped'); slotElement.removeAttribute('style'); delete slotElement.dataset.itemDetails; } } this.updateDisplayedAttributes(); } } catch (e) { console.error('加载装备状态失败:', e); localStorage.removeItem('guixu_equipped_items'); } }, savePendingActions() { try { localStorage.setItem('guixu_pending_actions', JSON.stringify(this.pendingActions)); } catch (e) { console.error('保存指令队列状态失败:', e); } }, loadPendingActions() { try { const savedActions = localStorage.getItem('guixu_pending_actions'); if (savedActions) { this.pendingActions = JSON.parse(savedActions) || []; } } catch (e) { console.error('加载指令队列状态失败:', e); this.pendingActions = []; localStorage.removeItem('guixu_pending_actions'); } }, // --- 新增：统一读写序号存取 --- saveUnifiedIndex() { try { localStorage.setItem('guixu_unified_index', this.unifiedIndex); } catch (e) { console.error('保存统一读写序号失败:', e); } }, loadUnifiedIndex() { try { const savedIndex = localStorage.getItem('guixu_unified_index'); if (savedIndex) { this.unifiedIndex = parseInt(savedIndex, 10) || 1; } const input = document.getElementById('unified-index-input'); if (input) { input.value = this.unifiedIndex; } } catch (e) { console.error('加载统一读写序号失败:', e); this.unifiedIndex = 1; // 出错时重置为1 } }, // --- 新增：小说模式独立读写序号存取 --- saveNovelModeIndex() { try { localStorage.setItem('guixu_novel_mode_index', this.novelModeIndex); } catch (e) { console.error('保存小说模式读写序号失败:', e); } }, loadNovelModeIndex() { try { const savedIndex = localStorage.getItem('guixu_novel_mode_index'); if (savedIndex) { this.novelModeIndex = parseInt(savedIndex, 10) || 1; } const input = document.getElementById('novel-mode-index-input'); if (input) { input.value = this.novelModeIndex; } } catch (e) { console.error('加载小说模式读写序号失败:', e); this.novelModeIndex = 1; // 出错时重置为1 } }, // --- 新增：自动开关世界书状态存取 --- saveAutoToggleState() { try { localStorage.setItem('guixu_auto_toggle_enabled', this.isAutoToggleLorebookEnabled); } catch (e) { console.error('保存自动开关状态失败:', e); } }, loadAutoToggleState() { try { const savedState = localStorage.getItem('guixu_auto_toggle_enabled'); this.isAutoToggleLorebookEnabled = savedState === 'true'; const checkbox = document.getElementById('auto-toggle-lorebook-checkbox'); if (checkbox) { checkbox.checked = this.isAutoToggleLorebookEnabled; } // 根据加载的状态决定是否启动轮询 if (this.isAutoToggleLorebookEnabled) { this.startAutoTogglePolling(); } } catch (e) { console.error('加载自动开关状态失败:', e); this.isAutoToggleLorebookEnabled = false; } }, // --- 新增：自动开关世界书轮询逻辑 (V2: 增加条目自动创建) --- async updateAutoToggledEntries(andDisableAll = false) { const bookName = '1归墟'; const index = this.unifiedIndex; const journeyKey = index> 1 ? `本世历程(${index})` : '本世历程'; const pastLivesKey = index> 1 ? `往世涟漪(${index})` : '往世涟漪'; try { let allEntries = await TavernHelper.getLorebookEntries(bookName); const entriesToCreate = []; // --- 核心修复：检查并创建缺失的条目 --- const targetJourneyEntry = allEntries.find(e => e.comment === journeyKey); if (!$1) { const baseTemplate = allEntries.find(e => e.comment === '本世历程'); if (baseTemplate) { // 最终修复V3：使用正确的属性并确保启用 const newJourneyEntry = { ...baseTemplate }; delete newJourneyEntry.uid; newJourneyEntry.comment = journeyKey; newJourneyEntry.content = ''; newJourneyEntry.keys = [...(baseTemplate.keys || []), journeyKey]; newJourneyEntry.enabled = true; newJourneyEntry.position = 'before_character_definition'; newJourneyEntry.order = 20; entriesToCreate.push(newJourneyEntry); } } const targetPastLivesEntry = allEntries.find(e => e.comment === pastLivesKey); if (!$1) { const baseTemplate = allEntries.find(e => e.comment === '往世涟漪'); if (baseTemplate) { // 最终修复V3：使用正确的属性并确保启用 const newPastLivesEntry = { ...baseTemplate }; delete newPastLivesEntry.uid; newPastLivesEntry.comment = pastLivesKey; newPastLivesEntry.content = ''; newPastLivesEntry.keys = [...(baseTemplate.keys || []), pastLivesKey]; newPastLivesEntry.enabled = true; newPastLivesEntry.position = 'before_character_definition'; newPastLivesEntry.order = 19; entriesToCreate.push(newPastLivesEntry); } } if (entriesToCreate.length> 0) { await TavernHelper.createLorebookEntries(bookName, entriesToCreate); console.log(`[归墟自动开关] 已自动创建 ${entriesToCreate.length} 个新世界书条目。`); // 重新获取所有条目，以包含新创建的条目 allEntries = await TavernHelper.getLorebookEntries(bookName); } // --- 修复结束 --- const entriesToUpdate = []; for (const entry of allEntries) { const isJourneyEntry = entry.comment.startsWith('本世历程'); const isPastLivesEntry = entry.comment.startsWith('往世涟漪'); if (!$1) { continue; } const isTarget = entry.comment === journeyKey || entry.comment === pastLivesKey; const shouldBeEnabled = isTarget && !andDisableAll; if ($1 === $2) { entriesToUpdate.push({ uid: entry.uid, enabled: shouldBeEnabled }); } } if (entriesToUpdate.length> 0) { await TavernHelper.setLorebookEntries(bookName, entriesToUpdate); console.log(`[归墟自动开关] 更新了 ${entriesToUpdate.length} 个世界书条目状态。`); } } catch (error) { console.error('[归墟自动开关] 更新世界书条目状态时出错:', error); } }, startAutoTogglePolling() { this.stopAutoTogglePolling(false); // 先停止任何可能存在的旧轮询, 但不禁用条目 console.log('[归墟] 启动世界书自动开关轮询...'); this.updateAutoToggledEntries(); // 立即执行一次 this.autoToggleIntervalId = setInterval(() => this.updateAutoToggledEntries(), 5000); // 每5秒轮询一次 }, stopAutoTogglePolling(disableEntries = true) { if (this.autoToggleIntervalId) { console.log('[归墟] 停止世界书自动开关轮询。'); clearInterval(this.autoToggleIntervalId); this.autoToggleIntervalId = null; } if (disableEntries) { // 停止时，确保所有相关条目都被禁用 this.updateAutoToggledEntries(true); } }, // --- Misc --- applyRandomBackground() { const container = document.querySelector(\\'$1\\'); if (!$1) { console.warn('[归墟背景] 找不到根容器，无法应用背景图'); return; } console.log('[归墟背景] 应用背景图，模式:', this.backgroundMode, '图片数量:', this.backgroundImages.length); // 如果用户有自定义背景图，则使用用户的设置 if (this.backgroundImages.length> 0) { let backgroundToApply; if ($1 === $2) { // 固定模式：使用选中的背景图 backgroundToApply = this.backgroundImages.find(bg => bg.id === this.selectedBackgroundId); if (!$1) { console.warn('[归墟背景] 找不到选中的背景图，ID:', this.selectedBackgroundId, '切换到随机模式'); backgroundToApply = this.backgroundImages[Math.floor(Math.random() * this.backgroundImages.length)]; } } else if ($1 === $2) { // 随机模式：从用户背景图中随机选择 backgroundToApply = this.backgroundImages[Math.floor(Math.random() * this.backgroundImages.length)]; } if (backgroundToApply && backgroundToApply.dataUrl) { // 检查是否为Object URL（以blob:开头） const isObjectUrl = backgroundToApply.dataUrl.startsWith('blob:'); // 检查是否为外链图片 const isUrlImage = backgroundToApply.isUrlImage; if (isObjectUrl) { console.log(`[归墟背景] 使用Object URL背景: ${backgroundToApply.name}`); // 对于Object URL，需要验证其有效性 const img = new Image(); img.onload = () => { container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`; console.log(`[归墟背景] 成功应用Object URL背景: ${backgroundToApply.name}`); }; img.onerror = () => { console.error(`[归墟背景] Object URL背景无效: ${backgroundToApply.name}`); this.handleInvalidBackground(backgroundToApply); }; img.src = backgroundToApply.dataUrl; } else if (isUrlImage) { console.log(`[归墟背景] 使用外链图片背景: ${backgroundToApply.name}`); // 对于外链图片，需要验证其有效性 const img = new Image(); img.onload = () => { container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`; console.log(`[归墟背景] 成功应用外链背景: ${backgroundToApply.name}`); }; img.onerror = () => { console.error(`[归墟背景] 外链背景无效或无法访问: ${backgroundToApply.name}`); this.handleInvalidBackground(backgroundToApply); }; // 设置跨域属性 img.crossOrigin = 'anonymous'; img.src = backgroundToApply.dataUrl; } else { // 普通DataURL，直接应用 container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`; console.log(`[归墟背景] 应用背景: ${backgroundToApply.name} (${this.backgroundMode}模式)`); } return; } } // 如果没有用户背景图，使用默认背景 console.log('[归墟背景] 使用默认背景图'); const defaultBackgrounds = [ 'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png', 'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png', ]; const bgUrl = defaultBackgrounds[Math.floor(Math.random() * defaultBackgrounds.length)]; container.style.backgroundImage = `url('${bgUrl}')`; }, // 新增：处理无效背景的函数 handleInvalidBackground(invalidBackground) { const bgType = invalidBackground.isUrlImage ? '外链图片' : invalidBackground.dataUrl.startsWith('blob:') ? 'Object URL图片' : '本地图片'; console.warn(`[归墟背景] 处理无效背景: ${invalidBackground.name} (${bgType})`); // 显示用户友好的提示信息 if (invalidBackground.isUrlImage) { this.showTemporaryMessage(`外链图片\"${invalidBackground.name}\"无法访问，已自动移除`, 4000); } // 从背景列表中移除无效背景 const index = this.backgroundImages.findIndex(bg => bg.id === invalidBackground.id); if ($1 === $2) { this.backgroundImages.splice(index, 1); this.saveBackgroundSettings(); console.log(`[归墟背景] 已移除无效背景: ${invalidBackground.name}`); // 如果删除的是当前选中的背景，清除选择 if ($1 === $2) { this.selectedBackgroundId = null; this.backgroundMode = 'random'; // 切换到随机模式 this.saveBackgroundSettings(); } // 如果还有其他背景，尝试应用一个新的 if (this.backgroundImages.length> 0) { this.applyRandomBackground(); } else { // 没有背景了，使用默认背景 console.log('[归墟背景] 所有用户背景已清除，使用默认背景'); const container = document.querySelector(\\'$1\\'); if (container) { const defaultBackgrounds = [ 'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png', 'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png', ]; const bgUrl = defaultBackgrounds[Math.floor(Math.random() * defaultBackgrounds.length)]; container.style.backgroundImage = `url('${bgUrl}')`; } } // 刷新背景列表显示 if (document.getElementById('background-settings-modal') && document.getElementById('background-settings-modal').style.display === 'flex') { this.renderBackgroundList(); this.updateBackgroundModeUI(); // 更新模式UI } } }, // 初始化背景图系统 initBackgroundSystem() { console.log('[归墟背景] 初始化背景图系统...'); // 首先加载背景图设置 this.loadBackgroundSettings(); console.log('[归墟背景] 已加载背景图设置，当前图片数量:', this.backgroundImages.length); // 加载透明度设置 this.loadOpacitySettings(); console.log('[归墟透明度] 已加载透明度设置，当前透明度:', this.mainOpacity + '%'); // 加载文字设置 this.loadTextSettings(); console.log('[归墟文字设置] 已加载文字设置'); // 清理过期的字体缓存 this.cleanupExpiredFontCache(); // 如果没有用户背景图，添加预设背景图 if ($1 === $2) { console.log('[归墟背景] 没有用户背景图，添加预设背景图'); this.backgroundImages = [ { id: 'preset1', name: '仙境云海', dataUrl: 'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png', isPreset: true }, { id: 'preset2', name: '古风山水', dataUrl: 'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png', isPreset: true } ]; this.saveBackgroundSettings(); console.log('[归墟背景] 预设背景图已添加并保存'); } // 应用背景图 this.applyRandomBackground(); console.log('[归墟背景] 背景图系统初始化完成'); }, async executeQuickSend() { const input = document.getElementById('quick-send-input'); if (!$1) return; const userMessage = input.value.trim(); if (userMessage) { this.saveInputToHistory(userMessage); // 发送时保存到历史 } await this.handleAction(userMessage); }, // 新增：处理所有动作的核心函数 async handleAction(userMessage = '') { const gameTextDisplay = document.getElementById('game-text-display'); if (gameTextDisplay) { this.lastValidGametxtHTML = gameTextDisplay.innerHTML; } const thinkingDisplay = document.getElementById('thinking-content-display'); if (thinkingDisplay) { thinkingDisplay.style.display = 'none'; } this.lastExtractedThinking = null; this.saveLastThinking(); // 清除持久化存储 this.updateThinkingButtonVisibility(); document.getElementById('action-options-container').innerHTML = ''; // 隐藏行动选项 this.hideVariableChangesReminder(); // 隐藏变量改变提醒 this.isStreamingGametxt = false; // 重置流式状态 // 1. 整合输入 let commandText = ''; if (this.pendingActions.length> 0) { commandText += '[本轮行动指令]\\n'; this.pendingActions.forEach(cmd => { let actionText = ''; switch (cmd.action) { case 'equip': actionText = `装备 [${cmd.itemName}] 到 [${cmd.category}] 槽位。`; break; case 'unequip': actionText = `卸下 [${cmd.itemName}] 从 [${cmd.category}] 槽位。`; break; case 'use': actionText = `使用 ${cmd.quantity} 个 [${cmd.itemName}]。`; break; case 'discard': if (cmd.quantity && cmd.quantity> 1) { actionText = `丢弃 ${cmd.quantity} 个 [${cmd.itemName}]。`; } else { actionText = `丢弃 [${cmd.itemName}]。`; } break; case 'travel': // 新增 actionText = `前往地点：[${cmd.locationName}]`; break; case 'do_action': // 新增 actionText = `选择行动：${cmd.text}`; break; } if (actionText) { commandText += `- ${actionText}\\n`; } }); } if (!$1) { this.showTemporaryMessage('请输入回复或添加指令后发送。'); return; } // 2. 构建 GenerateConfig 对象 const generateConfig = { injects: [], should_stream: this.isStreamingEnabled, // 修改：使用状态变量 }; // 将用户输入和指令合并为一个 user-role 注入 let combinedContent = ''; if (commandText) { combinedContent += commandText + '\\n'; // 指令在前 } if (userMessage) { combinedContent += `<行动选择>\\n${userMessage}\\n</行动选择>`; } if (combinedContent) { generateConfig.injects.push({ role: 'user', content: combinedContent, position: 'in_chat', // 插入到聊天记录中 depth: 0, should_scan: true, // 允许扫描关键字 }); } this.lastSentPrompt = combinedContent; // 更新调试信息 // 新增：控制台发送内容报告 console.group('🚀 [归墟] 本次发送内容报告'); console.log('📤 发送时间:', new Date().toLocaleString('zh-CN')); console.log('🎯 流式模式:', this.isStreamingEnabled ? '开启' : '关闭'); if (commandText) { console.log('⚡ 指令内容:'); console.log(commandText); } if (userMessage) { console.log('💬 用户输入:'); console.log(userMessage); } console.log('📋 完整发送内容:'); console.log(combinedContent); console.log('🔧 GenerateConfig:'); console.log(generateConfig); console.groupEnd(); this.showWaitingMessage(); try { // 3. 调用 generate，它现在不会立即返回最终结果 await TavernHelper.generate(generateConfig); // 后续处理已移至 handleStreamEnd } catch (error) { console.error('处理动作时出错:', error); this.showTemporaryMessage(`和伟大梦星沟通失败: ${error.message}`); this.hideWaitingMessage(); // 确保隐藏等待消息 } }, async handleMapUpdateCommand(commandContent) { console.log('[归墟地图] 检测到地图更新指令:', commandContent); // this.showTemporaryMessage('正在更新玄昊界地图...', 2000); // 用户要求静默处理 const bookName = '1归墟'; const mapEntryKey = '地图'; try { // 1. 读取当前地图数据 const allEntries = await TavernHelper.getLorebookEntries(bookName); const mapEntry = allEntries.find(entry => entry.comment === mapEntryKey); if (!$1) { throw new Error(`在世界书 \"${bookName}\" 中未找到名为 \"${mapEntryKey}\" 的条目。`); } let currentLocations = this.parseMapData(mapEntry.content || ''); let modified = false; // 2. 使用正则表达式解析所有指令 const updateRegex = /<更新>([\\s\\S]*?)<\\/更新>/g; const addRegex = /<新增>([\\s\\S]*?)<\\/新增>/g; const deleteRegex = /<删除>([\\s\\S]*?)<\\/删除>/g; let match; // 处理所有删除指令 while ((match = deleteRegex.exec(commandContent)) !== null) { const namesToDelete = match[1].trim().replace(/[\\[\\]]/g, '').split(',').map(name => name.trim()); const initialLength = currentLocations.length; currentLocations = currentLocations.filter(loc => !namesToDelete.includes(loc.name)); if(currentLocations.length <initialLength) modified = true; console.log('[归墟地图] 已删除:', namesToDelete); } // 处理所有更新指令 while ((match = updateRegex.exec(commandContent)) !== null) { const updates = this.parseMapData(match[1].trim()); updates.forEach(update => { const index = currentLocations.findIndex(loc => loc.name === update.name); if ($1 === $2) { Object.assign(currentLocations[index], update); modified = true; console.log('[归墟地图] 已更新:', update); } }); } // 处理所有新增指令 while ((match = addRegex.exec(commandContent)) !== null) { const newLocations = this.parseMapData(match[1].trim()); newLocations.forEach(newLoc => { if ($1 === $2)) { currentLocations.push(newLoc); modified = true; console.log('[归墟地图] 已新增:', newLoc); } }); } // 3. 仅当数据有变化时才写回 if (modified) { const newContent = currentLocations.map(loc => { const parts = [`${loc.name}`]; // 保证坐标在前 if ($1 === $2) parts.push(`x:${loc.x}`); if ($1 === $2) parts.push(`y:${loc.y}`); if ($1 === $2) parts.push(`z:${loc.z}`); for (const [key, value] of Object.entries(loc)) { if ($1 === $2) { parts.push(`${key}:${value}`); } } return `[${parts.join('|')}]`; }).join('\\n'); // 4. 写回世界书 await TavernHelper.setLorebookEntries(bookName, [{ uid: mapEntry.uid, content: newContent }]); // this.showTemporaryMessage('地图已更新！'); // 用户要求静默处理 // 5. 如果地图是打开的，则刷新它 if ($1 === $2) { const stat_data = this.currentMvuState?.stat_data; const playerPos = stat_data ? this.SafeGetValue(stat_data, '当前位置', null) : null; this.renderMap(document.getElementById('map-modal-body'), currentLocations, playerPos); } } else { console.log('[归墟地图] 地图数据无变化，跳过写入。'); } } catch (error) { console.error('处理地图更新指令时出错:', error); // this.showTemporaryMessage(`地图更新失败: ${error.message}`); // 用户要求静默处理 } }, // --- 新增：地图交互事件处理 --- bindMapEvents(container) { // 事件直接绑定在最外层容器上，但操作的是内层 map-container const mapContainer = container.querySelector('.map-container'); if (!$1) return; // 使用 .bind(this) 确保函数内的 this 指向 GuixuManager const handleWheel = this.handleMapWheel.bind(this); const handleMouseDown = this.handleMapMouseDown.bind(this); const handleMouseMove = this.handleMapMouseMove.bind(this); const handleMouseUp = this.handleMapMouseUp.bind(this); const handleMouseLeave = this.handleMapMouseLeave.bind(this); container.addEventListener('wheel', handleWheel, { passive: false }); container.addEventListener('mousedown', handleMouseDown); container.addEventListener('mousemove', handleMouseMove); container.addEventListener('mouseup', handleMouseUp); container.addEventListener('mouseleave',handleMouseLeave); // --- 新增：为触屏设备添加事件监听 --- const handleTouchStart = this.handleMapTouchStart.bind(this); const handleTouchMove = this.handleMapTouchMove.bind(this); const handleTouchEnd = this.handleMapTouchEnd.bind(this); container.addEventListener('touchstart', handleTouchStart, { passive: false }); container.addEventListener('touchmove', handleTouchMove, { passive: false }); container.addEventListener('touchend', handleTouchEnd); container.addEventListener('touchcancel', handleTouchEnd); // 新增：为缩放滑块绑定事件 const zoomSlider = document.getElementById('zoom-slider'); if (zoomSlider) { zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this)); } // 新增：为“回到玩家”按钮绑定事件 const centerBtn = document.getElementById('btn-center-player'); if (centerBtn) { centerBtn.addEventListener('click', this.centerOnPlayer.bind(this)); } }, updateMapTransform() { const mapContainer = document.querySelector(\\'$1\\'); if (mapContainer) { // 混合方案：拖动用 left/top，缩放用 transform。 // left/top 用于高频的拖动事件，避免 transform 导致的闪烁。 // scale 用于缩放。此函数现在是所有变换的唯一来源。 mapContainer.style.left = `${this.mapState.panX}px`; mapContainer.style.top = `${this.mapState.panY}px`; mapContainer.style.transform = `scale(${this.mapState.scale})`; } }, resetMapState() { this.mapState = { scale: 1, panX: 0, panY: 0, isPanning: false, startX: 0, startY: 0, animationFrameId: null }; this.updateMapTransform(); this.updateZoomSliderUI(); }, handleMapWheel(event) { event.preventDefault(); const scaleAmount = 0.1; const { clientX, clientY } = event; const containerRect = event.currentTarget.getBoundingClientRect(); const mouseX = clientX - containerRect.left; const mouseY = clientY - containerRect.top; const oldScale = this.mapState.scale; const newScale = event.deltaY> 0 ? Math.max(0.05, oldScale - scaleAmount) : Math.min(5, oldScale + scaleAmount); // 计算缩放中心，并调整panX和panY，使其在视觉上以鼠标为中心缩放 this.mapState.panX = mouseX - (mouseX - this.mapState.panX) * (newScale / oldScale); this.mapState.panY = mouseY - (mouseY - this.mapState.panY) * (newScale / oldScale); this.mapState.scale = newScale; this.updateMapTransform(); this.updateZoomSliderUI(); // 同步滑块UI }, handleMapMouseDown(event) { event.preventDefault(); this.mapState.isPanning = true; this.mapState.startX = event.clientX - this.mapState.panX; this.mapState.startY = event.clientY - this.mapState.panY; }, handleMapMouseMove(event) { // 无论是否在拖动，都更新坐标显示 this.updateCursorCoords(event); if (this.mapState.isPanning) { event.preventDefault(); this.mapState.panX = event.clientX - this.mapState.startX; this.mapState.panY = event.clientY - this.mapState.startY; // 使用 requestAnimationFrame 优化拖动性能，防止屏闪 if (!$1) { this.mapState.animationFrameId = requestAnimationFrame(() => { this.updateMapTransform(); this.mapState.animationFrameId = null; // 重置ID，允许下一次请求 }); } } }, handleMapMouseUp(event) { this.mapState.isPanning = false; // 停止拖动时，取消任何挂起的动画帧，以防止不必要的一次性更新 if (this.mapState.animationFrameId) { cancelAnimationFrame(this.mapState.animationFrameId); this.mapState.animationFrameId = null; } }, handleMapMouseLeave(event) { // 鼠标离开时，清除坐标显示 this.updateCursorCoords(event, true); this.mapState.isPanning = false; if (this.mapState.animationFrameId) { cancelAnimationFrame(this.mapState.animationFrameId); this.mapState.animationFrameId = null; } }, // --- 新增：触屏事件处理函数 --- handleMapTouchStart(event) { if ($1 === $2) { // 只处理单指拖动 event.preventDefault(); const touch = event.touches[0]; this.mapState.isPanning = true; this.mapState.startX = touch.clientX - this.mapState.panX; this.mapState.startY = touch.clientY - this.mapState.panY; } }, handleMapTouchMove(event) { if ($1 === $2) { event.preventDefault(); const touch = event.touches[0]; this.mapState.panX = touch.clientX - this.mapState.startX; this.mapState.panY = touch.clientY - this.mapState.startY; if (!$1) { this.mapState.animationFrameId = requestAnimationFrame(() => { this.updateMapTransform(); this.mapState.animationFrameId = null; }); } } }, handleMapTouchEnd(event) { this.mapState.isPanning = false; if (this.mapState.animationFrameId) { cancelAnimationFrame(this.mapState.animationFrameId); this.mapState.animationFrameId = null; } }, updateZoomSliderUI() { const slider = document.getElementById('zoom-slider'); const display = document.getElementById('zoom-level-display'); if (slider && display) { slider.value = this.mapState.scale; display.textContent = `${Math.round(this.mapState.scale * 100)}%`; } }, handleZoomSlider(event) { const newScale = parseFloat(event.target.value); if (!$1)) { // 当通过滑块缩放时，以视图中心为缩放点 const containerRect = document.querySelector(\\'$1\\').getBoundingClientRect(); const centerX = containerRect.width / 2; const centerY = containerRect.height / 2; const oldScale = this.mapState.scale; this.mapState.panX = centerX - (centerX - this.mapState.panX) * (newScale / oldScale); this.mapState.panY = centerY - (centerY - this.mapState.panY) * (newScale / oldScale); this.mapState.scale = newScale; this.updateMapTransform(); this.updateZoomSliderUI(); // 仅更新百分比显示 } }, // --- 新增：地图坐标和居中功能 --- updateCursorCoords(event, clear = false) { const display = document.getElementById('cursor-coords-display'); if (!$1) return; if (clear) { display.textContent = 'x: ---, y: ---'; return; } const container = document.querySelector(\\'$1\\'); const containerRect = container.getBoundingClientRect(); const scale = this.mapState.scale; const panX = this.mapState.panX; const panY = this.mapState.panY; // 1. 鼠标在视口（map-modal-body）内的坐标 const mouseX = event.clientX - containerRect.left; const mouseY = event.clientY - containerRect.top; // 2. 逆向计算鼠标在缩放前、平移前的位置 const mapMouseX = (mouseX - panX) / scale; const mapMouseY = (mouseY - panY) / scale; // 3. 逆向计算相对于地图中心 (50%, 50%) 的偏移量 const mapContainer = container.querySelector('.map-container'); const mapRect = mapContainer.getBoundingClientRect(); const mapCenterX = mapRect.width / 2; const mapCenterY = mapRect.height / 2; const offsetX = mapMouseX - mapCenterX; const offsetY = mapMouseY - mapCenterY; // 4. 将像素偏移量转换回世界坐标 const SCALE_FACTOR = 100; // 与renderMap中保持一致 const worldX = Math.round(offsetX * SCALE_FACTOR); const worldY = Math.round(offsetY * SCALE_FACTOR); display.textContent = `x: ${worldX}, y: ${worldY}`; }, centerOnPlayer() { if (!$1) { this.showTemporaryMessage(\"未找到玩家当前位置。\"); return; } const container = document.querySelector(\\'$1\\'); const containerRect = container.getBoundingClientRect(); const targetScale = 1.0; // 回到100%缩放 // 目标：将 this.mapState.playerMapPos (玩家像素坐标) 移动到视口中心 const targetX = containerRect.width / 2; const targetY = containerRect.height / 2; // 计算需要的 panX 和 panY // panX = targetX - (playerX * scale) // panY = targetY - (playerY * scale) this.mapState.scale = targetScale; this.mapState.panX = targetX - (this.mapState.playerMapPos.x * targetScale); this.mapState.panY = targetY - (this.mapState.playerMapPos.y * targetScale); this.updateMapTransform(); this.updateZoomSliderUI(); this.showTemporaryMessage(\"已回到当前位置\"); }, addTravelAction(location) { if (!$1) return; // 添加到指令队列 this.pendingActions.push({ action: 'travel', locationName: location.name, }); this.savePendingActions(); this.showTemporaryMessage(`已将 [前往 ${location.name}] 加入指令中心`); this.closeAllModals(); // 关闭地图，返回主界面 }, // --- 新增：快速指令列表相关函数 --- toggleQuickCommands() { const popup = document.getElementById('quick-command-popup'); if (!$1) return; if ($1 === $2) { this.hideQuickCommands(); } else { this.showQuickCommands(); } }, showQuickCommands() { const popup = document.getElementById('quick-command-popup'); if (!$1) return; if ($1 === $2) { popup.innerHTML = '<div class=\"$1\">暂无待执行的指令</div>'; } else { let listHtml = '<ul class=\"$1\">'; this.pendingActions.forEach(cmd => { let actionText = ''; switch (cmd.action) { case 'equip': actionText = `装备 [${cmd.itemName}] 到 [${cmd.category}] 槽位。`; break; case 'unequip': actionText = `卸下 [${cmd.itemName}] 从 [${cmd.category}] 槽位。`; break; case 'use': actionText = `使用 ${cmd.quantity} 个 [${cmd.itemName}]。`; break; case 'discard': if (cmd.quantity && cmd.quantity> 1) { actionText = `丢弃 ${cmd.quantity} 个 [${cmd.itemName}]。`; } else { actionText = `丢弃 [${cmd.itemName}]。`; } break; } // 列表项不再需要data-command属性 listHtml += `<li class=\"$1\">${actionText}</li>`; }); listHtml += '</ul>'; popup.innerHTML = listHtml; } popup.style.display = 'block'; }, hideQuickCommands() { const popup = document.getElementById('quick-command-popup'); if (popup) { popup.style.display = 'none'; } }, // --- 核心重构：前端备用MVU处理器 --- // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 _applyUpdateFallback(script, currentMvuState) { if (!$1) return null; const newState = _.cloneDeep(currentMvuState); let modified = false; const commands = this._extractCommands(script); for (const command of commands) { try { const path = this._trimQuotes(command.args[0]); switch (command.command) { case 'set': { const newValueStr = command.args.length>= 2 ? command.args[1] : undefined; if ($1 === $2) continue; let newValue = this._parseCommandValue(newValueStr); if (newValue instanceof Date) newValue = newValue.toISOString(); _.set(newState.stat_data, path, newValue); modified = true; break; } case 'add': { const value = _.get(newState.stat_data, path); const delta = this._parseCommandValue(command.args[1]); if ($1 === $2) { _.set(newState.stat_data, path, value + delta); modified = true; } break; } case 'remove': { _.unset(newState.stat_data, path); modified = true; break; } case 'assign': case 'insert': { if ($1 === $2) { // Handles _.assign('path', value) const valueToAssign = this._parseCommandValue(command.args[1]); const parentCollection = _.get(newState.stat_data, path); // Special handling for our [data_array, \"description\"] structure if ($1 === $2) && typeof parentCollection[1] === 'string') { const innerArray = parentCollection[0]; const description = parentCollection[1]; const newInnerArray = innerArray.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]); const newParentArray = [newInnerArray, description]; _.set(newState.stat_data, path, newParentArray); modified = true; } else if (Array.isArray(parentCollection)) { // Standard immutable update for regular arrays const newCollection = parentCollection.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]); _.set(newState.stat_data, path, newCollection); modified = true; } else if (_.isObject(parentCollection)) { // Merge for objects _.merge(parentCollection, valueToAssign); modified = true; } else { // If path doesn't exist, just set it _.set(newState.stat_data, path, valueToAssign); modified = true; } } else if (command.args.length>= 3) { // Handles _.assign('path', key, value) const keyOrIndex = this._parseCommandValue(command.args[1]); const valueToAssign = this._parseCommandValue(command.args[2]); let collection = _.get(newState.stat_data, path); if (Array.isArray(collection)) { if ($1 === $2) { const newCollection = [...collection]; // Create a shallow copy for immutability newCollection.splice(keyOrIndex, 0, valueToAssign); _.set(newState.stat_data, path, newCollection); modified = true; } } else if (_.isObject(collection)) { _.set(collection, String(keyOrIndex), valueToAssign); modified = true; } else { // If collection doesn't exist, create it const newCollection = {}; _.set(newCollection, String(keyOrIndex), valueToAssign); _.set(newState.stat_data, path, newCollection); modified = true; } } break; } } } catch (e) { console.error(`[归墟-备用方案] 处理指令失败:`, command, e); } } return modified ? newState : null; }, // --- 内部辅助函数，从 function.ts 移植 --- _trimQuotes(str) { if ($1 === $2) return str; return str.replace(/^['\"` ]*(.*?)['\"` ]*$/, '$1'); }, _parseCommandValue(valStr) { if ($1 === $2) return valStr; const trimmed = valStr.trim(); if ($1 === $2) return true; if ($1 === $2) return false; if ($1 === $2) return null; if ($1 === $2) return undefined; try { return JSON.parse(trimmed); } catch (e) { if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']'))) { try { return new Function(`return ${trimmed};`)(); } catch (err) { /* continue */ } } } return this._trimQuotes(valStr); }, _extractCommands(inputText) { const results = []; let i = 0; while (i <inputText.length) { const match = inputText.substring(i).match(/_\\.(set|assign|remove|add|insert)\\(/); if ($1 === $2) break; const commandType = match[1]; const start = i + match.index; const openParen = start + match[0].length; const closeParen = this._findMatchingCloseParen(inputText, openParen); if ($1 === $2) { i = openParen; continue; } let endPos = closeParen + 1; if ($1 === $2) { i = closeParen + 1; continue; } endPos+; const paramsString = inputText.substring(openParen, closeParen); const params = this._parseParameters(paramsString); results.push({ command: commandType, args: params }); i = endPos; } return results; }, _findMatchingCloseParen(str, startPos) { let parenCount = 1; let inQuote = false; let quoteChar = ''; for (let i = startPos; i <str.length; i+) { const char = str[i]; if ($1 === $2) && str[i - 1] !== '\\\\') { if (!$1) { inQuote = true; quoteChar = char; } else if ($1 === $2) { inQuote = false; } } if (!$1) { if ($1 === $2) parenCount+; else if ($1 === $2)') { parenCount--; if ($1 === $2) return i; } } } return -1; }, _parseParameters(paramsString) { const params = []; let currentParam = ''; let inQuote = false; let quoteChar = ''; let bracketCount = 0; let braceCount = 0; let parenCount = 0; for (let $1 = 0; $1 <$2; $1+) { const char = paramsString[i]; if ($1 === $2) && (i === 0 || paramsString[i - 1] !== '\\\\')) { if (!$1) { inQuote = true; quoteChar = char; } else if ($1 === $2) { inQuote = false; } } if (!$1) { if ($1 === $2) parenCount+; if ($1 === $2)') parenCount--; if ($1 === $2) bracketCount+; if ($1 === $2) bracketCount--; if ($1 === $2) braceCount+; if ($1 === $2) braceCount--; } if ($1 === $2) { params.push(currentParam.trim()); currentParam = ''; continue; } currentParam += char; } if (currentParam.trim()) { params.push(currentParam.trim()); } return params; }, // --- 新增：文本净化辅助函数 --- _getDisplayText(aiResponse) { try { if ($1 === $2) return ''; // 优先提取 <gametxt> 的内容 const gameText = this._extractLastTagContent('gametxt', aiResponse); if ($1 === $2) { // 新增：移除HTML注释，修复因注释导致的存档逻辑崩溃问题 return gameText.replace(new RegExp('<!--[\\\\s\\\\S]*?-->', 'g'), '').trim(); } // 备用方案：如果找不到 <gametxt>，则移除所有已知的非显示标签 let cleanedText = aiResponse; const tagsToRemove = ['本世历程', '往世涟漪', 'UpdateVariable', '角色提取', 'action', '行动选项']; tagsToRemove.forEach(tag => { // 移除 <tag>...</tag> 结构 const regexWithContent = new RegExp(`<${tag}>[\\\\s\\\\S]*?<\\\\/${tag}>`, 'gi'); cleanedText = cleanedText.replace(regexWithContent, ''); // 移除自闭合的 <tag/> 结构 const regexSelfClosing = new RegExp(`<${tag}\\\\s*\\\\/>`, 'gi'); cleanedText = cleanedText.replace(regexSelfClosing, ''); }); return cleanedText.trim(); } catch (e) { console.error(\"解析显示文本时出错:\", e, \"原始输入:\", aiResponse); return \"[摘要解析失败]\"; } }, // --- 新增：可重用的、健壮的标签提取函数 --- _extractLastTagContent(tagName, text, ignoreCase = false) { if ($1 === $2) return null; const flags = ignoreCase ? 'gi' : 'g'; const regex = new RegExp(`<${tagName}>([\\\\s\\\\S]*?)<\\\\/${tagName}>`, flags); const matches = [...text.matchAll(regex)]; if (matches.length> 0) { // 返回最后一个匹配项的内容 return matches[matches.length - 1][1].trim(); } return null; }, // --- 新增：MVU语法解析和中文转义 --- parseMvuCommands(mvuText) { if ($1 === $2) return []; const changes = []; const lines = mvuText.split('\\n'); for (const line of lines) { const trimmedLine = line.trim(); if (!$1) || trimmedLine.startsWith('<') || trimmedLine.startsWith('</')) { continue; } // 解析 _.set 命令 (支持2参数和3参数格式) let setMatch = trimmedLine.match(/^_\\.set\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]\\s*,\\s*([^,)]+)(?:\\s*,\\s*([^)]+))?\\)\\s*;?\\s*(?:\\/\\/(.*))?$/); if (setMatch) { const [, path, param2, param3, comment] = setMatch; let oldValue, newValue; if ($1 === $2) { // 三参数格式: _.set(path, oldValue, newValue) oldValue = this.formatValue(param2); newValue = this.formatValue(param3); } else { // 二参数格式: _.set(path, newValue) oldValue = '未知'; newValue = this.formatValue(param2); } changes.push({ type: 'set', path: this.translatePath(path), oldValue: oldValue, newValue: newValue, comment: comment ? comment.trim() : '', description: oldValue !== '未知' ? `设置 ${this.translatePath(path)} 从 ${oldValue} 变为 ${newValue}` : `设置 ${this.translatePath(path)} 为 ${newValue}` }); continue; } // 解析 _.add 命令 const addMatch = trimmedLine.match(/^_\\.add\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]\\s*,\\s*([^)]+)\\)\\s*;?\\s*(?:\\/\\/(.*))?$/); if (addMatch) { const [, path, delta, comment] = addMatch; const deltaValue = this.formatValue(delta); changes.push({ type: 'add', path: this.translatePath(path), delta: deltaValue, comment: comment ? comment.trim() : '', description: `${this.translatePath(path)} 增加 ${deltaValue}` }); continue; } // 解析 _.assign 命令 (支持2参数和3参数格式) const assignMatch = trimmedLine.match(/^_\\.assign\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]\\s*,\\s*([^,)]+)(?:\\s*,\\s*([^)]+))?\\)\\s*;?\\s*(?:\\/\\/(.*))?$/); if (assignMatch) { const [, path, param2, param3, comment] = assignMatch; let key, value, description; if ($1 === $2) { // 三参数格式: _.assign(path, key, value) key = this.formatValue(param2); value = this.formatValue(param3); description = `向 ${this.translatePath(path)} 添加 ${key}: ${value}`; } else { // 二参数格式: _.assign(path, value) 或 _.assign(path, key) const formattedValue = this.formatValue(param2); // 尝试判断是否为对象格式 if (param2.trim().startsWith('{') || param2.trim().startsWith('[')) { description = `向 ${this.translatePath(path)} 添加复杂对象`; key = '对象'; value = formattedValue; } else { // 简单值，可能是数组元素或对象键 key = formattedValue; value = ''; description = `向 ${this.translatePath(path)} 添加 ${formattedValue}`; } } changes.push({ type: 'assign', path: this.translatePath(path), key: key, value: value, comment: comment ? comment.trim() : '', description: description }); continue; } // 解析 _.remove 命令 const removeMatch = trimmedLine.match(/^_\\.remove\\s*\\(\\s*['\"`]([^'\"`]+)['\"`](?:\\s*,\\s*([^)]+))?\\)\\s*;?\\s*(?:\\/\\/(.*))?$/); if (removeMatch) { const [, path, target, comment] = removeMatch; const targetValue = target ? this.formatValue(target) : ''; changes.push({ type: 'remove', path: this.translatePath(path), target: targetValue, comment: comment ? comment.trim() : '', description: `从 ${this.translatePath(path)} 移除${targetValue ? ' ' + targetValue : '内容'}` }); continue; } } return changes; }, // 路径翻译：将英文路径转换为中文描述 translatePath(path) { const translations = { '当前境界': '当前境界', '境界映射': '境界映射', '修为进度': '修为进度', '修为瓶颈': '修为瓶颈', '法力': '法力上限', '当前法力': '当前法力', '神海': '神海上限', '当前神海': '当前神海', '道心': '道心上限', '当前道心': '当前道心', '空速': '空速上限', '当前空速': '当前空速', '气运': '气运', '生理年龄': '生理年龄', '心理年龄': '心理年龄', '当前时间纪年': '当前时间', '归墟充能时间': '归墟充能', '天赋列表': '天赋', '灵根列表': '灵根', '武器列表': '武器', '防具列表': '防具', '饰品列表': '饰品', '法宝列表': '法宝', '丹药列表': '丹药', '其他列表': '其他物品', '人物关系列表': '人物关系', '当前状态': '状态效果', '当前位置': '当前位置' }; // 处理数组索引 [0] 等 let translatedPath = path.replace(/\\[0\\]/g, ''); // 逐段翻译路径 const segments = translatedPath.split('.'); const translatedSegments = segments.map(segment => { return translations[segment] || segment; }); return translatedSegments.join(' → '); }, // 格式化数值显示 formatValue(value) { if ($1 === $2) { // 移除引号 const cleaned = value.replace(/^['\"`]|['\"`]$/g, ''); return cleaned; } return String(value); }, // --- 新增：变量改变提醒功能 --- updateVariableChangesReminder() { if (!$1) { this.hideVariableChangesReminder(); return; } const changes = this.parseMvuCommands(this.lastExtractedVariables); if ($1 === $2) { this.hideVariableChangesReminder(); return; } this.showVariableChangesReminder(changes); }, showVariableChangesReminder(changes) { const reminder = document.getElementById('variable-changes-reminder'); const count = document.getElementById('variable-changes-count'); const content = document.getElementById('variable-changes-content'); if (!$1) return; // 更新计数 count.textContent = changes.length; // 生成变量改变内容 const changesHtml = changes.map(change => { const typeText = { 'set': '设置', 'add': '增加', 'assign': '添加', 'remove': '移除' }[change.type] || change.type; return ` <div class=\"$1\"><div class=\"$1\"><span class=\"$1\">${typeText}</span> ${change.description} </div> ${change.comment ? `<div class=\"$1\">${change.comment}</div>` : ''} </div> `; }).join(''); content.innerHTML = changesHtml; reminder.style.display = 'block'; }, hideVariableChangesReminder() { const reminder = document.getElementById('variable-changes-reminder'); if (reminder) { reminder.style.display = 'none'; } }, toggleVariableChanges() { const content = document.getElementById('variable-changes-content'); const icon = document.getElementById('variable-changes-icon'); if (!$1) return; const isExpanded = content.classList.contains('expanded'); if (isExpanded) { content.classList.remove('expanded'); icon.classList.add('collapsed'); icon.textContent = '▶'; } else { content.classList.add('expanded'); icon.classList.remove('collapsed'); icon.textContent = '▼'; } }, // --- 新增：思维过程显示/隐藏 --- toggleThinkingDisplay() { const display = document.getElementById('thinking-content-display'); const btn = document.getElementById('btn-toggle-thinking'); if (display && btn) { if ($1 === $2) { if (this.lastExtractedThinking) { // Use textContent to display raw text and rely on CSS `white-space: pre-wrap` display.textContent = this.lastExtractedThinking; display.style.display = 'block'; btn.textContent = '隐藏思维过程'; } } else { display.style.display = 'none'; btn.textContent = '查看思维过程'; } } }, updateThinkingButtonVisibility() { const btn = document.getElementById('btn-toggle-thinking'); if (btn) { if (this.lastExtractedThinking) { btn.style.display = 'inline-block'; } else { btn.style.display = 'none'; } } }, // --- 新增：思维过程持久化 --- saveLastThinking() { try { if (this.lastExtractedThinking) { localStorage.setItem('guixu_last_thinking', this.lastExtractedThinking); } else { localStorage.removeItem('guixu_last_thinking'); } } catch (e) { console.error('保存思维过程失败:', e); } }, loadLastThinking() { try { this.lastExtractedThinking = localStorage.getItem('guixu_last_thinking') || null; } catch (e) { console.error('加载思维过程失败:', e); this.lastExtractedThinking = null; } }, // --- 新增：多存档管理功能 --- showSaveLoadManager() { this.openModal('save-load-modal'); const manualContainer = document.getElementById('save-slots-container'); const autoContainer = document.getElementById('auto-save-slot-container'); if (!$1) return; let saves; try { saves = this.getSavesFromStorage(); } catch (e) { console.error(\"解析整个存档文件失败，可能是JSON格式错误:\", e); manualContainer.innerHTML = `<div style=\"\"><p>错误：主存档文件已损坏。</p></div>`; autoContainer.innerHTML = ''; return; } // 1. 渲染自动存档槽位 (双缓冲) let autoSaveHtml = ''; const autoSaveSlots = [ { id: 'auto_save_slot_0', name: '最新自动存档', color: '#66CDAA' }, { id: 'auto_save_slot_1', name: '上一次自动存档', color: '#FFD700' } ]; autoSaveSlots.forEach(slotInfo => { const autoSaveData = saves[slotInfo.id]; autoSaveHtml += `<div class=\"$1\" data-$1=\"$2\">`; if (autoSaveData && autoSaveData.mvu_data) { const date = new Date(autoSaveData.timestamp).toLocaleString('zh-CN'); const statDataForRender = autoSaveData.mvu_data.stat_data || (autoSaveData.mvu_data['当前境界'] ? autoSaveData.mvu_data : null); const jingjie = this.SafeGetValue(statDataForRender, '当前境界', '未知'); const jinian = this.SafeGetValue(statDataForRender, '当前时间纪年', '未知'); const summary = this._getDisplayText(autoSaveData.message_content); autoSaveHtml += ` <div class=\"$1\"><div class=\"$1\" style=\"\">${slotInfo.name}</div><div class=\"$1\">${date} - ${jingjie} - ${jinian}</div><div class=\"$1\">${summary ? summary.substring(0, 40) + '...' : '无正文记录'}</div></div><div class=\"$1\"><button class=\"$1\" style=\"\">读档</button><button class=\"$1\" style=\"\">导出</button><button class=\"$1\" style=\"\">删除</button></div> `; } else { autoSaveHtml += ` <div class=\"$1\"><div class=\"$1\" style=\"\">${slotInfo.name}</div><div class=\"$1\" style=\"\">无自动存档记录</div></div><div class=\"$1\"><button class=\"$1\" style=\"\" disabled>读档</button><button class=\"$1\" style=\"\" disabled>导出</button><button class=\"$1\" style=\"\" disabled>删除</button></div> `; } autoSaveHtml += `</div>`; }); autoContainer.innerHTML = autoSaveHtml; // 2. 渲染手动存档槽位 let manualHtml = ''; const totalSlots = 5; for (let i = 1; i <= totalSlots; i+) { const slotId = `slot_${i}`; const saveData = saves[slotId]; manualHtml += `<div class=\"$1\" data-$1=\"$2\"><div class=\"$1\">`; let statDataForRender = null; if ($1 === $2) { statDataForRender = saveData.mvu_data.stat_data || (saveData.mvu_data['当前境界'] ? saveData.mvu_data : null); } if (statDataForRender) { const date = new Date(saveData.timestamp).toLocaleString('zh-CN'); const jingjie = this.SafeGetValue(statDataForRender, '当前境界', '未知'); const jinian = this.SafeGetValue(statDataForRender, '当前时间纪年', '未知'); const summary = this._getDisplayText(saveData.message_content); const saveName = saveData.save_name || `存档 ${i}`; manualHtml += ` <div class=\"$1\">${saveName}</div><div class=\"$1\">${date} - ${jingjie} - ${jinian}</div><div class=\"$1\">${summary ? summary.substring(0, 40) + '...' : '无正文记录'}</div> `; } else { manualHtml += ` <div class=\"$1\">存档 ${i}</div><div class=\"$1\" style=\"\">空存档位</div> `; } manualHtml += `</div><div class=\"$1\"><button class=\"$1\" style=\"\">存档</button><button class=\"$1\" style=\"\" ${!saveData ? 'disabled' : ''}>读档</button><button class=\"$1\" style=\"\" ${!saveData ? 'disabled' : ''}>导出</button><button class=\"$1\" style=\"\" ${!saveData ? 'disabled' : ''}>删除</button></div></div>`; } manualContainer.innerHTML = manualHtml; }, getSavesFromStorage() { try { const saves = localStorage.getItem('guixu_multi_save_data'); return saves ? JSON.parse(saves) : {}; } catch (e) { console.error(\"获取存档失败:\", e); return {}; } }, async saveGame(slotId) { try { // 首先弹出输入框让用户命名存档 const saveName = await this.promptForSaveName(slotId); if (!$1) { this.showTemporaryMessage('存档已取消'); return; } const allSaves = this.getSavesFromStorage(); const slotExists = allSaves[slotId]; const performSave = async () => { try { // 修复：优先使用缓存的mvu状态，如果没有再从消息获取 let currentMvuData = this.currentMvuState; let currentMessageContent = ''; if (!$1) { console.log('[归墟存档] 缓存状态为空，尝试从消息获取...'); const messages = await getChatMessages(getCurrentMessageId()); if ($1 === $2) { this.showTemporaryMessage('错误：无法获取当前消息数据，无法存档。'); return; } currentMvuData = messages[0].data; currentMessageContent = messages[0].message || ''; } else { // 如果有缓存状态，也尝试获取当前消息内容 try { const messages = await getChatMessages(getCurrentMessageId()); if (messages && messages.length> 0) { currentMessageContent = messages[0].message || ''; } } catch (e) { console.warn('[归墟存档] 获取消息内容失败，使用空内容:', e); } } if (!$1) { this.showTemporaryMessage('错误：MVU数据不完整，无法存档。请先进行一次游戏操作。'); return; } console.log('[归墟存档] 开始存档，数据检查通过'); // --- 新逻辑：创建独立的世界书条目 --- const bookName = '1归墟'; const index = this.unifiedIndex; const journeyKey = index> 1 ? `本世历程(${index})` : '本世历程'; const pastLivesKey = index> 1 ? `往世涟漪(${index})` : '往世涟漪'; // 生成独立世界书条目名称 const saveJourneyEntryName = `${saveName}-本世历程`; const savePastLivesEntryName = `${saveName}-往世涟漪`; const novelModeIndex = this.novelModeIndex; const novelModeKey = novelModeIndex> 1 ? `小说模式(${novelModeIndex})` : '小说模式'; const saveNovelModeEntryName = `${saveName}-小说模式`; let lorebookEntries = { journey_entry_name: saveJourneyEntryName, past_lives_entry_name: savePastLivesEntryName, novel_mode_entry_name: saveNovelModeEntryName }; try { const allEntries = await TavernHelper.getLorebookEntries(bookName); const journeyEntry = allEntries.find(entry => entry.comment === journeyKey); const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey); const novelModeEntry = allEntries.find(entry => entry.comment === novelModeKey); // 创建独立的世界书条目 const entriesToCreate = []; // 修复：即使内容为空也创建条目，避免存档失败 if (journeyEntry) { entriesToCreate.push({ comment: saveJourneyEntryName, content: journeyEntry.content || '', // 允许空内容 keys: [saveJourneyEntryName], enabled: false, // 默认禁用 position: 'before_character_definition', order: 20 }); console.log(`[归墟存档] 准备创建本世历程条目，内容长度: ${(journeyEntry.content || '').length}`); } else { // 如果找不到原始条目，创建一个空的 entriesToCreate.push({ comment: saveJourneyEntryName, content: '# 本世历程\\n暂无记录', keys: [saveJourneyEntryName], enabled: false, position: 'before_character_definition', order: 20 }); console.log(`[归墟存档] 原始本世历程条目不存在，创建空条目`); } if (pastLivesEntry) { entriesToCreate.push({ comment: savePastLivesEntryName, content: pastLivesEntry.content || '', // 允许空内容 keys: [savePastLivesEntryName], enabled: false, // 默认禁用 position: 'before_character_definition', order: 19 }); console.log(`[归墟存档] 准备创建往世涟漪条目，内容长度: ${(pastLivesEntry.content || '').length}`); } else { // 如果找不到原始条目，创建一个空的 entriesToCreate.push({ comment: savePastLivesEntryName, content: '# 往世涟漪\\n暂无记录', keys: [savePastLivesEntryName], enabled: false, position: 'before_character_definition', order: 19 }); console.log(`[归墟存档] 原始往世涟漪条目不存在，创建空条目`); } if (novelModeEntry) { entriesToCreate.push({ comment: saveNovelModeEntryName, content: novelModeEntry.content || '', // 允许空内容 keys: [saveNovelModeEntryName], enabled: false, // 默认禁用 position: 'before_character_definition', order: 18 // Give it a different order }); console.log(`[归墟存档] 准备创建小说模式条目，内容长度: ${(novelModeEntry.content || '').length}`); } else { entriesToCreate.push({ comment: saveNovelModeEntryName, content: '# 小说模式\\n暂无记录', keys: [saveNovelModeEntryName], enabled: false, position: 'before_character_definition', order: 18 }); console.log(`[归墟存档] 原始小说模式条目不存在，创建空条目`); } if (entriesToCreate.length> 0) { await TavernHelper.createLorebookEntries(bookName, entriesToCreate); console.log(`[归墟存档] 已创建 ${entriesToCreate.length} 个独立世界书条目`); } } catch (e) { console.error(\"创建独立世界书条目时出错:\", e); this.showTemporaryMessage(\"警告：创建世界书条目失败，但主数据仍会保存。\"); } // --- 新逻辑结束 --- const saveDataPayload = { timestamp: new Date().toISOString(), save_name: saveName, // 新增：用户输入的存档名称 message_content: currentMessageContent, lorebook_entries: lorebookEntries, // 修改：改为世界书条目名称 mvu_data: { stat_data: currentMvuData.stat_data, schema: currentMvuData.schema, initialized_lorebooks: currentMvuData.initialized_lorebooks, display_data: currentMvuData.display_data, delta_data: currentMvuData.delta_data, } }; allSaves[slotId] = saveDataPayload; localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves)); this.showTemporaryMessage(`存档\"${saveName}\"已保存到存档位 ${slotId.split('_')[1]}`); this.showSaveLoadManager(); // 刷新UI } catch (error) { console.error('存档失败:', error); this.showTemporaryMessage(`存档失败: ${error.message}`); } }; if (slotExists) { this.showCustomConfirm(`存档位 ${slotId.split('_')[1]} 已有数据，确定要覆盖吗？`, performSave); } else { await performSave(); } } catch (error) { console.error('存档过程中发生错误:', error); this.showTemporaryMessage(`存档失败: ${error.message}`); } }, async loadGame(slotId) { const allSaves = this.getSavesFromStorage(); const saveData = allSaves[slotId]; if (!$1) { this.showTemporaryMessage('没有找到存档文件。'); return; } const saveName = saveData.save_name || `存档${slotId.split('_')[1]}`; this.showCustomConfirm(`确定要读取存档\"${saveName}\"吗？当前所有未保存的进度将会被覆盖。`, async () => { try { const messages = await getChatMessages(getCurrentMessageId()); if ($1 === $2) { this.showTemporaryMessage('错误：无法获取当前消息，无法读档。'); return; } const messageZero = messages[0]; const loadedData = saveData.mvu_data; const loadedMessageContent = saveData.message_content || ''; messageZero.data = loadedData; messageZero.message = loadedMessageContent; // --- 新逻辑：从独立世界书恢复到当前序号 --- if (saveData.lorebook_entries) { const entries = saveData.lorebook_entries; const bookName = '1归墟'; const currentIndex = this.unifiedIndex; const currentJourneyKey = currentIndex> 1 ? `本世历程(${currentIndex})` : '本世历程'; const currentPastLivesKey = currentIndex> 1 ? `往世涟漪(${currentIndex})` : '往世涟漪'; const novelModeIndex = this.novelModeIndex; const currentNovelModeKey = novelModeIndex> 1 ? `小说模式(${novelModeIndex})` : '小说模式'; try { const allEntries = await TavernHelper.getLorebookEntries(bookName); // 查找存档的独立世界书条目 const saveJourneyEntry = allEntries.find(entry => entry.comment === entries.journey_entry_name); const savePastLivesEntry = allEntries.find(entry => entry.comment === entries.past_lives_entry_name); const saveNovelModeEntry = allEntries.find(entry => entry.comment === entries.novel_mode_entry_name); // 查找当前序号的世界书条目 const currentJourneyEntry = allEntries.find(entry => entry.comment === currentJourneyKey); const currentPastLivesEntry = allEntries.find(entry => entry.comment === currentPastLivesKey); const currentNovelModeEntry = allEntries.find(entry => entry.comment === currentNovelModeKey); const entriesToUpdate = []; // 覆写本世历程 - 修复：允许空内容的恢复 if (saveJourneyEntry) { const contentToRestore = saveJourneyEntry.content || ''; if (currentJourneyEntry) { // 更新现有条目 entriesToUpdate.push({ uid: currentJourneyEntry.uid, content: contentToRestore }); console.log(`[归墟读档] 更新本世历程条目，内容长度: ${contentToRestore.length}`); } else { // 创建新条目 await TavernHelper.createLorebookEntries(bookName, [{ comment: currentJourneyKey, content: contentToRestore, keys: [currentJourneyKey], enabled: true, position: 'before_character_definition', order: 20 }]); console.log(`[归墟读档] 创建本世历程条目，内容长度: ${contentToRestore.length}`); } } // 覆写往世涟漪 - 修复：允许空内容的恢复 if (savePastLivesEntry) { const contentToRestore = savePastLivesEntry.content || ''; if (currentPastLivesEntry) { // 更新现有条目 entriesToUpdate.push({ uid: currentPastLivesEntry.uid, content: contentToRestore }); console.log(`[归墟读档] 更新往世涟漪条目，内容长度: ${contentToRestore.length}`); } else { // 创建新条目 await TavernHelper.createLorebookEntries(bookName, [{ comment: currentPastLivesKey, content: contentToRestore, keys: [currentPastLivesKey], enabled: true, position: 'before_character_definition', order: 19 }]); console.log(`[归墟读档] 创建往世涟漪条目，内容长度: ${contentToRestore.length}`); } } // 覆写小说模式 - 新增逻辑 if (saveNovelModeEntry) { const contentToRestore = saveNovelModeEntry.content || ''; if (currentNovelModeEntry) { // 更新现有条目 entriesToUpdate.push({ uid: currentNovelModeEntry.uid, content: contentToRestore }); console.log(`[归墟读档] 更新小说模式条目，内容长度: ${contentToRestore.length}`); } else { // 创建新条目 await TavernHelper.createLorebookEntries(bookName, [{ comment: currentNovelModeKey, content: contentToRestore, keys: [currentNovelModeKey], enabled: false, position: 'before_character_definition', order: 18 }]); console.log(`[归墟读档] 创建小说模式条目，内容长度: ${contentToRestore.length}`); } } // 批量更新现有条目 if (entriesToUpdate.length> 0) { await TavernHelper.setLorebookEntries(bookName, entriesToUpdate); } console.log(`[归墟读档] 已将存档\"${saveName}\"的世界书数据覆写到当前序号 ${currentIndex}`); } catch (e) { console.error(\"恢复世界书数据时出错:\", e); this.showTemporaryMessage(\"警告：恢复世界书数据失败，但主数据已恢复。\"); } } // --- 新逻辑结束 --- await TavernHelper.setChatMessages([messageZero], { refresh: 'all' }); await this.loadAndDisplayCurrentScene(loadedMessageContent); await this.init(); this.showTemporaryMessage(`读档\"${saveName}\"成功！`); this.closeAllModals(); } catch (error) { console.error('读档失败:', error); this.showTemporaryMessage(`读档失败: ${error.message}`); } }); }, deleteSave(slotId) { const allSaves = this.getSavesFromStorage(); const saveData = allSaves[slotId]; const saveName = saveData?.save_name || `存档 ${slotId.replace('slot_', '')}`; const isAutoSave = slotId.startsWith('auto_save_slot'); let confirmMessage = `确定要删除存档“${saveName}”吗？此操作不可恢复。`; // 对所有类型的存档都提示会删除世界书条目，因为自动存档现在也创建独立条目了 if (saveData && saveData.lorebook_entries) { confirmMessage += `\\n相关的世界书条目也会被一并删除。`; } this.showCustomConfirm(confirmMessage, async () => { try { // 对所有包含 lorebook_entries 的存档执行删除操作 if (saveData && saveData.lorebook_entries) { const bookName = '1归墟'; const entryNamesToDelete = Object.values(saveData.lorebook_entries); if (entryNamesToDelete.length> 0) { console.log(`[归墟删除] 准备删除世界书条目:`, entryNamesToDelete); const allEntries = await TavernHelper.getLorebookEntries(bookName); const uidsToDelete = allEntries .filter(entry => entryNamesToDelete.includes(entry.comment)) .map(entry => entry.uid); if (uidsToDelete.length> 0) { await TavernHelper.deleteLorebookEntries(bookName, uidsToDelete); console.log(`[归墟删除] 已成功删除 ${uidsToDelete.length} 个关联的世界书条目。`); } } } // 从localStorage中删除存档记录 delete allSaves[slotId]; localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves)); this.showTemporaryMessage(`存档“${saveName}”已删除。`); this.showSaveLoadManager(); // 刷新UI } catch (error) { console.error('删除存档失败:', error); this.showTemporaryMessage(`删除存档失败: ${error.message}`); } }); }, clearAllSaves() { this.showCustomConfirm(`你确定要清除所有存档吗？这个操作会删除所有5个存档槽位的数据，且不可恢复。`, () => { try { localStorage.removeItem('guixu_multi_save_data'); this.showTemporaryMessage(`所有存档已清除。`); this.showSaveLoadManager(); // 刷新UI } catch (error) { console.error('清除所有存档失败:', error); this.showTemporaryMessage(`清除存档失败: ${error.message}`); } }); }, // --- 新增：存档命名输入框 --- async promptForSaveName(slotId) { console.log('[归墟存档] 显示存档命名对话框'); return new Promise((resolve) => { try { // 创建模态框 const modal = document.createElement('div'); modal.className = 'modal-overlay'; modal.style.display = 'flex'; modal.style.zIndex = '2000'; // 确保在最顶层 modal.innerHTML = ` <div class=\"$1\" style=\"\"><div class=\"$1\"><h2 class=\"$1\">存档命名</h2></div><div class=\"$1\" style=\"\"><p style=\"\">请为存档位 ${slotId.split('_')[1]} 输入一个名称：</p><input type=\"text\" id=\"save-name-input\" placeholder=\"例如：突破金丹期\" style=\"\"><p style=\"\"> 将创建世界书条目：<br> • <span id=\"preview-journey\">存档名-本世历程</span><br> • <span id=\"preview-past-lives\">存档名-往世涟漪</span><br> • <span id=\"preview-novel-mode\">存档名-小说模式</span></p><div style=\"\"><button id=\"save-name-cancel\" class=\"$1\">取消</button><button id=\"save-name-confirm\" class=\"$1\">确认</button></div></div></div> `; const container = document.querySelector(\\'$1\\'); if (!$1) { console.error('[归墟存档] 找不到根容器'); resolve(null); return; } container.appendChild(modal); const input = modal.querySelector('#save-name-input'); const previewJourney = modal.querySelector('#preview-journey'); const previewPastLives = modal.querySelector('#preview-past-lives'); const previewNovelMode = modal.querySelector('#preview-novel-mode'); const confirmBtn = modal.querySelector('#save-name-confirm'); const cancelBtn = modal.querySelector('#save-name-cancel'); if (!$1) { console.error('[归墟存档] 模态框元素创建失败'); modal.remove(); resolve(null); return; } // 实时更新预览 input.addEventListener('input', () => { const name = input.value.trim() || '存档名'; if (previewJourney) previewJourney.textContent = `${name}-本世历程`; if (previewPastLives) previewPastLives.textContent = `${name}-往世涟漪`; if (previewNovelMode) previewNovelMode.textContent = `${name}-小说模式`; }); // 确认按钮 confirmBtn.addEventListener('click', () => { const saveName = input.value.trim(); if (!$1) { this.showTemporaryMessage('请输入存档名称'); return; } console.log('[归墟存档] 用户输入存档名称:', saveName); modal.remove(); resolve(saveName); }); // 取消按钮 cancelBtn.addEventListener('click', () => { console.log('[归墟存档] 用户取消存档'); modal.remove(); resolve(null); }); // 回车确认 input.addEventListener('keypress', (e) => { if ($1 === $2) { confirmBtn.click(); } }); // 自动聚焦 setTimeout(() => { try { input.focus(); } catch (e) { console.warn('[归墟存档] 自动聚焦失败:', e); } }, 100); } catch (error) { console.error('[归墟存档] 创建存档命名对话框时出错:', error); resolve(null); } }); }, // --- 新增：自动存档核心功能 --- saveAutoSaveState() { try { localStorage.setItem('guixu_auto_save_enabled', this.isAutoSaveEnabled); } catch (e) { console.error('保存自动存档状态失败:', e); } }, loadAutoSaveState() { try { const savedState = localStorage.getItem('guixu_auto_save_enabled'); this.isAutoSaveEnabled = savedState === 'true'; // 默认为 false const checkbox = document.getElementById('auto-save-checkbox'); if (checkbox) { checkbox.checked = this.isAutoSaveEnabled; } } catch (e) { console.error('加载自动存档状态失败:', e); this.isAutoSaveEnabled = false; } }, async performAutoSave() { console.log('[归墟] 执行双缓冲自动存档...'); try { // --- 1. 数据准备 --- const currentMvuData = this.currentMvuState; let currentMessageContent = ''; try { const messages = await getChatMessages(getCurrentMessageId()); if (messages && messages.length> 0) { const lastAiMessage = [...messages].reverse().find(m => m.role === 'assistant'); if (lastAiMessage) currentMessageContent = lastAiMessage.message || ''; } } catch (e) { console.warn('[归墟自动存档] 获取消息内容失败:', e); } if (!$1) { console.error('[归墟自动存档] MVU数据不完整，自动存档失败。'); return; } const bookName = '1归墟'; const allSaves = this.getSavesFromStorage(); const allEntries = await TavernHelper.getLorebookEntries(bookName); // --- 2. 轮换 localStorage 中的存档数据 --- const latestSave = allSaves['auto_save_slot_0']; if (latestSave) { allSaves['auto_save_slot_1'] = latestSave; // 旧的“最新”变成“上一次” } // --- 3. 轮换世界书条目 --- const entriesToUpdate = []; const entriesToCreate = []; const entriesToDelete = []; // 定义条目名称 const latestJourneyKey = '自动存档(最新)：本世历程'; const latestPastLivesKey = '自动存档(最新)：往世涟漪'; const latestNovelModeKey = '自动存档(最新)：小说模式'; const previousJourneyKey = '自动存档(上一次)：本世历程'; const previousPastLivesKey = '自动存档(上一次)：往世涟漪'; const previousNovelModeKey = '自动存档(上一次)：小说模式'; const latestJourneyEntry = allEntries.find(e => e.comment === latestJourneyKey); const latestPastLivesEntry = allEntries.find(e => e.comment === latestPastLivesKey); const latestNovelModeEntry = allEntries.find(e => e.comment === latestNovelModeKey); const previousJourneyEntry = allEntries.find(e => e.comment === previousJourneyKey); const previousPastLivesEntry = allEntries.find(e => e.comment === previousPastLivesKey); const previousNovelModeEntry = allEntries.find(e => e.comment === previousNovelModeKey); // a. 将“最新”条目内容移动到“上一次”条目 if (latestJourneyEntry) { if (previousJourneyEntry) entriesToUpdate.push({ uid: previousJourneyEntry.uid, content: latestJourneyEntry.content }); else entriesToCreate.push({ comment: previousJourneyKey, content: latestJourneyEntry.content, keys: [previousJourneyKey], enabled: false, position: 'before_character_definition', order: 18 }); } if (latestPastLivesEntry) { if (previousPastLivesEntry) entriesToUpdate.push({ uid: previousPastLivesEntry.uid, content: latestPastLivesEntry.content }); else entriesToCreate.push({ comment: previousPastLivesKey, content: latestPastLivesEntry.content, keys: [previousPastLivesKey], enabled: false, position: 'before_character_definition', order: 17 }); } if (latestNovelModeEntry) { if (previousNovelModeEntry) entriesToUpdate.push({ uid: previousNovelModeEntry.uid, content: latestNovelModeEntry.content }); else entriesToCreate.push({ comment: previousNovelModeKey, content: latestNovelModeEntry.content, keys: [previousNovelModeKey], enabled: false, position: 'before_character_definition', order: 16 }); } // b. 获取当前游戏内容，并写入“最新”条目 const currentJourneyEntry = allEntries.find(entry => entry.comment === (this.unifiedIndex> 1 ? `本世历程(${this.unifiedIndex})` : '本世历程')); const currentPastLivesEntry = allEntries.find(entry => entry.comment === (this.unifiedIndex> 1 ? `往世涟漪(${this.unifiedIndex})` : '往世涟漪')); const currentNovelModeEntry = allEntries.find(entry => entry.comment === (this.novelModeIndex> 1 ? `小说模式(${this.novelModeIndex})` : '小说模式')); const journeyContent = currentJourneyEntry ? currentJourneyEntry.content : ''; const pastLivesContent = currentPastLivesEntry ? currentPastLivesEntry.content : ''; const novelModeContent = currentNovelModeEntry ? currentNovelModeEntry.content : ''; if (latestJourneyEntry) entriesToUpdate.push({ uid: latestJourneyEntry.uid, content: journeyContent }); else entriesToCreate.push({ comment: latestJourneyKey, content: journeyContent, keys: [latestJourneyKey], enabled: false, position: 'before_character_definition', order: 20 }); if (latestPastLivesEntry) entriesToUpdate.push({ uid: latestPastLivesEntry.uid, content: pastLivesContent }); else entriesToCreate.push({ comment: latestPastLivesKey, content: pastLivesContent, keys: [latestPastLivesKey], enabled: false, position: 'before_character_definition', order: 19 }); if (latestNovelModeEntry) entriesToUpdate.push({ uid: latestNovelModeEntry.uid, content: novelModeContent }); else entriesToCreate.push({ comment: latestNovelModeKey, content: novelModeContent, keys: [latestNovelModeKey], enabled: false, position: 'before_character_definition', order: 18 }); // c. 执行世界书操作 if (entriesToCreate.length> 0) await TavernHelper.createLorebookEntries(bookName, entriesToCreate); if (entriesToUpdate.length> 0) await TavernHelper.setLorebookEntries(bookName, entriesToUpdate); // --- 4. 创建新的“最新”存档并保存 --- const newSaveDataPayload = { timestamp: new Date().toISOString(), save_name: '最新自动存档', message_content: currentMessageContent, mvu_data: currentMvuData, is_auto_save: true, lorebook_entries: { // 记录关联的条目名，便于删除 journey_entry_name: latestJourneyKey, past_lives_entry_name: latestPastLivesKey, novel_mode_entry_name: latestNovelModeKey } }; allSaves['auto_save_slot_0'] = newSaveDataPayload; // 更新“上一次”存档的名称和关联条目 if (allSaves['auto_save_slot_1']) { allSaves['auto_save_slot_1'].save_name = '上一次自动存档'; allSaves['auto_save_slot_1'].lorebook_entries = { journey_entry_name: previousJourneyKey, past_lives_entry_name: previousPastLivesKey, novel_mode_entry_name: previousNovelModeKey }; } localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves)); this.showTemporaryMessage('自动存档成功', 1500); console.log('[归墟] 双缓冲自动存档成功。'); } catch (error) { console.error('[归墟] 自动存档失败:', error); this.showTemporaryMessage(`自动存档失败: ${error.message}`); } }, // --- 新增：存档导入/导出功能 --- async exportSave(slotId) { this.showTemporaryMessage('正在准备导出数据...', 2000); try { const allSaves = this.getSavesFromStorage(); const saveData = allSaves[slotId]; if (!$1) { this.showTemporaryMessage('错误：找不到要导出的存档数据。'); return; } const exportData = { exportVersion: '1.0', exportedAt: new Date().toISOString(), saveData: saveData, lorebookData: [] }; // 如果存在世界书条目关联，则读取其内容 if ($1 === $2) { const bookName = '1归墟'; const entryNamesToExport = Object.values(saveData.lorebook_entries); if (entryNamesToExport.length> 0) { const allLorebookEntries = await TavernHelper.getLorebookEntries(bookName); exportData.lorebookData = allLorebookEntries.filter(entry => entryNamesToExport.includes(entry.comment) ); } } const jsonString = JSON.stringify(exportData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; const safeSaveName = (saveData.save_name || slotId).replace(/[^a-z0-9_\\-]/gi, '_'); a.download = `GuixuSave_${safeSaveName}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); this.showTemporaryMessage('存档已成功导出！'); } catch (error) { console.error('导出存档时出错:', error); this.showTemporaryMessage(`导出失败: ${error.message}`); } }, async handleFileImport(event) { const file = event.target.files[0]; if (!$1) return; this.showTemporaryMessage('正在导入存档...', 3000); const reader = new FileReader(); reader.onload = async (e) => { try { const importData = JSON.parse(e.target.result); // 1. 验证导入数据 if ($1 === $2) { throw new Error('存档文件格式无效或已损坏。'); } const allSaves = this.getSavesFromStorage(); // 2. 寻找空的手动存档槽位 let emptySlotId = null; for (let i = 1; i <= 5; i+) { const slotId = `slot_${i}`; if (!$1) { emptySlotId = slotId; break; } } if (!$1) { throw new Error('没有可用的手动存档槽位。请先删除一个。'); } const bookName = '1归墟'; const currentEntries = await TavernHelper.getLorebookEntries(bookName); const currentEntryNames = new Set(currentEntries.map(entry => entry.comment)); const newSaveData = _.cloneDeep(importData.saveData); const entriesToCreate = []; // 3. 处理世界书条目冲突并准备创建 for (const entryToImport of importData.lorebookData) { let newEntryName = entryToImport.comment; let originalEntryName = entryToImport.comment; // 如果条目名已存在，则重命名 if (currentEntryNames.has(newEntryName)) { newEntryName = `${newEntryName}_imported_${Date.now()}`; this.showTemporaryMessage(`世界书条目“${originalEntryName}”已存在，重命名为“${newEntryName}”`, 4000); } const newEntry = { ...entryToImport }; delete newEntry.uid; // 必须删除旧的uid newEntry.comment = newEntryName; newEntry.keys = [newEntryName]; // 更新关键字 newEntry.enabled = false; // 导入后默认禁用 entriesToCreate.push(newEntry); // 4. 更新存档数据中对世界书条目的引用 for (const key in newSaveData.lorebook_entries) { if ($1 === $2) { newSaveData.lorebook_entries[key] = newEntryName; } } } // 5. 创建世界书条目 if (entriesToCreate.length> 0) { await TavernHelper.createLorebookEntries(bookName, entriesToCreate); } // 6. 写入存档数据到localStorage newSaveData.save_name = `${newSaveData.save_name} (导入)`; // 标记为导入存档 allSaves[emptySlotId] = newSaveData; localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves)); this.showTemporaryMessage(`存档已成功导入到槽位 ${emptySlotId.split('_')[1]}！`); this.showSaveLoadManager(); // 刷新UI } catch (error) { console.error('导入存档时出错:', error); this.showTemporaryMessage(`导入失败: ${error.message}`); } finally { // 清空file input的值，以便可以再次选择同一个文件 event.target.value = ''; } }; reader.readAsText(file); }, // --- 新增：行动选项状态存取 --- saveActionOptionsState() { try { localStorage.setItem('guixu_action_options_enabled', this.isActionOptionsEnabled); } catch (e) { console.error('保存行动选项状态失败:', e); } }, // --- 新增：行动选项自动发送状态存取 --- saveActionAutoSendState() { try { localStorage.setItem('guixu_action_auto_send_enabled', this.isActionAutoSend); } catch (e) { console.error('保存行动选项自动发送状态失败:', e); } }, loadActionAutoSendState() { try { const savedState = localStorage.getItem('guixu_action_auto_send_enabled'); // 默认为 true (开启) this.isActionAutoSend = savedState === null ? true : savedState === 'true'; const checkbox = document.getElementById('auto-send-action-checkbox'); if (checkbox) { checkbox.checked = this.isActionAutoSend; } } catch (e) { console.error('加载行动选项自动发送状态失败:', e); this.isActionAutoSend = true; } }, loadActionOptionsState() { try { const savedState = localStorage.getItem('guixu_action_options_enabled'); // 默认为 true (开启) this.isActionOptionsEnabled = savedState === null ? true : savedState === 'true'; const checkbox = document.getElementById('action-options-enabled-checkbox'); if (checkbox) { checkbox.checked = this.isActionOptionsEnabled; } } catch (e) { console.error('加载行动选项状态失败:', e); this.isActionOptionsEnabled = true; } }, // --- 新增：自动化系统修剪功能 --- showTrimJourneyModal() { this.openModal('trim-journey-modal', true); // keepOpen = true to show over history modal const indexInput = document.getElementById('trim-journey-index-input'); if (indexInput) { indexInput.value = this.unifiedIndex; } }, _getTrimmedJourneyContent(fullContent) { if (!$1) return fullContent; const events = this.parseJourneyEntry(fullContent); if (events.length <= 2) { return fullContent; // 不需要修剪 } let trimCount = 0; events.forEach((event, idx) => { if (idx <events.length - 2) { if (event['自动化系统']) { delete event['自动化系统']; trimCount+; } } }); if ($1 === $2) { return fullContent; // 没有内容被改变 } // 重构内容字符串 const newContent = events.map(event => { const fieldOrder = ['序号', '日期', '标题', '地点', '人物', '描述', '人物关系', '标签', '重要信息', '暗线与伏笔', '自动化系统']; return fieldOrder .map(key => (event[key] ? `${key}|${event[key]}` : null)) .filter(Boolean) .join('\\n'); }).join('\\n\\n'); console.log(`[归墟-内部修剪] 成功移除 ${trimCount} 条自动化系统记录。`); return newContent; }, async trimJourneyAutomation(index, silent = false) { const bookName = '1归墟'; const journeyKey = index> 1 ? `本世历程(${index})` : '本世历程'; if (!$1) this.showTemporaryMessage(`正在开始修剪序号 ${index} 的本世历程...`); try { const allEntries = await TavernHelper.getLorebookEntries(bookName); const journeyEntry = allEntries.find(entry => entry.comment === journeyKey); if (!$1) { if (!$1) this.showTemporaryMessage(`错误：找不到或内容为空，无法修剪。`, 3000); return; } const newContent = this._getTrimmedJourneyContent(journeyEntry.content); if ($1 === $2) { if (!$1) this.showTemporaryMessage('没有需要修剪的自动化内容。'); return; } await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]); if (!$1) { this.showTemporaryMessage(`修剪成功！`, 3000); this.closeModal('trim-journey-modal'); this.showJourney(); // 刷新视图 } } catch (error) { console.error('修剪本世历程时出错:', error); if (!$1) this.showTemporaryMessage(`修剪失败: ${error.message}`, 3000); } }, // --- 新增：自动修剪状态存取 --- saveAutoTrimState() { try { localStorage.setItem('guixu_auto_trim_enabled', this.isAutoTrimEnabled); } catch (e) { console.error('保存自动修剪状态失败:', e); } }, loadAutoTrimState() { try { const savedState = localStorage.getItem('guixu_auto_trim_enabled'); this.isAutoTrimEnabled = savedState === 'true'; // 默认为 false // 注意：复选框是在 showJourney 时动态创建的，所以在这里无法直接更新它 } catch (e) { console.error('加载自动修剪状态失败:', e); this.isAutoTrimEnabled = false; } }, // --- 新增：流式开关状态存取 --- saveStreamingState() { try { localStorage.setItem('guixu_streaming_enabled', this.isStreamingEnabled); } catch (e) { console.error('保存流式状态失败:', e); } }, loadStreamingState() { try { const savedState = localStorage.getItem('guixu_streaming_enabled'); // 默认为 true (开启) this.isStreamingEnabled = savedState === null ? true : savedState === 'true'; const checkbox = document.getElementById('streaming-enabled-checkbox'); if (checkbox) { checkbox.checked = this.isStreamingEnabled; } } catch (e) { console.error('加载流式状态失败:', e); this.isStreamingEnabled = true; } }, // --- 新增：格式审查状态存取 --- saveFormatValidationState() { try { localStorage.setItem('guixu_format_validation_enabled', this.isFormatValidationEnabled); } catch (e) { console.error('保存格式审查状态失败:', e); } }, loadFormatValidationState() { try { const savedState = localStorage.getItem('guixu_format_validation_enabled'); // 默认为 true (开启) this.isFormatValidationEnabled = savedState === null ? true : savedState === 'true'; const checkbox = document.getElementById('format-validation-enabled-checkbox'); if (checkbox) { checkbox.checked = this.isFormatValidationEnabled; } } catch (e) { console.error('加载格式审查状态失败:', e); this.isFormatValidationEnabled = true; } }, // --- 新增：回车发送状态存取 --- saveEnterSendState() { try { localStorage.setItem('guixu_enter_send_enabled', this.isEnterSendEnabled); } catch (e) { console.error('保存回车发送状态失败:', e); } }, loadEnterSendState() { try { const savedState = localStorage.getItem('guixu_enter_send_enabled'); // 默认为 false (关闭) this.isEnterSendEnabled = savedState === 'true'; const checkbox = document.getElementById('enter-send-checkbox'); if (checkbox) { checkbox.checked = this.isEnterSendEnabled; } } catch (e) { console.error('加载回车发送状态失败:', e); this.isEnterSendEnabled = false; } }, // --- 新增：历程修剪功能处理函数 --- reconstructJourneyEntry(events) { if (!$1)) return ''; const fieldOrder = ['序号', '日期', '标题', '地点', '人物', '描述', '人物关系', '标签', '重要信息', '暗线与伏笔', '自动化系统']; return events.map(event => { return fieldOrder .map(key => { // 检查属性是否存在且不为null/undefined if ($1 === $2) { return `${key}|${String(event[key]).trim()}`; } return null; }) .filter(Boolean) // 过滤掉null或undefined的条目 .join('\\n'); }).join('\\n\\n'); }, async handlePreciseTrim() { // 1. 获取要操作的条目 const checkedBoxes = document.querySelectorAll(\\'$1\\'); if ($1 === $2) { this.showTemporaryMessage('请先在下方历程中勾选需要修剪的条目。'); return; } const sequenceIdsToTrim = Array.from(checkedBoxes).map(box => box.dataset.sequenceId); // 2. 获取要删除的字段 const fieldsToRemove = Array.from(document.querySelectorAll(\\'$1\\')).map(cb => cb.value); if ($1 === $2) { this.showTemporaryMessage('请先在上方控制台勾选需要修剪的字段。'); return; } // 3. 弹出确认框 this.showCustomConfirm( `你确定要从选中的 ${checkedBoxes.length} 个条目中，删除【${fieldsToRemove.join('、')}】字段吗？此操作不可恢复。`, async () => { this.showTemporaryMessage('正在进行精确修剪...'); const bookName = '1归墟'; const index = this.unifiedIndex; const journeyKey = index> 1 ? `本世历程(${index})` : '本世历程'; try { const allEntries = await TavernHelper.getLorebookEntries(bookName); const journeyEntry = allEntries.find(entry => entry.comment === journeyKey); if (!$1) { this.showTemporaryMessage('错误：找不到“本世历程”内容。'); return; } let events = this.parseJourneyEntry(journeyEntry.content); let trimCount = 0; events.forEach(event => { if (sequenceIdsToTrim.includes(event['序号'])) { let trimmedThisEvent = false; fieldsToRemove.forEach(field => { if (event.hasOwnProperty(field)) { delete event[field]; trimmedThisEvent = true; } }); if (trimmedThisEvent) trimCount+; } }); if ($1 === $2) { this.showTemporaryMessage('选中的条目中没有可修剪的内容。'); return; } const newContent = this.reconstructJourneyEntry(events); await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]); this.showTemporaryMessage(`修剪成功！已处理 ${trimCount} 个条目。`, 3000); this.showJourney(); // 刷新视图 } catch (error) { console.error('精确修剪失败:', error); this.showTemporaryMessage(`修剪失败: ${error.message}`, 3000); } }, true // keepCurrentModal ); }, async handleAutoTrim() { // 1. 获取要删除的字段 const fieldsToRemove = Array.from(document.querySelectorAll(\\'$1\\')).map(cb => cb.value); if ($1 === $2) { this.showTemporaryMessage('请先在上方控制台勾选需要修剪的字段。'); return; } // 2. 获取保留数量 const keepCountInput = document.getElementById('trim-keep-count'); const keepCount = parseInt(keepCountInput.value, 10); if (isNaN(keepCount) || keepCount <0) { this.showTemporaryMessage('请输入有效的保留数量。'); return; } // 3. 弹出确认框 this.showCustomConfirm( `你确定要保留最新的 ${keepCount} 个条目，并从所有更早的条目中删除【${fieldsToRemove.join('、')}】字段吗？此操作不可恢复。`, async () => { this.showTemporaryMessage('正在进行自动修剪...'); const bookName = '1归墟'; const index = this.unifiedIndex; const journeyKey = index> 1 ? `本世历程(${index})` : '本世历程'; try { const allEntries = await TavernHelper.getLorebookEntries(bookName); const journeyEntry = allEntries.find(entry => entry.comment === journeyKey); if (!$1) { this.showTemporaryMessage('错误：找不到“本世历程”内容。'); return; } let events = this.parseJourneyEntry(journeyEntry.content); if (events.length <= keepCount) { this.showTemporaryMessage('无需修剪，当前条目数未超过保留数量。'); return; } let trimCount = 0; const eventsToTrimCount = events.length - keepCount; events.forEach((event, idx) => { if (idx <eventsToTrimCount) { let trimmedThisEvent = false; fieldsToRemove.forEach(field => { if (event.hasOwnProperty(field)) { delete event[field]; trimmedThisEvent = true; } }); if (trimmedThisEvent) trimCount+; } }); if ($1 === $2) { this.showTemporaryMessage('没有可修剪的内容。'); return; } const newContent = this.reconstructJourneyEntry(events); await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]); this.showTemporaryMessage(`自动修剪成功！已处理 ${trimCount} 个旧条目。`, 3000); this.showJourney(); } catch (error) { console.error('自动修剪失败:', error); this.showTemporaryMessage(`修剪失败: ${error.message}`, 3000); } }, true ); }, async handleFullTrim() { const keepCountInput = document.getElementById('trim-keep-count'); const keepCount = parseInt(keepCountInput.value, 10); if (isNaN(keepCount) || keepCount <0) { this.showTemporaryMessage('请输入有效的保留数量。'); return; } this.showCustomConfirm( `【高危操作】你确定要永久删除除最近 ${keepCount} 条外的所有历程记录吗？此操作将彻底删除数据，不可恢复！`, async () => { this.showTemporaryMessage('正在进行完整删除...'); const bookName = '1归墟'; const index = this.unifiedIndex; const journeyKey = index> 1 ? `本世历程(${index})` : '本世历程'; try { const allEntries = await TavernHelper.getLorebookEntries(bookName); const journeyEntry = allEntries.find(entry => entry.comment === journeyKey); if (!$1) { this.showTemporaryMessage('错误：找不到“本世历程”内容。'); return; } let events = this.parseJourneyEntry(journeyEntry.content); if (events.length <= keepCount) { this.showTemporaryMessage('无需删除，当前条目数未超过保留数量。'); return; } const deletedCount = events.length - keepCount; const keptEvents = events.slice(deletedCount); const newContent = this.reconstructJourneyEntry(keptEvents); await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]); this.showTemporaryMessage(`完整删除成功！已删除 ${deletedCount} 个旧条目。`, 3000); this.showJourney(); } catch (error) { console.error('完整删除失败:', error); this.showTemporaryMessage(`删除失败: ${error.message}`, 3000); } }, true ); }, // --- 新增：修剪字段状态的保存与加载 --- saveTrimFieldsState() { const checkboxes = document.querySelectorAll(\\'$1\\'); const state = {}; checkboxes.forEach(cb => { state[cb.value] = cb.checked; }); this.trimFieldsState = state; try { localStorage.setItem('guixu_trim_fields_state', JSON.stringify(state)); } catch (e) { console.error('保存修剪字段状态失败:', e); } }, loadTrimFieldsState() { try { const savedState = localStorage.getItem('guixu_trim_fields_state'); if (savedState) { this.trimFieldsState = JSON.parse(savedState); } else { // 如果没有保存的状态，则从HTML的默认checked状态初始化 this.saveTrimFieldsState(); return; } } catch (e) { console.error('加载修剪字段状态失败:', e); this.trimFieldsState = {}; // 出错时重置 } // 将加载的状态应用到复选框 const checkboxes = document.querySelectorAll(\\'$1\\'); checkboxes.forEach(cb => { // 如果状态对象中有这个值，则使用它；否则保持默认 if (this.trimFieldsState.hasOwnProperty(cb.value)) { cb.checked = this.trimFieldsState[cb.value]; } }); }, // --- 新增：输入缓存历史功能 --- getInputHistory() { try { const history = localStorage.getItem('guixu_input_history'); return history ? JSON.parse(history) : []; } catch (e) { return []; } }, saveInputToHistory(content) { if (!$1) return; try { let history = this.getInputHistory(); // 避免重复保存完全相同的内容到最前面 if ($1 === $2) return; // 将新内容添加到数组开头 history.unshift(content); // 限制历史记录数量，例如100条 if (history.length> 100) { history.pop(); } localStorage.setItem('guixu_input_history', JSON.stringify(history)); } catch (e) { // Fail silently } }, showInputCacheModal() { const history = this.getInputHistory(); const recentListEl = document.getElementById('recent-inputs-list'); const allListEl = document.getElementById('all-inputs-list'); if (!$1) return; recentListEl.innerHTML = ''; allListEl.innerHTML = ''; if ($1 === $2) { recentListEl.innerHTML = '<li class=\"$1\">暂无记录</li>'; allListEl.innerHTML = '<li class=\"$1\">暂无记录</li>'; } else { // 填充最近两次输入 history.slice(0, 2).forEach((item, index) => { const li = document.createElement('li'); li.className = 'input-cache-item'; li.dataset.content = item; li.innerHTML = `<span class=\"$1\">${index + 1}.</span>${item}`; recentListEl.appendChild(li); }); // 填充所有历史记录 history.forEach((item, index) => { const li = document.createElement('li'); li.className = 'input-cache-item'; li.dataset.content = item; li.innerHTML = `<span class=\"$1\">${index + 1}.</span>${item}`; allListEl.appendChild(li); }); } this.openModal('input-cache-modal'); }, applyInputFromHistory(content) { const inputEl = document.getElementById('quick-send-input'); if (inputEl) { inputEl.value = content; this.closeModal('input-cache-modal'); this.showTemporaryMessage('已应用历史输入。'); } }, // --- 新增：背景图设置功能 --- showBackgroundSettings() { this.openModal('background-settings-modal'); this.renderBackgroundList(); this.updateBackgroundModeUI(); // 确保在模态框打开后绑定事件 setTimeout(() => { this.bindBackgroundListEvents(); }, 100); }, updateBackgroundModeUI() { const randomRadio = document.getElementById('bg-mode-random'); const fixedRadio = document.getElementById('bg-mode-fixed'); if (randomRadio && fixedRadio) { randomRadio.checked = this.backgroundMode === 'random'; fixedRadio.checked = this.backgroundMode === 'fixed'; } }, renderBackgroundList() { const listContainer = document.getElementById('background-list'); const countSpan = document.getElementById('background-count'); if (!$1) return; countSpan.textContent = `(${this.backgroundImages.length}张)`; listContainer.innerHTML = ''; if ($1 === $2) { listContainer.innerHTML = '<div style=\"\">暂无背景图</div>'; return; } this.backgroundImages.forEach(bg => { const item = document.createElement('div'); item.className = 'background-item'; item.dataset.bgId = bg.id; // 如果是固定模式下的选中背景，添加选中样式 if ($1 === $2) { item.classList.add('selected'); } // 为外链图片添加特殊标识 const linkIcon = bg.isUrlImage ? '<div style=\"\">🔗</div>' : ''; item.innerHTML = ` <img src=\"${bg.dataUrl}\" alt=\"${bg.name}\" style=\"\"> ${linkIcon} <div class=\"$1\"><div class=\"$1\"><button class=\"$1\" data-$1=\"$2\">预览</button><button class=\"$1\" data-$1=\"$2\">选择</button><button class=\"$1\" data-$1=\"$2\">删除</button></div></div> `; // 如果是当前预览的背景，显示指示器 if ($1 === $2) { const indicator = document.createElement('div'); indicator.className = 'background-preview-indicator'; indicator.textContent = '当前'; item.appendChild(indicator); } listContainer.appendChild(item); }); // 绑定事件 this.bindBackgroundListEvents(); }, bindBackgroundListEvents() { const listContainer = document.getElementById('background-list'); if (!$1) return; // 移除旧的事件监听器（如果存在） if (this.backgroundListClickHandler) { listContainer.removeEventListener('click', this.backgroundListClickHandler); } // 创建新的事件处理器并保存引用 this.backgroundListClickHandler = (e) => { const bgId = e.target.dataset.bgId; if (!$1) return; if (e.target.classList.contains('preview-btn')) { this.previewBackground(bgId); } else if (e.target.classList.contains('select-btn')) { this.selectBackground(bgId); } else if (e.target.classList.contains('delete')) { this.deleteBackground(bgId); } }; // 绑定新的事件监听器 listContainer.addEventListener('click', this.backgroundListClickHandler); }, // 新增：将背景设置模态框内的静态事件绑定分离出来 bindBackgroundSettingsListeners() { if (this.backgroundEventsInitialized) return; // 确保只绑定一次 // 绑定上传区域事件 const uploadArea = document.getElementById('background-upload-area'); const fileInput = document.getElementById('background-file-input'); if (uploadArea && fileInput) { uploadArea.addEventListener('click', () => fileInput.click()); fileInput.addEventListener('change', (e) => this.handleBackgroundUpload(e)); } // 绑定模式切换事件 const randomRadio = document.getElementById('bg-mode-random'); const fixedRadio = document.getElementById('bg-mode-fixed'); if (randomRadio && fixedRadio) { randomRadio.addEventListener('change', () => { if (randomRadio.checked) { this.backgroundMode = 'random'; this.saveBackgroundSettings(); this.renderBackgroundList(); } }); fixedRadio.addEventListener('change', () => { if (fixedRadio.checked) { this.backgroundMode = 'fixed'; this.saveBackgroundSettings(); this.renderBackgroundList(); } }); } // 绑定外链图床按钮事件 const addUrlBtn = document.getElementById('add-url-image-btn'); if (addUrlBtn) { addUrlBtn.addEventListener('click', () => this.handleUrlImageAdd()); } // 绑定管理外链按钮事件 const manageUrlBtn = document.getElementById('manage-url-images-btn'); if (manageUrlBtn) { manageUrlBtn.addEventListener('click', () => this.showUrlImagesManageModal()); } // 标记为已初始化 this.backgroundEventsInitialized = true; }, async handleBackgroundUpload(event) { const files = event.target.files; if ($1 === $2) { console.warn('[归墟背景] 没有选择文件'); return; } console.log(`[归墟背景] 开始处理 ${files.length} 个文件`); this.showTemporaryMessage('正在处理图片...', 3000); for (let $1 = 0; $1 <$2; $1+) { const file = files[i]; console.log(`[归墟背景] 处理文件: ${file.name}, 大小: ${file.size} bytes, 类型: ${file.type}`); // 检查文件类型 if (!$1)) { console.error(`[归墟背景] 文件类型无效: ${file.type}`); this.showTemporaryMessage(`文件 ${file.name} 不是有效的图片格式`); continue; } try { let processedDataUrl; let compressionApplied = false; // 检查文件大小，如果超过2MB则尝试压缩 if (file.size> 2 * 1024 * 1024) { console.log(`[归墟背景] 文件过大 (${file.size} bytes)，尝试压缩...`); try { processedDataUrl = await this.compressImage(file, 0.8, 1920, 1080); compressionApplied = true; console.log(`[归墟背景] 图片压缩成功`); } catch (compressionError) { console.error(`[归墟背景] 图片压缩失败:`, compressionError); // 如果压缩失败，尝试使用Object URL方式 try { processedDataUrl = await this.createObjectUrlForLargeImage(file); console.log(`[归墟背景] 使用Object URL处理大图片`); } catch (objectUrlError) { console.error(`[归墟背景] Object URL创建失败:`, objectUrlError); this.showTemporaryMessage(`文件 ${file.name} 过大且处理失败，请选择小于2MB的图片`); continue; } } } else { // 文件大小合适，直接转换 processedDataUrl = await this.fileToDataUrl(file); console.log(`[归墟背景] 直接转换为DataURL成功`); } const bgId = 'bg_' + Date.now() + $1 + Math.random().toString(36).substr(2, 9); const newBackground = { id: bgId, name: file.name.replace(/\\.[^/.]+$/, \"\"), // 移除文件扩展名 dataUrl: processedDataUrl, uploadTime: new Date().toISOString(), isPreset: false, compressed: compressionApplied, originalSize: file.size }; // 临时添加到数组中测试存储 const tempImages = [...this.backgroundImages, newBackground]; const testSettings = { images: tempImages, mode: this.backgroundMode, selectedId: this.selectedBackgroundId }; // 测试是否能够成功保存到localStorage try { const testData = JSON.stringify(testSettings); console.log(`[归墟背景] 测试数据大小: ${testData.length} 字符`); // 检查数据大小（localStorage通常限制为5-10MB） if (testData.length> 4 * 1024 * 1024) { // 4MB限制 throw new Error('存储空间不足'); } // 尝试保存测试数据 localStorage.setItem('guixu_background_test', testData); localStorage.removeItem('guixu_background_test'); // 如果测试成功，正式添加图片 this.backgroundImages.push(newBackground); this.saveBackgroundSettings(); console.log(`[归墟背景] 成功保存图片: ${file.name}, 当前图片数量: ${this.backgroundImages.length}`); // 显示成功消息，包含压缩信息 if (compressionApplied) { this.showTemporaryMessage(`图片 ${file.name} 已压缩并保存成功`); } else { this.showTemporaryMessage(`图片 ${file.name} 保存成功`); } } catch (storageError) { console.error('[归墟背景] localStorage存储失败:', storageError); this.showTemporaryMessage(`图片 ${file.name} 保存失败：存储空间不足或图片过大`); continue; } // 如果背景设置模态框是打开的，刷新列表 if ($1 === $2) { this.renderBackgroundList(); } } catch (error) { console.error('[归墟背景] 处理图片失败:', error); this.showTemporaryMessage(`处理图片 ${file.name} 失败: ${error.message}`); } } // 清空文件输入 event.target.value = ''; this.showTemporaryMessage('图片处理完成！'); }, fileToDataUrl(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => { console.log(`[归墟背景] FileReader成功读取文件，DataURL长度: ${e.target.result.length}`); resolve(e.target.result); }; reader.onerror = (error) => { console.error(`[归墟背景] FileReader读取失败:`, error); reject(error); }; reader.readAsDataURL(file); }); }, // 新增：图片压缩函数 compressImage(file, quality = 0.8, maxWidth = 1920, maxHeight = 1080) { return new Promise((resolve, reject) => { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); const img = new Image(); img.onload = () => { try { // 计算压缩后的尺寸 let { width, height } = img; if (width> maxWidth || height> maxHeight) { const ratio = Math.min(maxWidth / width, maxHeight / height); width *= ratio; height *= ratio; } canvas.width = width; canvas.height = height; // 绘制压缩后的图片 ctx.drawImage(img, 0, 0, width, height); // 转换为DataURL const compressedDataUrl = canvas.toDataURL('image/jpeg', quality); console.log(`[归墟背景] 图片压缩完成: ${img.naturalWidth}x${img.naturalHeight} -> ${width}x${height}, 质量: ${quality}`); resolve(compressedDataUrl); } catch (error) { console.error(`[归墟背景] 图片压缩过程中出错:`, error); reject(error); } }; img.onerror = (error) => { console.error(`[归墟背景] 图片加载失败:`, error); reject(new Error('图片加载失败')); }; // 创建图片URL const url = URL.createObjectURL(file); img.src = url; // 清理URL - 修正onload处理 const originalOnload = img.onload; img.onload = () => { URL.revokeObjectURL(url); originalOnload(); }; }); }, // 新增：为大图片创建Object URL的处理方式 createObjectUrlForLargeImage(file) { return new Promise((resolve, reject) => { try { // 创建Object URL const objectUrl = URL.createObjectURL(file); // 验证URL是否有效 const img = new Image(); img.onload = () => { console.log(`[归墟背景] Object URL创建成功: ${objectUrl}`); resolve(objectUrl); }; img.onerror = () => { URL.revokeObjectURL(objectUrl); reject(new Error('Object URL验证失败')); }; img.src = objectUrl; } catch (error) { console.error(`[归墟背景] Object URL创建失败:`, error); reject(error); } }); }, previewBackground(bgId) { const bg = this.backgroundImages.find(b => b.id === bgId); if (!$1) return; // 创建预览模态框 this.showImagePreviewModal(bg); }, showImagePreviewModal(bg) { // 创建预览模态框 const modal = document.createElement('div'); modal.className = 'modal-overlay'; modal.style.display = 'flex'; modal.style.zIndex = '2001'; // 确保在背景设置模态框之上 modal.innerHTML = ` <div class=\"$1\" style=\"\"><div class=\"$1\" style=\"\"><h2 class=\"$1\">预览：${bg.name}</h2><button class=\"$1\" id=\"preview-close-btn\">&times;</button></div><div class=\"$1\" style=\"\"><img src=\"${bg.dataUrl}\" alt=\"${bg.name}\" style=\"\"></div></div> `; const container = document.querySelector(\\'$1\\'); if (container) { container.appendChild(modal); // 绑定关闭事件 const closeBtn = modal.querySelector('#preview-close-btn'); const closeModal = () => { modal.remove(); }; if (closeBtn) { closeBtn.addEventListener('click', closeModal); } // 点击背景关闭 modal.addEventListener('click', (e) => { if ($1 === $2) { closeModal(); } }); // ESC键关闭 const handleKeydown = (e) => { if ($1 === $2) { closeModal(); document.removeEventListener('keydown', handleKeydown); } }; document.addEventListener('keydown', handleKeydown); this.showTemporaryMessage(`正在预览：${bg.name}`); } }, selectBackground(bgId) { const bg = this.backgroundImages.find(b => b.id === bgId); if (!$1) return; this.selectedBackgroundId = bgId; this.backgroundMode = 'fixed'; // 选择背景时自动切换到固定模式 this.saveBackgroundSettings(); this.updateBackgroundModeUI(); this.renderBackgroundList(); this.applyRandomBackground(); // 应用选中的背景 this.showTemporaryMessage(`已选择背景：${bg.name}`); }, deleteBackground(bgId) { const bg = this.backgroundImages.find(b => b.id === bgId); if (!$1) return; this.showCustomConfirm(`确定要删除背景图\"${bg.name}\"吗？`, () => { this.backgroundImages = this.backgroundImages.filter(b => b.id !== bgId); // 如果删除的是当前选中的背景，清除选择 if ($1 === $2) { this.selectedBackgroundId = null; } this.saveBackgroundSettings(); this.renderBackgroundList(); this.applyRandomBackground(); // 重新应用背景 this.showTemporaryMessage(`已删除背景图：${bg.name}`); }, null, true); // keepCurrentModal = true }, saveBackgroundSettings() { try { const settings = { images: this.backgroundImages, mode: this.backgroundMode, selectedId: this.selectedBackgroundId }; localStorage.setItem('guixu_background_settings', JSON.stringify(settings)); } catch (e) { console.error('保存背景图设置失败:', e); } }, loadBackgroundSettings() { try { const saved = localStorage.getItem('guixu_background_settings'); if (saved) { const settings = JSON.parse(saved); this.backgroundImages = settings.images || []; this.backgroundMode = settings.mode || 'random'; this.selectedBackgroundId = settings.selectedId || null; } } catch (e) { console.error('加载背景图设置失败:', e); this.backgroundImages = []; this.backgroundMode = 'random'; this.selectedBackgroundId = null; } }, // --- 新增：处理外链图床添加 --- async handleUrlImageAdd() { const urlInput = document.getElementById('image-url-input'); if (!$1) { this.showTemporaryMessage('找不到URL输入框'); return; } const inputText = urlInput.value.trim(); const baseName = ''; // 使用空字符串，让系统自动生成名称 // 验证输入 if (!$1) { this.showTemporaryMessage('请输入图片链接'); return; } // 分割多行输入，支持多个链接 const imageUrls = inputText.split('\\n') .map(url => url.trim()) .filter(url => url.length> 0); if ($1 === $2) { this.showTemporaryMessage('请输入有效的图片链接'); return; } // 验证所有链接格式 const invalidUrls = imageUrls.filter(url => !this.isValidImageUrl(url)); if (invalidUrls.length> 0) { this.showTemporaryMessage(`以下链接格式无效（需要以 https:// 开头）：\\n${invalidUrls.slice(0, 3).join('\\n')}${invalidUrls.length> 3 ? '\\n...' : ''}`); return; } // 检查重复链接 const existingUrls = imageUrls.filter(url => this.backgroundImages.some(bg => bg.dataUrl === url) ); if (existingUrls.length> 0) { this.showTemporaryMessage(`以下链接已存在：\\n${existingUrls.slice(0, 3).join('\\n')}${existingUrls.length> 3 ? '\\n...' : ''}`); return; } this.showTemporaryMessage(`正在验证 ${imageUrls.length} 个图片链接...`, 5000); let successCount = 0; let failedUrls = []; // 批量处理图片链接 for (let $1 = 0; $1 <$2; $1+) { const imageUrl = imageUrls[i]; try { // 验证图片链接是否有效 const isValid = await this.validateImageUrl(imageUrl); if (!$1) { failedUrls.push(imageUrl); continue; } // 生成图片名称 let finalName; if (baseName) { finalName = imageUrls.length> 1 ? `${baseName}_${i + 1}` : baseName; } else { finalName = this.extractNameFromUrl(imageUrl); } // 创建新的背景图对象 const bgId = 'url_' + Date.now() + $1 + Math.random().toString(36).substr(2, 9); const newBackground = { id: bgId, name: finalName, dataUrl: imageUrl, uploadTime: new Date().toISOString(), isPreset: false, isUrlImage: true, // 标记为外链图片 originalUrl: imageUrl }; // 测试存储空间 const tempImages = [...this.backgroundImages, newBackground]; const testSettings = { images: tempImages, mode: this.backgroundMode, selectedId: this.selectedBackgroundId }; try { const testData = JSON.stringify(testSettings); if (testData.length> 4 * 1024 * 1024) { throw new Error('存储空间不足'); } localStorage.setItem('guixu_background_test', testData); localStorage.removeItem('guixu_background_test'); // 保存成功 this.backgroundImages.push(newBackground); successCount+; console.log(`[归墟背景] 成功添加外链图片: ${finalName}, URL: ${imageUrl}`); } catch (storageError) { console.error('[归墟背景] 存储外链图片失败:', storageError); failedUrls.push(imageUrl); } } catch (error) { console.error('[归墟背景] 验证外链图片失败:', error); failedUrls.push(imageUrl); } } // 保存设置 if (successCount> 0) { this.saveBackgroundSettings(); // 清空输入框 urlInput.value = ''; // 刷新列表 if ($1 === $2) { this.renderBackgroundList(); } } // 显示结果消息 if ($1 === $2) { this.showTemporaryMessage(`成功添加 ${successCount} 张外链图片！`); } else if (successCount> 0) { this.showTemporaryMessage(`成功添加 ${successCount} 张图片，${failedUrls.length} 张失败`); } else { this.showTemporaryMessage('所有图片链接都添加失败，请检查链接是否正确'); } }, // --- 新增：验证图片URL格式 --- isValidImageUrl(url) { try { const urlObj = new URL(url); // 必须是 https 协议 if ($1 === $2) { return false; } // 检查是否是常见的图片扩展名或图床域名 const pathname = urlObj.pathname.toLowerCase(); const hostname = urlObj.hostname.toLowerCase(); // 常见图片扩展名 const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp']; const hasImageExtension = imageExtensions.some(ext => pathname.endsWith(ext)); // 常见图床域名 const imagehostDomains = [ 'imgur.com', 'i.imgur.com', 'postimg.cc', 'i.postimg.cc', 'sm.ms', 'i.loli.net', 'github.com', 'raw.githubusercontent.com', 'cdn.jsdelivr.net', 'unpkg.com' ]; const isImagehostDomain = imagehostDomains.some(domain => hostname === domain || hostname.endsWith('.' + domain) ); return hasImageExtension || isImagehostDomain; } catch (e) { return false; } }, // --- 新增：验证图片链接是否可访问 --- validateImageUrl(url) { return new Promise((resolve) => { const img = new Image(); const timeout = setTimeout(() => { resolve(false); }, 10000); // 10秒超时 img.onload = () => { clearTimeout(timeout); resolve(true); }; img.onerror = () => { clearTimeout(timeout); resolve(false); }; // 设置跨域属性以避免CORS问题 img.crossOrigin = 'anonymous'; img.src = url; }); }, // --- 新增：从URL提取文件名 --- extractNameFromUrl(url) { try { const urlObj = new URL(url); const pathname = urlObj.pathname; const filename = pathname.split('/').pop(); if (filename && filename.includes('.')) { // 移除扩展名 return filename.replace(/\\.[^/.]+$/, '') || '外链图片'; } // 如果无法提取文件名，使用域名 return urlObj.hostname.replace('www.', '') || '外链图片'; } catch (e) { return '外链图片'; } }, // --- 新增：显示图床链接管理模态框 --- showUrlImagesManageModal() { this.openModal('url-images-manage-modal'); this.renderUrlImagesList(); }, // --- 新增：渲染外链图片列表 --- renderUrlImagesList() { const listContainer = document.getElementById('url-images-list'); const countSpan = document.getElementById('url-images-count'); if (!$1) return; // 筛选出外链图片 const urlImages = this.backgroundImages.filter(bg => bg.isUrlImage); countSpan.textContent = `(${urlImages.length}张)`; if ($1 === $2) { listContainer.innerHTML = '<div style=\"\">暂无外链图片</div>'; return; } listContainer.innerHTML = ''; urlImages.forEach(bg => { const item = document.createElement('div'); item.className = 'url-image-item'; item.style.cssText = ` display: flex; align-items: center; padding: 12px; margin-bottom: 8px; background: rgba(26, 26, 46, 0.6); border: 1px solid rgba(201, 170, 113, 0.2); border-radius: 6px; transition: all 0.2s ease; `; item.innerHTML = ` <div style=\"\"><img src=\"${bg.dataUrl}\" alt=\"${bg.name}\" style=\"\"></div><div style=\"\"><div style=\"\"> ${bg.name} </div><div style=\"\"> ${bg.originalUrl} </div><div style=\"\"> 添加时间: ${new Date(bg.uploadTime).toLocaleString('zh-CN')} </div></div><div style=\"\"><button class=\"$1\" data-$1=\"$2\" style=\"\"> 重命名 </button><button class=\"$1\" data-$1=\"$2\" style=\"\"> 预览 </button><button class=\"$1\" data-$1=\"$2\" style=\"\"> 删除 </button></div> `; // 添加悬停效果 item.addEventListener('mouseenter', () => { item.style.background = 'rgba(26, 26, 46, 0.8)'; item.style.borderColor = 'rgba(201, 170, 113, 0.4)'; }); item.addEventListener('mouseleave', () => { item.style.background = 'rgba(26, 26, 46, 0.6)'; item.style.borderColor = 'rgba(201, 170, 113, 0.2)'; }); listContainer.appendChild(item); }); // 绑定按钮事件 this.bindUrlImageListEvents(); }, // --- 新增：绑定外链图片列表事件 --- bindUrlImageListEvents() { const listContainer = document.getElementById('url-images-list'); if (!$1) return; // 移除旧的事件监听器 if (this.urlImageListClickHandler) { listContainer.removeEventListener('click', this.urlImageListClickHandler); } // 创建新的事件处理器 this.urlImageListClickHandler = (e) => { const bgId = e.target.dataset.bgId; if (!$1) return; if (e.target.classList.contains('edit-name-btn')) { this.showEditImageNameModal(bgId); } else if (e.target.classList.contains('preview-btn')) { this.previewBackground(bgId); } else if (e.target.classList.contains('delete-btn')) { this.deleteUrlImage(bgId); } }; // 绑定新的事件监听器 listContainer.addEventListener('click', this.urlImageListClickHandler); }, // --- 新增：显示编辑图片名称模态框 --- showEditImageNameModal(bgId) { const bg = this.backgroundImages.find(b => b.id === bgId); if (!$1) return; const input = document.getElementById('edit-image-name-input'); const saveBtn = document.getElementById('save-image-name-btn'); if (!$1) return; // 设置当前名称 input.value = bg.name; // 移除旧的事件监听器 if (this.saveImageNameHandler) { saveBtn.removeEventListener('click', this.saveImageNameHandler); } // 创建新的保存事件处理器 this.saveImageNameHandler = () => { const newName = input.value.trim(); if (!$1) { this.showTemporaryMessage('图片名称不能为空'); return; } // 更新图片名称 bg.name = newName; this.saveBackgroundSettings(); // 刷新列表 this.renderUrlImagesList(); // 如果背景设置模态框也是打开的，也刷新那个列表 if ($1 === $2) { this.renderBackgroundList(); } // 刷新UI界面的背景图列表 this.renderBackgroundList(); this.closeModal('edit-image-name-modal'); this.showTemporaryMessage(`图片名称已更新为：${newName}`); }; // 绑定保存事件 saveBtn.addEventListener('click', this.saveImageNameHandler); // 绑定回车键保存 const handleEnterKey = (e) => { if ($1 === $2) { this.saveImageNameHandler(); input.removeEventListener('keypress', handleEnterKey); } }; input.addEventListener('keypress', handleEnterKey); // 打开模态框并聚焦输入框 this.openModal('edit-image-name-modal'); setTimeout(() => { input.focus(); input.select(); }, 100); }, // --- 新增：删除外链图片 --- deleteUrlImage(bgId) { const bg = this.backgroundImages.find(b => b.id === bgId); if (!$1) return; this.showCustomConfirm(`确定要删除外链图片\"${bg.name}\"吗？`, () => { this.backgroundImages = this.backgroundImages.filter(b => b.id !== bgId); // 如果删除的是当前选中的背景，清除选择 if ($1 === $2) { this.selectedBackgroundId = null; } this.saveBackgroundSettings(); this.renderUrlImagesList(); // 如果背景设置模态框也是打开的，也刷新那个列表 if ($1 === $2) { this.renderBackgroundList(); } this.applyRandomBackground(); // 重新应用背景 this.showTemporaryMessage(`已删除外链图片：${bg.name}`); }, null, true); // keepCurrentModal = true }, }; // --- Entry Point --- // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 eventOn(tavern_events.APP_READY, () => { GuixuManager.init(); // 过滤无关的控制台错误，避免干扰调试 const originalConsoleError = console.error; console.error = function(...args) { const message = args.join(' '); // 过滤掉与归墟Plus无关的资源加载错误 if (message.includes('ui-icons') || message.includes('MIME type') || message.includes('stylesheet MIME type') || message.includes('404 (Not Found)')) { return; // 静默处理这些错误 } // 其他错误正常输出 originalConsoleError.apply(console, args); }; }); // 事件监听已在 GuixuManager.init() 中处理，此处不再需要 })(); </script></body></html> ``` \\n```",
  "trimStrings": [],
  "placement": [
    1
  ],
  "disabled": false,
  "markdownOnly": false,
  "promptOnly": false,
  "runOnEdit": false,
  "substituteRegex": [],
  "minDepth": null,
  "maxDepth": null
}